#!/bin/zsh
# The generated shell script will take a cores envvar for the -N# RTS flag.
#
# Based on a script michael sweet posted to the fltk mailing list.

if test $# -lt 1; then
    echo "Usage: $0 filename [icon.icns]"
    exit 1
fi

binpath="$1"
icon="$2"
name=$(basename "$binpath")
id=elaforge.seq.$(echo "$name" | tr ' ' _)
bindir="$binpath.app/Contents/MacOS"

if [[ $name = seq ]]; then
    default_cores=2
fi

if [[ -n $default_cores ]]; then
    rts_flags=(+RTS -N\${cores:-$default_cores} -RTS)
fi

# Make a shell script that runs the bundled executable
cat >"$binpath.run" <<EOF
#!/bin/sh
dir=\$(dirname "\$0")
exec "\$dir/$name.app/Contents/MacOS/$name" $rts_flags "\$@"
EOF
chmod +x "$binpath.run"

# Make sure the script is idempotent since make likes to run it due to .PHONY.
if [[ $(head -c2 $binpath) = '#!' ]] then
    echo replacing shell script
    mv $binpath.run $binpath
else
    rm -rf "$bindir"
    mkdir -p "$bindir"
    mv "$binpath" "$bindir"
    mv "$binpath.run" "$binpath"
    if [[ -n $icon ]]; then
        mkdir -p $binpath.app/Contents/Resources
        cp $icon $binpath.app/Contents/Resources/icon
        icon_info="<key>CFBundleIconFile</key> <string>icon</string>"
    fi
fi

# Make the simplest Info.plist needed for an application
cat >"$binpath.app/Contents/Info.plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<plist version="0.9">
    <dict>
        <key>CFBundleInfoDictionaryVersion</key>
            <string>6.0</string>
        <key>CFBundleExecutable</key>
            <string>$name</string>
        <key>CFBundleIdentifier</key>
            <string>$id</string>
        <key>CFBundleName</key>
            <string>$name</string>
        <key>CFBundlePackageType</key>
            <string>APPL</string>
        $icon_info
    </dict>
</plist>
EOF
