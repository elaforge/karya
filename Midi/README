Handle low level MIDI IO.  There are three things to do with MIDI: receive
MIDI, write MIDI, and send MIDI through, possibly filtering or modifying it.

This module also exports bandwidth readings for the midi ports so you can see
if you are saturating the bus.


    Write:
C code receives timestamped MIDI events and sends them to the OS driver

At end of MidiRender:
midi_render :: NoteList -> [(Port, Timestamp, MidiMsg)]
render thread: mapM_ Midi.write_msg (midi_render notelist)

Midi.write_msg (port, timestamp, msg) = c_os_dependent_write port timestamp msg

-- | Schedule msg to be run asynchronously at given time.
-- write_msg may block if the given Timestamp is too far in the future,
-- to avoid flooding OS data structures with too much midi.  So you should
-- call this with a monotonically increasing Timestamp.
write_msg :: Port -> Timestamp -> MidiMsg -> IO ()
-- | Synchronously write msg right now.  Good for sysex msgs.
sync_write :: Port -> MidiMsg -> IO MidiError
-- MidiFile module also has
-- write_midi_file :: WriteFile -> [(Port, Timestamp, MidiMsg)] -> IO ()

-- Clear the output queue.  The write bandwidth queue should also be cleared.
abort :: IO ()

    Read:

MIDI drivers use a callback, so this is haskell code that registers and
configures a C callback.

-- | Return a list of ports attached to the system.
ports :: IO [Port]
-- | 'take_msgs' will start receiving msgs from Port, except ones matched by
-- MidiFilter.
open_port :: Port -> MidiFilter -> IO MidiError

-- | Stop receiving msgs from Port.
close_port :: Port -> IO MidiError

-- | Take the msgs received since the last call to 'take_msgs'.  Block
-- if there are no msgs available.
take_msgs :: IO [(Timestamp, MidiMsg)]

open_port(port) { add_read_callback(port, read_callback, read_data) }
read_callback(packets, read_data) {
    add_to_lockless_channel(read_data.chan, (read_data.port, packets))
    for msg in packets
        read_bw_buckets[port][msg.channel][timestamp/bw_resolution % nbuckets]
            += len(msg)
}
data MidiFilter = MidiFilter
    { filter_midi_realtime :: Bool -- throw away rt msgs
    }


    Monitor midi bandwidth:

-- | Read the next item from the bandwidth queue, blocking if it's not
-- available.  The Timestamp is rounded to the last 0.1 second, and the list
-- reports IO and a bytecount for it that happened during that second.
-- Since bandwidth is stored in a ring buffer, if you don't read from this
-- for a while you will lose data.
read_bandwidth :: IO (Timestamp, [(Port, Channel, in_bytes, out_bytes)])

c_os_dependent_write can stick byte counts in the write_bw array right away:
write_bw_buckets[port][channel][timestamp/bw_resolution % nbuckets]
    += msglen - running_status

The C read callback does the same with with read_bw_buckets.

    Errors:
data MidiError
    = BadPortName 
    | ...  -- errors returned by midi driver


    Monitor playback transport position:

Do I really need this?  Since I know when a said the msgs should be sent,
I just advance the play position 1 per sec.  So this is actually communication
from the Notelist to its generating block, kicked off by the start play
machinery.


    Thru:

Since incoming midi is transformed to Score and back in an arbitrary way, there
is no way to do thru such that the thru notes sound as they would played back
from Score.  However, instruments that have a simple correspondence to a single
(port, channel) can set thru correspondingly, at the least to provide
a reference pitch when you play.  The simplest thing is to remap the port and
channel:

-- | Configure the read callback to remap incoming msgs out a send port.
configure_thru :: ConfigureThru -> IO MidiError

data ConfigureThru
    -- Nothing port is all ports, Nothing channel is all channels,
    -- Nothing dest means throw away the msgs
    -- Turn off Thru with (Remap (Nothing, Nothing) Nothing)
    = Remap (Maybe Port, Maybe Channel) (Maybe (Port, Channel))
    -- All msgs go through unchanged.
    | Reset
type Channel = Int -- 0--15
type Port = String -- port name

Some instruments may map midi keys, i.e. map them to a different scale or
transpose them.  It would be nice to be able to hear the scale played thru.
If the scale is implemented as midi nns, then this is easy.  If the scale is
sent as nn + pitch bend, the thru layer would have to do some nontrivial
transformation.  Scales may also contain other controller values.  This means
mapping nn to (nn, pitch bend, controller, ...), and possibly distributing the
output over multiple midi channels.

Can this be done in haskell or must it be done at the C level for acceptable
latency?  A simple map of 128 nns to [msg] would be easy to pass to C, but if
they need to e.g. depend on velocity things get harder.  If latency is ok,
I can just give C a haskell callback to calculate 'input_msg -> [msg]'.

Since this requires going to haskell, I can just implement this as a wrapper
around take_msgs that may call write_msg.

Regardless, each midi instrument needs a separate set of rules about how to do
thru.  Selecting one of an instruments tracks should install its thru
preferences.



    How other people do timing:

tutka tracker:

while 1
    if player->sched in RTC, NANOSLEEP
        next = small val depending on BPM (1000000/((BPM/60)*24) usecs)
        gettimeofday(now, NULL)
        if sched == NANOSLEEP
            req = next - now
            while (nanosleep(&req, &rem) == -1)
                ;
        elif sched == RTC
            ioctl(player->rtc, RTC_PIE_ON, 0)
            while next-now > 1000000 / player->rtc_frequency
                long = read(player->rtc)
                now = gettimeofday
            while next - now > 0
                now = gettimeofday
    elif sched == EXTERNAL_SYNC
        if player->external_sync_ticks == 0
            g_cond_wait(player->external_sync, player->mutex)
        if player->external_sync_ticks > 0
            player->external_sync_ticks--

    for midi output: output->tick = player->tickssofar
    if sendsync: send 0xf8 on all outputs
    write midi notes that occurred in this row
