Indents are 4 spaces only.  Nothing is lined up vertically, and there are no
tabs.

No line is longer than 80 columns, not counting the newline.

All lower case names are lower_with_underscores even though it's not haskell
standard.  All upper case names are haskell standard CamelCase.

Operators are wrapped on the following line, with some exceptions like =, <-,
$.

Each module has a haddock comment, describing what it's for and what should go
in it.

Large comments use {- -} and their contents are indented.  This way
indentation based folding can get them out of the way.

Modules are imported like 'import qualified A.B.C as C', with very few
exceptions.  Therefore, names should generally not repeat the module name.
Preferably no two modules have the same file name, but if they do, they can be
imported along with their directory name, e.g. 'import qualified A.B.C as
B.C'.  They are sorted by the order in the 'fix-imports' file, and
alphabetically after that.  The order is automatically enforced by the
FixImports tool.

Major high level types tend to go in a module with their own name.  Many types
also often have a functional constructor with the lower cased name of the type
which may provide default arguments and whatnot.  Even though I don't
generally restrict the "real" constructor from module export list, you should
use the functional constructor when possible to insulate against changes to
the type.

All modules that call C end with "C", and are split up such that as few
modules as possible import them.  This is because ghci won't work it has to
import a module with foreign deps.  Technically it should be able to if you
give it the object files but I've never been able to get that to work.

Record fields are named rec_xyz, where 'rec' is an abbreviation of the record
type name.

Cmds begin with cmd_.  But not always.  I'm not very convinced of the value of
this convention.  The idea with cmd_ is that the cmd_* version is directly
bound to a key, and it will get various default parameters from context and
call the non-cmd_ prefixed version with more parameters.

Derivers begin with d_.  I'm even less convinced that this convention is
useful.

Most types should be in Show, for debugging and interactive use.  Types that
cannot use the automatic Show instance may derive their own.  If so, they
should emit valid haskell syntax because non-valid syntax will break
'Util.PPrint.pshow'.  In this case, they are surrounded by double parens
'((xyz))' to distinguish them from automatic instances.  Types that are likely
to be used from the REPL should have a 'Util.Pretty.Pretty' instance, and a
format method.  This way they can emit non-haksell descriptions and have it
format nicely.
