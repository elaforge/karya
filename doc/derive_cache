TODO: check out yi's approach to caching the results of incremental parsing:
http://yi-editor.blogspot.com/2008/11/incremental-parsing-in-yi.html

Derivation can be expensive, especially if there is a lot of data to derive.
Clearly rederiving the entire song on every edit is not going to very well.

Ideally, I rederive the minimum amount necessary to reflect the change that was
just made.  In the presence of fully general derivation, I can't really know
this since any event may generate some arbitrary amount of notes.

However, I should be able to make some simplifying assumptions and restrictions
to make the common case efficient.


    Memoize subderivations

This won't help you if you put the whole song in one giant block, but it's
probably reasonable to break things up into small-ish blocks, tracker style.
In that case, if I cache the result of deriving unchanged blocks then
rederiving the whole song only means rederiving the changed block and its
parents.  It would mean merging all the events which could mean a lot of
copying, but if this turns out to be a problem maybe I can come up with some
sort of tree-ish data structure that would remove the copying.

A subderivation depends on its controller environment, so the memo table would
look like: {(ControllerMap, Tempo) : [Event]}.  I can optimize the common case
of many derivatinos identical except for tempo offset by memoizing with an
offset of 0 and just adding the offset to the cached result.  Of course it does
mean they all have to be copied.

Unfortunately this still seems like it would involve a lot of expensive
comparisons looking things up in the table (e.g. dense controller curves).

Since I know the region that was edited, maybe I don't need to look in any memo
tables, I just rederive the modified section and merge it with the existing
data.




Individual block derivations can only be cached if they have the same
environment.  Tempo can be different if only the offset is different (then you
just add the offset difference to the events).

The important thing is detecting what needs to be regenerated.  In general it
can't be done, because a derivation may decide what to do based on any other
event, but in the vast majority of cases each event has no external dependency.

1 So if you edit a block derived from a parent, the parent should only
re-derive the sections covered by your block.  2 Similarly, if you edit
a region in a block, it only needs to rederive the edited region.  There also
needs to be a way for a deriver to signal that you can't do this though.


1 Each block has a memo table: {(ControllerMap, Tempo) : [Event]} as well as
Set BlockId for children.  When a parent wants to derive, the subderive first
looks at the memo table.  If there is already an entry, it just uses the events
directly.  If there isn't one, it calls the deriver, and if there are enough
events, puts them in the memo table.

When a block changes, its memo table is cleared.

If you make a lot of changes to the parent's controllers and don't change the
child, it could build up a big memo table.  Maybe I could clear old ones.

2 I may not need this, because 1:1 events is pretty cheap, and subderivations
are handled by #1.  I could do something like rederive the changed part and
just splice in the changed section.  I'd have to do this for everything in the
memo tabe though.

Given a change on a certain BlockId, that block's
[Events] must be rederived, and every block that has it as a child must
rederive.  Hmm, except that how can you derive a block in isolation unless it's
the top one?

So the parent keeps {(Range, BlockId) : [Event]}.
