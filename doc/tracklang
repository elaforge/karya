Tracklang is... TODO

    Symbols

Scores are more likely than most text to make use of many symbols.  So it may
seem strange that the tracklang does not support unicode identifiers.  Instead
it supports a backtick notation: text inside of backticks `like this` is looked
up in a table that maps symbol names to symbol glyphs, which may include
one or more unicode glyphs but also placement and rotation.  The name to glyph
map is declared statically in the source.

This design has several motivations.  Firstly, the major problem with unicode
is how to type it.  Even though I'm used to switching between several IMEs it's
still a hassle.  And it hurts interoperability since not everyone uses or even
can use the same IMEs.  Fltk doesn't support IMEs anyway.  Secondly, you have
to be able to say which font to get a glyph from.  Even unicode doesn't include
all the symbols that maybe used in a score, and without font information the
score no longer shows up correctly anywhere but the original author's computer.
Thirdly, many symbols are compositions of existing symbols, e.g. a number with
a dot above it.  So plain unicode glyphs aren't going to be enough anyway.

Cons of the design are that you don't get the convenience of a full-fledged IME
for selecting characters, and that adds some overhead to each new symbol you
want to introduce, since you have to manually add it to a table.

In fact, identifier naming is more strict than most programming languages.
Only lowercase letters a-z, digits 0-9, and the hyphen are allowed.  IDs also
allow `s so BlockIds can embed symbols.  This enforces a lowercase-with-hyphens
naming scheme.  The exact definition is in 'Derive.ParseBs.p_ident'.

The intent of the restrictive rules are that they relieve me of the burden of
remembering a naming scheme (e.g. '.' vs. '-' vs. '_') and leave room for
flexibility in other places (e.g. @-macros in the REPL).

Call names are a notable exception.  A call name can be anything without spaces
in it.


    Special Calls

" - Repeat the text of the last event.

-- - Comment, skipped by the deriver, useful to manually set a block end past
the last event.


    Typed Numbers, Typed Controls

Numeric values can have a type suffix.  For instance, 3d means that the number
is intended to be interpreted as a transposition of 3 diatonic steps.
Similarly, control names can have a type suffix, such as delay:r.  This means
that the values of the control are intended to be interpreted as 3 RealTime
seconds.

Of course, whether or not they are so interpreted depends on the call that
winds up receiving them.  Calls that expect an amount of transposition will
accept 'd' and 'c', and untyped numbers will be interpreted as 'c'
(chromatic).

Many numbers and controls are untyped and will ignore any type on a value or
control.  The type mechanism is intended only as a way of overloading certain
calls.  For example, it would be awkward to include all combinations of trills
on diatonic or chromatic neighbors, and in score time or real time.  It's
easier to have one control that can be passed a diatonic or chromatic
neighbor.

All type codes are enumerated in Derive.BaseTypes.Type.


    Built-in Controls

dyn - Maps to velocity for most instruments, but maps to breath for instruments
with the Pressure flag.

start-rnd, dur-rnd - Randomize note starts and durations.  It will only ever
make notes shorter to avoid causing overlaps, which thanks to MIDI can cut-off
notes prematurely.

t-diatonic, t-chromatic, t-hz - ... TODO
