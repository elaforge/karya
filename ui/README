    c++ style conventions:
declaration order:
public, protected, private
methods, data, widgets

    Memory management:

Since multiple BlockViews can share a BlockModel, and multiple TrackViews (in
different BlockViews) can share a TrackModel:

BlockModel, EventTrackModel, and RulerTrackModel all implement a reference
counting scheme.  DividerTrackModel is too trivial to be shared.  Objects that
have subobjects of this kind call a decref method on them instead of deleting
them directly.

When you delete a model, it decrefs.  If there are views on the model, their
refs should keep it alive until they are destroyed.

Views hold shared_ptrs to models.  When all views to a model are destroyed
(views are destroyed explicitly), the model will be destroyed.  At that point,
the model's views pointers should be empty because each view removes itself
from the list in its destructor.


    Tracks

A track can be one of three types: an event track, containing note data,
a ruler track, like the block ruler view, and a divider, which is meant to
visually break up tracks or represent collapsed tracks.

Their implementation is somewhat unsatisfying.  TrackView is an abstract base
class with the various kinds of tracks as subclasses, but TrackModel is
a struct with pointers to all of them.  Anyone wanting to convert a model to
a view (BlockView::insert_track) or marshal between haskell and C needs to do
case analysis.  Places to change if another kind of track is added:

BlockView: insert_track, remove_track
c_interface: insert_*_track, track_at
