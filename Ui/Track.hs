-- Copyright 2013 Evan Laforge
-- This program is distributed under the terms of the GNU General Public
-- License 3.0, see COPYING or http://www.gnu.org/licenses/gpl-3.0.txt

-- | The 'Track' type and supporting functions.
module Ui.Track where
import qualified Control.DeepSeq as DeepSeq
import qualified Data.Map as Map

import Util.Control
import qualified Util.Pretty as Pretty
import qualified Ui.Color as Color
import qualified Ui.Event as Event
import qualified Ui.Events as Events

import qualified Derive.Score as Score
import qualified Perform.Signal as Signal
import qualified App.Config as Config
import Types


-- * track

data Track = Track {
    track_title :: !Text
    , track_events :: !Events.Events
    -- | Similar to 'Event.Event.style', you can individually configure track
    -- bg color, but in practice I do it automatically at the low level with
    -- 'TrackBg'.
    , track_bg :: !Color.Color
    , track_render :: !RenderConfig
    } deriving (Eq, Show, Read)

instance Pretty.Pretty Track where
    format (Track title events _bg render) =
        Pretty.record (Pretty.text "Track" Pretty.<+> Pretty.format title
                Pretty.<+> Pretty.format render)
            [ ("events", Pretty.format events)
            ]

-- | Construct a new Track.
track :: Text -> Events.Events -> Track
track title events = Track
    { track_title = title
    , track_events = events
    , track_bg = Config.track_bg
    , track_render = line_render
    }

empty :: Track
empty = track "" Events.empty

instance DeepSeq.NFData Track where
    rnf track = DeepSeq.rnf (track_events track) `seq` ()

modify_events :: (Events.Events -> Events.Events) -> Track -> Track
modify_events f track@(Track { track_events = events }) =
    track { track_events = f events }

set_events :: Events.Events -> Track -> Track
set_events events = modify_events (const events)

type SetStyle = (TrackBg, Event.EventStyle)

-- | High level SetStyle, with information provided automatically.
-- Bool is true if the track has note track children.
--
-- It's a bit awkward to have two SetStyles, but some information can only be
-- supplied by "Ui.Sync".
type SetStyleHigh = (TrackBg, Bool -> Event.EventStyle)
type TrackBg = Track -> Color.Color

-- * track signal

data RenderConfig = RenderConfig {
    render_style :: !RenderStyle
    , render_color :: !Color.Color
    } deriving (Eq, Show, Read)

no_render :: RenderConfig
no_render = RenderConfig NoRender Config.render_color

line_render :: RenderConfig
line_render = RenderConfig (Line Nothing) Config.render_color

instance Pretty.Pretty RenderConfig where
    pretty (RenderConfig style color) = Pretty.pretty (style, color)

-- | RenderStyles can take an optional source which says which control the
-- signal comes from.  This is only for note tracks, and will extract the
-- final signal from the events and display that.
--
-- Non-note tracks will ignore the RenderSource, and note tracks will ignore
-- a RenderStyle without a RenderSource.
data RenderStyle = NoRender | Line !(Maybe RenderSource)
    | Filled !(Maybe RenderSource)
    deriving (Eq, Read, Show)

data RenderSource = Control Score.Control | Pitch (Maybe Score.Control)
    deriving (Eq, Read, Show)

instance Pretty.Pretty RenderStyle where pretty = show

set_render_style :: RenderStyle -> Track -> Track
set_render_style style track =
    track { track_render = (track_render track) { render_style = style } }

-- | Each TrackId has a TrackSignal associated with it.
-- signal derivation failed.  I include both possibilities because I want to
-- ensure that TrackSignals can be derived lazily.  This is because in
-- addition to UI rendering, some Cmds may inspect TrackSignals but I don't
-- know which ones in advance.  Since getting the track signal means deriving
-- the control track again to get it in ScoreTime, I want to avoid doing that
-- if no one is interested in the result.
--
-- The log msgs for a successful derivation are discarded, I assume that
-- anything interesting will have been logged by the normal signal derivation.
--
-- There's no particular reason a ruler couldn't also have a signal in it,
-- except that it might look a little crowded.  But RulerId isn't supported.
-- If there's ever a need I can add it.
type TrackSignals = Map.Map (BlockId, TrackId) TrackSignal

-- | Similar to 'Derive.Derive.TrackWarp's, the signal generated by signal
-- tracks is stashed away in TrackSignals during derivation so it can be sent
-- to the UI for display.
--
-- Signals are in real time, but the UI wants to display them in score time.
-- If the block happens to have a linear warp then the mapping is trivial, and
-- I don't have to bother generating another signal just for display.  However,
-- if there is a non-trivial warp, the signal will have to be rederived in an
-- id warp.
data TrackSignal = TrackSignal {
    ts_signal :: !Signal.Display
    , ts_shift :: !ScoreTime
    , ts_stretch :: !ScoreTime
    , ts_is_pitch :: !Bool
    } deriving (Show, Eq)

instance Pretty.Pretty TrackSignal where
    format (TrackSignal sig shift stretch _is_pitch) =
        Pretty.record (Pretty.text "TrackSignal"
                Pretty.<+> Pretty.format (shift, stretch))
            [("signal", Pretty.format sig)]

instance DeepSeq.NFData TrackSignal where
    rnf (TrackSignal sig _ _ _) = DeepSeq.rnf sig

-- | Not a monoid because there's no mempty and since I take shift and stretch
-- from the first TrackSignal it's not really commutative.
--
-- TODO I forget now exactly why I had to do this instead of just using (<>)
-- like normal, but I think it was because the signal chunks are not
-- necessarily merged together in track time order, and they may wind up with
-- extra samples at 0.
merge_signals :: TrackSignal -> TrackSignal -> TrackSignal
merge_signals tsig1 tsig2 = tsig1
    { ts_signal = Signal.interleave (ts_signal tsig1) (ts_signal tsig2) }
