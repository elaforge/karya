-- | The 'Track' type and supporting functions.
module Ui.Track where
import qualified Control.DeepSeq as DeepSeq
import qualified Data.List as List
import qualified Data.Map as Map

import qualified Util.Log as Log
import Ui
import qualified Ui.Color as Color
import qualified Ui.Events as Events

import qualified Perform.PitchSignal as PitchSignal
import qualified Perform.Signal as Signal


-- * track

-- -- | Constructor for tests, analogous to 'Event.event'.
-- event :: ScoreTime -> ScoreTime -> String -> PosEvent
-- event start dur txt = (start, Event.event txt dur)

data Track = Track {
    track_title :: !String
    , track_events :: !Events.Events
    , track_bg :: !Color.Color
    , track_render :: !RenderConfig
    } deriving (Eq, Show, Read)

-- | Construct an empty Track.
track :: String -> [Events.PosEvent] -> Color.Color -> RenderConfig -> Track
track title events bg render =
    Track title (Events.insert_events events Events.empty) bg render

instance DeepSeq.NFData Track where
    rnf track = DeepSeq.rnf (track_events track) `seq` ()

modify_events :: (Events.Events -> Events.Events) -> Track -> Track
modify_events f track@(Track { track_events = events }) =
    track { track_events = f events }

set_events :: Events.Events -> Track -> Track
set_events events = modify_events (const events)

-- * track signal

data RenderConfig = RenderConfig {
    render_style :: !RenderStyle
    , render_color :: !Color.Color
    } deriving (Eq, Show, Read)

data RenderStyle = NoRender | Line | Filled
    deriving (Eq, Show, Read)

set_render_style :: RenderStyle -> Track -> Track
set_render_style style track =
    track { track_render = (track_render track) { render_style = style } }

-- | Each TrackId has a TrackSignal associated with it, or log msgs if the
-- signal derivation failed.  I include both possibilities because I want to
-- ensure that TrackSignals can be derived lazily.  This is because in
-- addition to UI rendering, some Cmds may inspect TrackSignals but I don't
-- know which ones in advance.  Since getting the track signal means deriving
-- the control track again to get it in ScoreTime, I want to avoid doing that
-- if no one is interested in the result.
--
-- The log msgs for a successful derivation are discarded, I assume that
-- anything interesting will have been logged by the normal signal derivation.
--
-- There's no particular reason a ruler couldn't also have a signal in it,
-- except that it might look a little crowded.  But RulerId isn't supported.
-- If there's ever a need I can add it.
--
-- TODO this is by TrackId, but shouldn't it be by (BlockId, TrackNum)?  The
-- same track could derive a different signal in a different context.
type TrackSignals = Map.Map TrackId (Either [Log.Msg] TrackSignal)

-- | Similar to 'Derive.Derive.TrackWarp's, the signal generated by signal
-- tracks is stashed away in TrackSignals during derivation so it can be sent
-- to the UI for display.
--
-- Signals are in real time, but the UI wants to display them in score time.
-- If the block happens to have a linear warp then the mapping is trivial, and
-- I don't have to bother generating another signal just for display.  However,
-- if there is a non-trivial warp, the signal will have to be rederived in an
-- id warp.
data TrackSignal = TrackSignal {
    ts_signal :: !Signal
    , ts_shift :: !ScoreTime
    , ts_stretch :: !ScoreTime
    } deriving (Show, Eq)

data Signal =
    Pitch !PitchSignal.PitchSignal !ScaleMap
    | Control !Signal.Display
    deriving (Show, Eq)

-- | ScaleMaps are sorted by their scale degree number.
newtype ScaleMap = ScaleMap [ValName] deriving (Show, Eq)
newtype ValName = ValName (Double, String) deriving (Show, Eq)

make_scale_map :: [(String, Double)] -> ScaleMap
make_scale_map = ScaleMap . map ValName . List.sort . map (\(a, b) -> (b, a))
