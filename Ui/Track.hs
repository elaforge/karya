-- | The 'Track' type and supporting functions.
module Ui.Track where
import qualified Control.DeepSeq as DeepSeq
import qualified Data.List as List
import qualified Data.Map as Map

import Ui
import qualified Ui.Color as Color
import qualified Ui.Events as Events

import qualified Perform.Signal as Signal
import qualified Perform.PitchSignal as PitchSignal


-- * track

-- -- | Constructor for tests, analogous to 'Event.event'.
-- event :: ScoreTime -> ScoreTime -> String -> PosEvent
-- event start dur txt = (start, Event.event txt dur)

data Track = Track {
    track_title :: String
    , track_events :: Events.Events
    , track_bg :: Color.Color
    , track_render :: RenderConfig
    } deriving (Eq, Show, Read)

-- | Construct an empty Track.
track :: String -> [Events.PosEvent] -> Color.Color -> RenderConfig -> Track
track title events bg render =
    Track title (Events.insert_events events Events.empty) bg render

instance DeepSeq.NFData Track where
    rnf (Track title events bg render) = title `seq` DeepSeq.rnf events
        `seq` bg `seq` render `seq` ()

modify_events :: (Events.Events -> Events.Events) -> Track -> Track
modify_events f track@(Track { track_events = events }) =
    track { track_events = f events }

set_events :: Events.Events -> Track -> Track
set_events events = modify_events (const events)

-- * track signal

data RenderConfig = RenderConfig {
    render_style :: RenderStyle
    , render_color :: Color.Color
    } deriving (Eq, Show, Read)

data RenderStyle = NoRender | Line | Filled
    deriving (Eq, Show, Read)

set_render_style :: RenderStyle -> Track -> Track
set_render_style style track =
    track { track_render = (track_render track) { render_style = style } }

-- | There's no particular reason a ruler couldn't also have a signal in it,
-- except that it might look a little crowded.  But RulerId isn't supported.
-- If there's ever a need I can add it.
type TrackSignals = Map.Map TrackId TrackSignal

-- | Similar to 'Derive.Derive.TrackWarp's, the signal generated by signal
-- tracks is stashed away in TrackSignals during derivation so it can be sent
-- to the UI for display.
--
-- Signals are in real time, but the UI wants to display them in score time.
-- If the block happens to have a linear warp then the mapping is trivial, and
-- I don't have to bother generating another signal just for display.  However,
-- if there is a non-trivial warp, the signal will have to be rederived in an
-- id warp.
data TrackSignal = TrackSignal {
    ts_signal :: Signal
    , ts_shift :: ScoreTime
    , ts_stretch :: ScoreTime
    } deriving (Show, Eq)

data Signal =
    Pitch PitchSignal.PitchSignal ScaleMap
    | Control Signal.Display
    deriving (Show, Eq)

-- | ScaleMaps are sorted by their scale degree number.
newtype ScaleMap = ScaleMap [ValName] deriving (Show, Eq)
newtype ValName = ValName (Double, String) deriving (Show, Eq)

make_scale_map :: [(String, Double)] -> ScaleMap
make_scale_map = ScaleMap . map ValName . List.sort . map (\(a, b) -> (b, a))
