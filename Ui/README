    OVERVIEW

This is the interface between the C++ implementation of the UI (which is in
fltk/) and the rest of the app.

    BlockC, UiMsg, Initialize

The lowest level is in the various *C modules, which contain code to serialize
the haskell versions of the sequencer state to the c++ versions, and imported
functions that directly call the C++ code.  Since the haskell FFI can't talk
directly to C++, they actually call an API defined in c_interface.h, which
basically just re-exports the relevant C++ methods, and does things like
serialize C arrays to C++ vectors.  BlockC is actually the only module with
foreign calls in it, since all C++ calls go through BlockViewWindow.

If BlockC is for haskell -> C++ communication, UiMsg is for C++ -> haskell
communication.  The UI emits UiMsgs in response to mouse and keyboard actions.
UiMsg deserializes those and puts them on a channel for the rest of the app.

Initialize ties the UI handling together.  All UI actions are run in a single
bound haskell thread to due to OS limitations and to avoid races in the C++.
Initialize has functions to start that thread and communicate with it.

    Block, Ruler, Track, Event, Sync, Diff

Most of the UI data like widget sizes and tracks displayed is small and is just
copied to the C++ layer, which basically maintains a mirror image of the
haskell state, but note and ruler data is passed to C++ as callbacks.

The UI level data structures are declared in Block, Ruler, Track and Event.
These are all tied together by State, which represents the complete app state,
at the UI level at least.  State also maintains the block -> block view mapping
(also track -> track view), since the C++ layer has no notion of sharing
a block between multiple views.

On every change to the State (which is immutable), the displayed portions have
to be synced with the C++ state.  Recreating all the windows from scratch on
every change would be slow and look ugly, so the Diff module generates a set of
Updates needed to change one State to another, and the Sync module then applies
those by calling the action BlockC functions.


    Code conventions

Haskell types should be converted to C types with Util.c_*.  This can do range
checking if necessary.  This is because haskell Integers can be larger than
CInts.  TODO but I don't use those, rethink this bit.  At the least, this
provides an easy way to grep for hs->c conversions.

Functions in the UI monad make calls to FLTK and must be called in the ui
thread so they are serialized in the main thread (this is a requirement for
some OSs).  Functions with IO types don't call FLTK and can be run from any
thread concurrently.



    OVERVIEW

There is no EventView because the blocks-as-macros functionality should allow
you to put a single event in multiple places already.

measures <- Ruler.create_marklist [mark, ..]
sections <- Ruler.create_marklist [...]
ruler1 <- Ruler.create bg_color [measures, sections]

block1 <- Block.create block_model_config
block2 <- Block.create block_model_config

-- two views of one block
view1a <- Block.view block_view_config block1
view1b <- Block.view block_view_config block1
Block.zoom view1b (Zoom 1.5sec 2)
Block.close view1b -- destroy view

track1 <- Track.create
Block.set_ruler_track block1 ruler1 20
Block.insert_track block1 0 (Block.R ruler1) 20
Block.insert_track block1 1 (Block.T (ruler1, track1)) 60
Block.insert_track block1 2 (Block.D Color.blue) 5

-- block2 also has the same track
Block.insert_track block2 0 (Block.T (ruler1, track1)) 100


kbd_map = [
    (Key.down_arrow, \active -> next_minor (Event.active_block active)),
    (Key.insert, \active -> insert_event (Event.active_track active)),
]

ins_sel = 0
next_minor blockv = do
    pos <- Block.selection blockv ins_sel
    ruler <- Block.get_ruler_track (Block.model blockv)
    sel <- Block.get_selection blockv ins_sel
    Block.set_selection blockv ins_sel (next_mark (rank 1) ruler (sel_pos sel))

insert_event blockv trackv = do
    pos <- Block.selection blockv ins_sel
    Track.insert_event (Track.model trackv) ""


threading
A haskell thread, in its own os thread, loops on Fl::wait(), passing back
events as they come.  Every time wait() returns, it clears out a channel of
incoming IO actions to perform on the UI.  Sending an action on the channel
triggers the wait() to release, by calling Fl::awake().



The 'send' function ships actions to the ui thread to execute.  To keep the ui
thread from doing too much work I should make sure it's strict as possible.
Easiest way I can think of to do this is to only send c_something calls since
the args have been serialized... or could that by lazy too?

Or, I can have the various args get !s?


The problem is to always execute actions from the same thread.  Solutions:

Need to be single threaded:
create view
modify view (model modification counts too)

Don't need to be single threaded:
query model
query view (make sure that all values are stored in the class, not the widget,
so e.g. title is set by fl_input callback)

Onle the write actions should trigger coming out of wait()... but then I guess
even reads should be serialized.  If there are certain things that get called
a lot maybe I could put the lock in the c++?

In any case, it would be good to abstract away 'send_action' so I just call the
functions and they work right.


    Implementation

The XImpl modules implement the actual c interface.  The corresponding
X modules call send_action as necessary, first fully evaluating their arguments
to prevent the ui thread hanging up on thunks.

The opaque raw implementation types Block, BlockView, etc. contain the pointer
or foreign pointer to the C structure and then auxiliary haskell data along for
the ride.  Some of this data (e.g. the Block of a BlockView) could technically
be derived from the C struct, but it's easier to get it from the haskell type.


    Where data is stored

Ultimately, track and event data is stored in the c++ *Model classes.  This
gives the view classes easy access to the data they need to draw.  However,
their is auxiliary data associated with blocks and tracks that the GUI doesn't
need, so I have two choices for storing data:

- Store all data in the c++ classes.  This means it's in only one place, but
I need to do awkward and inefficient cross language marshalling to get it from
c++ to haskell.  It also means all access is serialized through the ui thread,
but since this is shared mutable data, access needs to be serialized in some
way anyway.  If it turns out complete serialization is hurting read access
which could happen concurrently, I would have to put shared locks in at the
c++ level and specify that some c_interface.h functions can be called outside
the ui thread.  To store auxiliary haskell data, I have to put a "data" ptr
into the c++ classes, and export that as a stable ptr from haskell, casted to
void* and back.

- "Cache" some or all data in the haskell types.  With this scheme, Block and
Track data stores mutable references to haskell data locally.  This means
I don't have to ask c++ for that data (so I can avoid writing peeks for e.g.
config data), and concurrent access is easier since I can serialize around
a haskell mvar.  The downside is that I have to store the data in two places,
which is an opportunity to get out of sync.

Block attrs: haskell only, mutable Map

Config data: 


    View validity

Views can be destroyed from the UI, so there's a chance a haskell view will be
stale, i.e. point to a deleted window.  To avoid concurrent delete issues in
c++, fltk must already serialize delete into the event handler.  So I just
serialize the deletes through the haskell event handler, which issues the
window destroys.  This lets haskell maintain a valid map for view ptrs.  All
view ops check for the ptr in the map, and since UI ops are all serialized,
the ptr will continue to be valid while the view op executes.

This only applies to block views, since I don't give direct access to any
other kind of view.
TODO: so what happens when you do a force close?
