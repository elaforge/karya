/// Syntax

I have:
A x(B(), c);

gcc thinks this is a function declaration taking a pointer to a
function that returns B and a 'c' with no specified type. I thought the
declaration for a pointer to a function than returns B would have to be
'B (*f)()' or 'B (*)()'.  Anyway, what I mean of course is 'A x = A(B(), c);',
only without the extra construction and assignment.  Is this interpretation
of 'A x(B())' according to the c++ grammar, or is it a bug in g++?

/// STL container use:

Is there a way to initialize an element directly in its container? If I
have, say, std::vector<X> and want to insert a new X, the standard way
initializes a default X and then copy-constructs the new X into it. This
doesn't work well with assignment / copy-constructor unfriendly classes,
like those that contain pointers and delete in their destructors, or
those with const references. Of course, a vector of pointers solves
that, but then I can't rely on the vector's destructor to clean up and
memory leaks become a possibility.

Whatever the way is, it can't involve passing my element-to-be-added as
an argument, since there's a copy constructor already right there.  The only
way I can think of is to write my own vector whose insert knows about the
arguments T's constructor wants:

template<class A, class B, class C, class D>
vector<T>::direct_insert(at, A arg1, B arg2, /* overloaded for more args */)
{
	// ... stuff with those uninitialized_memory functions...
	allocator.construct(_array + at, arg1, arg2, ...);
	// except that construct() only takes one arg, so we might have to say
	new(_array+at) T(arg1, arg2, ...);
}

Ok, this is looking kind of grody.  Vector of pointers is looking better now.
Tricky explicit memory management is what C++ is all about, right?

///

This is a generic OO question:

I have Widgets. I implement a zoom facility, and some widgets can be
zoomed and some can't. I want to do this by having a Zoomable type
so functions can say they want Zoomable widgets. But how do I have a
function say it wants something which is *both* a Widget and Zoomable,
along the lines of '(Widget x, Zoomable x) => x'? (CLOS doesn't let you
say '(x (and widget zoomable))', but I think dylan does.)

I could make a Zoomable_widget but Widget has a bunch of subclasses
(e.g. Group) and now if I want a Zoomable Group I have to create another
Zoomable_group class. And then what if I later have Frotzable objects?
Now I need Frotzable_zoomable_widgets, which has to inherit from both
Frotzable_widget and Zoomable_widget, which have to be changed to
specify Widget as a virtual base. This seems possible, but really kind
of awkward and grody and there must be a better way to do it.

/// More generic OO:

Abstract interface:

Iterator *Marklist::begin()
Iterator *Marklist::find(Trackpos, zoom, Iterator hint)
	// these must return dynamically allocated leakable pointers because
	// only pointers are polymorphic

Iterator::operator++
Iterator::operator==(Iterator o)
Mark Iterator::operator*

This won't work because find() wants an iterator of the correct type
(the same type it returns) as does Iterator::operator==, but the type
system can't guarantee that because the signature says *any* Iterator
is ok. I could have == and find() check at runtime with dynamic_cast if
they have been given appropriate Iterators, but the type system can't
help me if I insist on covariant arguments.

STL "solves" this by having no explicit relationships between
containers, but this means you can't substitute implementations at
runtime (since templates are compile-time), which is the whole point of
an abstract class.

The only way I can think to do this is for Marklist to be the only abstract
class, and for the iterators to be internal.  Unfortunately, there are
potentially many iterators for each marklist, and while I could have
external "iterator" which is simply an index into the internal iterator
array, that just seems really unpleasant.

///

Yeah, that's what I was trying to do. It was because according to
stroustrup, you can't overload template members and you have to
specialize, but apparently normal overloading is working for me?

The big picture is that I have a { Horizontal, Vertical} enumeration
and then lots of "if (enum == Horizontal) stuff-with-x-coords else
stuff-with-y-coords" sprinkled around. I can eliminate all that
by making the enum a class with time_pos and track_pos accessors
(time/track axes can be xy or yx) and then not talk about low level
xy at all. But I extract xs and ys from rectangle and point templates
(which look like rect.x) and widgets (which look like w.x()), so I need
template for points, template for rects, and function for widgets:

        template<class T> T time_pos(const Rect_tmpl<T> &w) const {
        return HV(w.x, w.y); } template<class T> T time_pos(const
        Point_tmpl<T> &w) const { return HV(w.x, w.y); } int
        time_pos(const Fl_Widget &w) const { return HV(w.x(), w.y()); }

I thought I had to specialize the Fl_Widget case with a template, like:

        template<> int time_pos(const Fl_Widget &w) const;

... but then gcc "says explicit specialization in non-namespace scope",
where it seems to like the overloading way just fine. I also tried:

        template<class T, class U> T time_pos(const U &o) const;

with the idea that then I could make rects and points be spelled p.x()
and unify everything, but gcc was having none of it ("no matching
function").

I was going to have Horizontal and Vertical be subclasses of
Orientation, but that leads to a huge pile of pure virtual methods in
Orientation, and huge piles of definitions in the subclasses. So I go
with the less ugly but still ugly HV macro which turns into (this->type
== .. ? .. : .. ).

It's way too much work for a simple abstraction but thanks to c++ and
static typing...
