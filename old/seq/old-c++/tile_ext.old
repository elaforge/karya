/*
class Scale_tile : public Fl_Tile {
public:
	enum Resize { Resize_upper_left, Resize_lower_right, Resize_proportional };
	Scale_tile(int X, int Y, int W, int H, char *label = 0) :
		Fl_Tile(X, Y, W, H, label),
		resize_horizontal(Resize_lower_right),
		resize_vertical(Resize_lower_right),
		min_size(0, 0)
	{};
	virtual void resize(int X, int Y, int W, int H);
	virtual int handle(int event);
	Resize resize_horizontal, resize_vertical;
	Point min_size;
};

void Scale_tile::position(const Point &from, const Point &to)
{
	short *p = sizes();
	p += 8;
	for (int i = 0; i < children(); i++, p += 4) {
		if (child(i) == resizable())
			continue;
		Rect orig = rect_from_sizes(p);
		Rect cur = rect_from_widget(child(i));
		if (from.x) {
			// if dragging child's x || orig right of from && cur left of to
			//   		|| orig left of from && cur right of to
			//	move this obj to to
			if (orig.x == from.x || orig.x > from.x && cur.x < to.x
					|| orig.x < from.x && cur.x > to.x)
				cur.x = to.x;
		}
	}
}

{
	case FL_PUSH:
		Point mind(100, 100);
		Point old(0, 0);
		for (i in children) {
			if (original right in frame && current top above mouse + area
				&& current bottom below mouse - area)
				t = distance from child right to event
				if abs(t) < mindx  // select closest child right
					sdx = t
					mindx = abs(t)
					oldx = original right
			
			if (closest child within grabarea)
				turn on sdrag, sx = oldx (closest child's original right edge)
			if (orig.r() < frame.r() && child.y <= evt.y + GRABAREA
					&& child.b() >= evt.y - GRABAREA) {
				int t = evt.x - child.r();
				if (abs(t) < mind.x) {
					sd.x = t;
					mind.x = abs(t);
					old.x = orig.r();
				}
			}
		}
}

void Scale_tile::resize(int X, int Y, int W, int H)
{
	short *p = sizes();
	const Rect old = rect_from_sizes(p);
	// const Rect old = rect_from_widget(this);
	const Rect d = Rect(X-old.x, Y-old.y, W-old.w, H-old.h);
	const double w_ratio = double(W) / old.w,
		h_ratio = double(H) / old.h;
	Fl_Widget::resize(X, Y, W, H);
	print_children(this);
	p += 8;
	for (int i = 0; i < children(); i++, p += 4) {
		Rect c = rect_from_sizes(p);
		// Rect c = rect_from_widget(child(i));
		switch (resize_horizontal) {
		case Resize_upper_left:
			if (c.x <= old.x)
				c.w += d.w;
			else
				c.x += d.w;
			break;
		case Resize_lower_right:
			if (c.r() >= old.r())
				c.w += d.w;
			break;
		case Resize_proportional:
			c.x = int((c.x - old.x) * w_ratio);
			c.w = int(c.w * w_ratio);
			break;
		}
		switch (resize_vertical) {
		case Resize_upper_left:
			if (c.y <= old.y)
				c.h += d.h;
			else
				c.y += d.h;
			break;
		case Resize_lower_right:
			if (c.b() >= old.b())
				c.h += d.h;
			break;
		case Resize_proportional:
			c.y = int(c.y * h_ratio);
			c.h = int(c.h * h_ratio);
			break;
		}
		child(i)->damage_resize(max(X, c.x + d.x), max(Y, c.y + d.y),
				min(W, c.w), min(H, c.h));
		// child(i)->damage_resize(c.x + d.x, c.y + d.y, c.w, c.h);
	}
	print_children(this);
}

int Scale_tile::handle(int ev)
{
  return Fl_Tile::handle(ev);
}

*/

