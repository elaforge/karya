#!/usr/bin/env python
"""usage: output.hs test_mod1.hs test_mod2.hs ...

Collect tests from the given modules and generate a haskell module that calls
the tests.

The generated haskell module takes either '-list', which will display the tests
it knows about, or a set of string prefixes, which will run only tests starting
with one of those prefixes.

Tests are divided into "interactive" and "plain", depending on whether they
use certain interactive assertions.

-- TODO: support noisy and quiet tests?
"""

import sys, os, re
import hs_pp

def main():
    out_fn = sys.argv[1]
    test_fns = sys.argv[2:]

    test_defs = {}
    for fn in test_fns:
        src = open(fn).read()
        line_map = [m.start() for m in re.finditer('\n', src)]
        def offset_to_line(offset):
            for i, off in enumerate(line_map):
                if off > offset:
                    break
            return i+1

        test_defs[fn] = []
        for match in re.finditer(r'^(test_[a-z0-9_]+?)( =.*\n(?:\s+.*\n|\n)*)',
                src, re.MULTILINE):
            test_defs[fn].append((match.group(1),
                offset_to_line(match.start()), match.group(2)))

    out = open(out_fn, 'w')
    out.write(hs_template % {
        'argv0': sys.argv[0],
        'imports': '\n'.join(map(make_import, test_fns)),
        'all_tests': ',\n    '.join(make_tests(test_defs)),
    })


def make_import(fn):
    return 'import qualified %s' % path_to_module(fn)

def path_to_module(path):
    return os.path.splitext(path)[0].replace('/', '.')

def make_tests(test_defs):
    out = []
    for fn, defs in test_defs.items():
        for (test_name, line, body) in defs:
            if has_interactive(body):
                name = 'interactive-'
            else:
                name = 'plain-'
            sym = '%s.%s' % (path_to_module(fn), test_name)
            name += sym
            out.append('Test %s %s %s %d'
                % (hs_str(name), sym, hs_str(fn), line))
    return out

def has_interactive(func_body):
    for (src, dest, is_interactive) in hs_pp.test_macros:
        if is_interactive and re.search(r'\b(%s|%s)\b'
            % (src, dest), func_body):
            return True
    return False

def hs_str(s):
    return '"%s"' % s.replace('"', '\\"').replace('\n', '\\n')


hs_template = r'''-- automatically generated by %(argv0)s --
import qualified Data.List as List
import qualified System.Environment
import qualified Util.Test as Test

%(imports)s

data Test = Test
    { test_name :: String
    , test_test :: IO ()
    , test_file :: String
    , test_line :: Int
    }

all_tests = [
    %(all_tests)s
    ]

main :: IO ()
main = do
    args <- System.Environment.getArgs
    case args of
        ["-list"] -> mapM_ putStrLn $ List.sort (map test_name all_tests)
        prefixes -> let tests = matching_tests prefixes in do
            putStrLn $ "running: " ++ comma_list (map test_name tests)
            mapM_ run_test tests

matching_tests prefixes =
    filter (\t -> any (`List.isPrefixOf` test_name t) prefixes) all_tests

run_test test = do
    Test.catch_line (test_file test) (test_line test) (test_test test)

comma_list = concat . List.intersperse ", "
'''


if __name__ == '__main__':
    main()
