Custom actions, derivers, interpolaters, keymaps, and whatever else are
compiled and inserted into the program.  They can be saved with song files and
in separate libraries to arbitrarily extend the sequencer for a given song.

TODO: how current is hs-plugins?  how does xmonad do this?


Code objects are stored in a namespace that maps (Symbol -> Dynamic).
Functions in Actions, Scores, and the keymap are referred to by name.  Since
the symbol table is dynamically typed, each function that looks up a dynamic
symbol must have a standard way to throw a type error.  Also, all dynamic code
must be monomorphic.

Symbols have namespaces to avoid name clashes when merging songs, or writing
general purpose libraries.

hmm, so two approaches:
Have a namespace, and then send msgs like 'symbol := monomoprhic_code'.
Serializing Actions and Scores requires symbolic names for the code, along with
a list of symbol assignments.

But then how do you write polymorphic functions?  And what namespace does
monomoprhic_code run in?  Then how do you intergrate a normal haskell module?

Maybe a special import declaration 'import ....' that will go in the implicit
module that monomoprhic_code is run in.  Then you write the plain haskell
separately.


But then wouldn't you write everything that way?  Easier to write a plain
haskell module than a special language.  But you still need a symbol table.


Ok, so the plugin system imports the module you give it (give a filename to the
UI).  It calls functions in there that you write for the dynamic bits.  Each
function in there has to put itself in the namespace like:

my_derive = id
derivers = Namespace
    [ ("my_derive", my_derive)
    ]

my_keymap (Msg (KbdMsg state 'h')) = h_action
my_keymap _ = ?
keymap = my_keymap

Now each Block has a deriver name like "Module.my_derive", and it will look in
Module.derivers.  Keys in its focus will be sent to Module.keymap.  Clearly
there should be an inheritance / overriding kind of thing so you can patch
specific behaviours in on top of general purpose ones, depending on the
situation:

    Keymap

Block has [Symbol].  Msg delivery goes through each Module.keymap until one
returns Just Action, then executes that action.  Actions can have a NextAction
which will resolve to the next action in the list.  This is so an action can do
something like "do what's normally bound to this key in addition to..." or "do
it n times".  Essentially each keymap entry is an around-method.  Newly created
blocks have prepend their own keymaps, and automatically inherit a standard
set.

    Deriver

This has many parts, which are extendable.


    tempo   inst1   pres    cont    |
0   40      g-1     1       vib 0   |
1   30              0       1       |

The interpretation of the tempo track is universal, and applies to the whole
block.  'inst1' only applies until the divider.

Score
[ Track "tempo" [(0, 40), (1, 30)]
, Track "inst1"


(tempo (lin [(0, 40), (1, 30)])
    (note "inst1" "g-1" 0 1
        [ control "pres" (lin [(0, 1), (1, 0)])
        , control "vib" (lin [(0, 0), (1, 1)])]))


Block level deriver
Track level deriver
How to treat the derived-from track (mute it?)

    Derivation use cases

tempo track
javanese style melody
merge controller curves
block macro expansion


    Interpolator



Dynamic bits:

Deriver : Score -> Score or Score -> NoteList
Interpolator
    : Array (TrackPos, ControllerValue) -> [TrackPos] -> [ControllerValue]
Keymap : Msg -> Maybe Action
    subsets like Map ([KbdState], Char) Action for kbd
