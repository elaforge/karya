- typed Signals
  - Control Float
  - Tempo Double
  - RelativePitch Pitch.Generic [Float] (output of relative pitch track)
  - GenericPitch Pitch.Generic [Float] (output of PitchSignal.convert)

  I can use phantom types and use all doubles, but if space is an issue
  most can be converted to floats and I can use typeclass for Float vs. Double.

- is Module.throw_srcpos not enabled?
- the +- at the beginning of a relative pitch is not necessary in a relative
  pitch track because the title already says it's relative

- warning if a relative pitch track is added to the no_pitch signal?  or
a relative control is the first one (but this is more ok)
- empty scale on a relative pitch track... can it inherit the scale in scope?
it only needs the per_oct

- make Score.ControlEvent which is returned by Derive.Control.d_control_track

- program to launch logview and seq together
- ^T on the cmdline prints stuff!?
- State.structure only used by Clip_test

- playback cursor seems to reset to the top after a play through
- subderived doesn't get the cursor on the second derive

CURRENT
  - Event.event_text should be Text instead of ByteString
  - compile_to_signals doesn't like relative pitch tracks?
  - compile_to_signals spams too much when there is an error
  - implement scale transpose in terms of to_generic and generic_add
  - logview: clickable stackpos
  - "drag selection" cmd is too spammy
  * relative control tracks
  * relative pitch tracks
  * reverse skel display arrow direction
  * convert Signal to only flat line segments
  * rename controller -> control
  - sub block: relative pitch track
    create with absolute pitch track, then 'pitch_to_relative bid tnum "4c-"'
  + track down ghc rts crashes
  - select track, st3 style select block, track
  * extend shouldn't clip current event to 0
  - enter note on existing note should change its length

  - demo piece: show nested tempos with "bouncing ball", expressive pitch
    track, non-trivial repl transformation (pitch tweak after big jump?)
    transcribe rejang w/ reyong patterns
  - cut + paste didn't work with a point paste

  - skel_display status can be two chars: Sm is solo+mute

  track management:
    - resize a bunch of tracks at once
    - collapse tracks down to minimum width?

  - editing for "pattern list" block
  - double click call to jump to its block?

- verify twelve ->midi mapping and range checking

note language
  - project specific bindings, e.g. for instrument names
  - calls, e.g. "` *1" does a rambat style jump
    "-/_\\/_" does the rejang cadence

MILESTONES
  0.1
    + scales and keyswitches
    + efficient thru
    - dense / efficient control signals
    - lazy signals
    - memoize deriver output, to avoid unnecessary rederivation
    - midi record / integrator
    - save undo history
    - linux and windows ports
  future
    - display / edit derivations inline
    - print scores
    - mouse oriented signal editing
    - freeze tracks / audio memoization: doc/freeze_track
    - vst host
    - sync with audio editor: jack or rewire
    - non-midi instruments

  far future
    - render audio
    - include audio inline

- make sure pitch terminology is consistent:
  KeyNumber = scale independent note, Note = note in scale,
  Pitch = freq easily mapped to and from nn, same as NoteNumber,
  NoteNumber = Midi.Key + decimal

----

- optimization: if a msg aborts or doesn't run any cmds, don't bother to run
diff.  except that hardly ever happens if I do shortcut thru

- per-project short aliases for inst names so you can fit them in tracks easily

display signal:
  cmd makes a change to a controller track
  diff (and cmd) generate TrackEvents update
  sync processes TrackEvents and TrackAllEvents and merges it with samples

  so where does sync get the samples?  I can pass it [(TrackId, Samples)]
  that comes from (Track, Signal), which comes from a partial derivation
  most derivers should be able to get that from the Skeleton

****
- switch to darcs hashed repo format
  darcs optimize --upgrade
  darcs optimize --pristine

note input / thru:
  - keyswitch support in midi thru
  - profile midi->midi thru and implement a fast path if necessary

bugs:
  - can share pitches doesn't consider a whole step transposition unshareable
  - is kbd entry letting keys like 1 fall through?
  - Edit.cmd_delete_time is still a little funky, an event with only 2 time
    steps is deleted, >2 is shortened.
  * graphical corruption when scrolling down
  - keymap collisions are logged twice
  * renaming the project makes the merged tracks get out of date
  * nudge a note event on a collapsed track doesn't nudge the pitch event
  * delete note event in command mode doesn't delete the pitch event
  - bring block windows to the front after a load

  * mousewheel scroll goes past the end
  * save saves with .state
  * loading with a window displayed 'error: unknown (vid "untitled/b0.v0")'
  * when loading a new state collapsed tracks are expanded

  - tracks with different tempos play correctly, but playback follows tempo
  - unparsed notes are played instead of dropped, it's because the pitch is
    dropped but not the note
  - bizarre hint importing requirements in Cmd.LanguageEnviron
  + track down ghc rts crashes
    * write a script that continually starts up to see if I can trigger it
    add -DS flag
    crash is when evacuating pinned memory, is it a foreign ptr?
    - run under valgrind

  - fltk: mute (i.e. change brightness) makes text get drawn twice
  - fltk: moving a track title while it's expanded doesn't work
  - hint refuses to compile when Cmd.NoteEntry emits a warning

cleanup:
  - setting some state like project directly through State won't update
    global status.  Maybe I could fix this and also avoid the scattered syncs
    by doing a special state diff after cmds
    sync: state_project, state_project_scale
  - Makefile: ghc --make doesn't understand the hsc -> hs link, which leads to
    manual inclusion of $(UI_HS) in the deps
  - remove Util.Log -> Perform.Warning import by translating IDs into strings?
    On the other hand, it's not unreasonable for logs to use other data types
  - having collapsed state in c++ is kind of error-prone, should I go back to
    trying to put it in haskell?

performance:
  speed and memory profiling:
    - respond to incoming notes
    - diff and modify UI
    - derive a large score
  - pause before starting background derive to avoid thrashing during edits?
  - use a lazy storeable vector for [Score.Event] and [Midi.Message] to save
    memory?
  random little hangs are annoying.  figure out what's going on.  GC?
    - timer can summarize one responder loop cycle?
    - get diff results is really slow
    from yi bug:
      * GHC triggers a major GC everytime Yi becomes active whenever user
      resumes typing
      * Major GC takes increasingly long time as number of object grows (as
      expected)
      So, we have to iron out all memory leaks.

  - send style id to c++ instead of all the style elements
  - strictify some basic datatypes with ! and {-# UNPACK #-}:
    Ui.Event, Midi.Message, Perform.Midi.Instrument.Instrument
  - collapsing a track shouldn't trigger a rederive
  caching:
    - in c++, cache marks and events from callback
    - cache track cmds for each track, update when the track title or skeleton
      changes
    - deriver caching, see doc/derive_cache

fltk:
  - draw arrows in SkeletonDisplay.cc properly
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  - bug: doesn't redraw after switching monitors
  - SeqInputs should display the right side of the text if they're too small
  UI Msgs
  Track
    / dividers can have separate color for upper part, for collapsable tracks
  event track
    - "currently edited" event shouldn't be hidden by previous ones
  Ruler
  MoveTile
    - only capture drag on a plain drag with no modifiers

logging logview:
  * use bytestrings?
  - implement clickable srcpos and StackPos
  - haskell and c++ use the same machine readable format
  - LogView should use Util.Fltk
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...
  - collapse duplicate lines
  - commands like Selection or MIDI thru generate too much log spam, maybe
    filter logs for those?

control
  scale markers on pitch signals
    - haskell will have to send [(String, Val)].  Either cache it or avoid
      cache problems by always passing it but keep as a a ForeignPtr in haskell.
    - fltk implementation
  - more render options, e.g. solid with color gradient
  dense sampled signals
    - efficient storage, preferably as a Signal so no conversion is necessary
    - display dense signals: omit text and trigger lines when zoomed out

Ui:
  - some kind of special highlight to indicate the active block
  - rethrow c++ exceptions as FltkError
  Track
    - events pass style as a uchar ID for consistency and memory savings
    - benchmark large TrackEvents
    more compact implemnetation than Data.Map?  profile first!
      - priorities: memory efficiency, persistent, merge speed (insert many)
        shallow tree of dense chunks?
        can I take advantage of non-overlap?  [(pos0, data), (pos1, end), ...]
        data Event = Event String StyleId | End | ControlVal Double
      - I think memory efficiency is more important than modification speed
    - modify IntMap for Word64s, add toDescList
      - send patch to libraries@haskell.org
    - track collapse
    * track mute
      - visual indication when both solo and mute is on
    * track merge
    - adjacent collpsed tracks are merged

skeleton:
  * splice track: adding a new track automatically links into the skeleton
  - parse skeleton in LanguageCmds

test:
  - tests count number of tests in addition to checks within each test
  - it should be possible to build only certain tests into RunTests

integrator / midi record:
  - implement

Cmd:
  ? a module with easy access to all GlobalKeymap cmds for cmdline access
  - cmd to give a view focus and bring it to the front
  - Cmd_test
  vi style keymap:
    - movement: hjkl, HJKL to move timestep+1 or skip to
      next inst track, bf to move timestep at block section rank, BF to move to
      top and bottom of block
    - esc and i for edit mode
    - number prefixed cmds?  not for now
  - selection scrolling should scroll so the next 2 timesteps are visible
  Keymap
    * check for key assignment collisions
    * support generic modifiers like any Shift, any Control, and Command
      (which becomes alt on a PC keyboard)
  Cmd.Edit
    * change note lengths
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - trackerlike note entry: entered events are all as long as the block
      (merge will clip them to the next event)
    - map selection through function
    - transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces
    * nudge events
    - a legato command that always goes to the next note would still be useful
    - method edit works in controller tracks
  Cmd.Selection
    * drag snap to timestep
    * extend selection with shift-arrow
  Cmd.TimeStep
    - snap to event begin/end

  Cmd.NoteTrack
    - record velocity if there is a velocity track
    - chord input, if there are multiple note tracks for this inst

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.Play
    - warn about unallocated instruments (Convert.verify)
    * make sure the whole stack is lazy
    - play loops
    * background derivation
    - start playing from top of displayed area
    - start playing from TimeStep before insert point

  Undo
    * implement undo and undo/redo cmds
    - figure out how to checkpoint just state diffs
    - add undo history to on-disk format

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice or delete time or a Meter into a ruler

  Cmd.Freeze
    - details in doc/freeze_track

Derive:
  derivers
    * control
    * tempo
      * multiple tempos per block
    * subblock derivation
  PitchTrack pitch
    * pitch signal should be Signal Relative so that they can be transposed
    * relative pitches, e.g. +5
  NoteTrack note
    - non-note commands: set random seed, ...
      do I want to set cc things from note or require a control track?
      pedals, fingered portamento, ....  I think not because it will screw up
      note initialization.  Also e.g. pedal will naturally want to apply to
      a bunch of tracks.  With a good way to collapse or hide controller
      tracks it should be ok to have its own track.
      I do want +attr -> cc for cc keyswitches.  Technically attrs also kinda
      overlap with controllers and need special support for initialization.
      They get that by being treated separate instruments.
    - leading ; means the command is evaluated for its effect but emits no note

  ControlTrack control
    * relative controller tracks, combined with an operator, so e.g. "+, *scale"
      adds to the pitch track, and "*, volume" multiplies with the volume track
      operators: +, *, min, max
    * just plain "i" means the previous val, to make timed slides easier
      "approach val" method to make pitch bend easier, or just insert two
      notes?  the former is higher-level...
      something like: a5- g2e1 b5-
      or "a5- ;; i ;; 2e, b5-", much better!

  scales
    - implement pengumbang pengisep
    - enharmonics for Twelve
    - just intonation
    - looks like fun: http://en.wikipedia.org/wiki/Bohlen-Pierce_scale

   - swap tracks keeping skeleton up to date

   - Control track management?  It should be possible to have a note or a bunch
     of note tracks with a bunch of control tracks and control the clutter.
     Ideas: collapse has limited usefulness when there are too many, even with
     color coding.  I could do this with logview: selecting a note track logs
     a list of its control tracks and whether they are hidden or not.  Clicking
     on one in logview will emit a cmd that will hide or show that track.
     Or I could use a UI for adding new controls too: click a track, then a cmd
     'add_control "vel"', this will unhide and focus the control if it exists,
     or create a new one and link it with the skeleton if it doesn't.  ^T is
     intended to create new note tracks, and they're only linked to tempo
     initially.

     This implies a slightly more generic and acme-ish system for logview:
     anything enclosed in {}s can be clicked and will be sent verbatim, even if
     it's in the catch line:

     -- title (tracknum): inst_name, allocation, [control tracks]
     Inst (track 1): fm8/inst1, fm8:0,1,2, [vel {hide 2}, pedal {show 3}]

  - suspend automatic derivation while there's a note down?  use Cmd.Mod
    instead of the note_id map since it should be more reliable.
  - block derivation memoization / caching
  - set instrument within note track, controller within control track
  - separate instrument track, as a kind of controller track
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - display derived blocks
  - 3 way merge for derived blocks

Perform:
  Player
    * flush midi output when I get a Stop
      * send patches upstream
  Midi
    * eliminate duplicate controller msgs
    * pitch signal rendering
    * support key switches

  Instrument
    - some kind of organized way to manage instruments and instrument config
    * backend-independent instrument def
    - some basic midi instrument defs for generic midi (dev, patch)
    * defs for z1 and vl1

  Signal
    - lazy implementation
    * implement Signal.equal
    - signal transformation derivers: +, *, /, min, max, ...
    * after implementing GUI drawing and transformation, reduce the
      proliferation of signal types
    - ensure that controllers are warped continuously by tempo

Instrument DB:
  - search lang supports quotes
  - search lang supports - to exclude a term
  - original file goes in a tag, not the text
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - now that PatchTemplate is gone, maybe I can use a simpler storage format
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi:
  * implement midi merging for midi thru
  * a single msg input thread instead of one thread per input port
  bandwidth
    - keep stats
    - display widget

misc ideas:
  * legato filter makes adjacent notes overlap a little, for keyed portamento
  - more complicated track names: "< legato < synth/inst" to pipe inst output
    through legato deriver
  - use "<" for tracks that generate data, ">" for ones that accept it, e.g.
    to display and merge a derived version
  - should be a documented extensible way to add new track types without
    modifying core ADTs

  - chord input... think about some kind of compact representation
  - if derivation needs event IDs, maybe I can use the value-supply package
  - safecopy package does version controlled serialization

  - think about yi's approach to keybindings as a parser and keybinding state
  - also investigate yi's approach to configuration

research:
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - learn about hs gtk for reference

future:
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
