* .depend doesn't have *.hsc -> *.h dependencies
- check use of Ints

fltk
  - set_selection should do nothing if the selection is the same as the last one
  * bug: if the first event is a modifier, it doesn't get emitted.  An fltk
    thing?
  * make TrackPos into an opaque type to let me be more free with impl.
    implement as int64 usec?  or since it's just block relative, I can use
    plain unsigned msec?
  * scroll
  * add info line at the bottom
  - zoom
  * selections
  * bug: one pixel drawing glitch at bottom of tracks
    it has something to do with FL_FLAT_BOX + FL_THIN_DOWN_BOX
  * bug: starting with an x,y offset makes BlockView confused
  * bug: resizing ruler to 0 crashes
  _ optimize redraw by implementing scroll and selection damage
  - scrolling should add text height to time_end()

  * change ZoomInfo to_trackpos and to_pixels to not use offset
  - resizing when you're scrolled should scroll back if there's nothing
    interesting

  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)

  UI Msgs
    - bug: arrow keys are still doing keynav, remove that
    - a special "system" window that receives events like "new block"
    - can I capture os x two-finger drag events?
      yes, they're reported as FL_MOUSEWHEEL, so I should scroll on mousewheel
    * convert EventCollectWindow to global EventCollector
    * remove the fltk default event handling, except for inputs
    * custom Msg type that includes events, as well as "new selection" and
      other UI actions
    * send msg_scroll_changed msgs
    * figure out how to go BlockView* -> BlockView in UiMsg
    - clicking outside of SeqInput should unfocus it

  Block
    - BlockView::set_config

  Track
    / dividers can have separate color for upper part, for collapsable tracks
    - tracks have their own status lines, to report things like mute
  event track
    * overlay ruler
    * events
    * bug: scrolling gets little one pixels shifts
    - bug: event tracks flicker when moving horizontally
  Ruler
    - include selection in time_end
    - scroll to keep moving edge of selection in view, go to bottom edge if
      both moved
    - mark text tries to wrap if there isn't enough room
    * don't clip out the text as soon as the marker scrolls off screen
    * clip markers when they overlap edge of widget
    - bug: looks like overlay is getting drawn twice when called from Interface
      after adding a selection
    * text labels

  MoveTile
    - only capture drag on a plain drag with no modifiers
    * bug: upper part of ruler track not getting resize?
      also not shrinking to the left
      hard to trigger this one
      ok, this happens whenever a stiff child is on the far left or far right
    * bug: I can resize a divider by dragging the right edge
    * bug: dragging divider jumps to dragging by left edge
    * dragging tracks should resize rightmost / bottommost widget like resize()
    * bug: moving a track off the right side chops it off
    _ bug: tracks close together seem to have a problem, and the arrow hot point
      isn't obvious.  highlight?  or a handle somehow?

logging
  - haskell and c++ use the same machine readable format
  - log to a file
  - log filtering / visualizing tool
  * add surrounding function to SrcPos

Ui
  * rename Interface -> Ui, ui -> fltk
  * UiMsg: use Key data type instead of Char for e.g. backspace
  * use main thread for ui
  * set block config
  - set block view config
  * BlockView.set_track_width, BlockView.get_track_width
  * track_at
  * Event
  * work old tests from TestUi into BlockC_test
  * always having to specify the color of a Selection is annoying, make
    CSelection automatically get it from block_selection_colors
  - set_block_status
  - set_track_status
  Diff
    * ErrorT
    * track width, track update (need diff hints?)
  State
    - quickcheck Arbitrary to generate States
  Track
    - benchmark large TrackEvents
    - modify IntMap for Word64s, add toDescList
      - send patch to libraries@haskell.org

Cmd
  * put keydown map in Responder to augment the context with midi note down and
    keydown
  * refactor UiMsg.UiMsg
  * add block_focus / MsgFocus msg type
  * put all stateful keys (kbd, mouse button, midi note) into keydown set
  * reintegrate handler and responder into new hstate, rename Msg->Cmd
  - Cmd_test
  - cmd_midi_thru - basic hardcoded midi thru command
  keymap
    * keymaps that combine key patterns into a table and create a Cmd
    - check for key assignment collisions
    - better functions to make KeySpecs
    - KeySpecs that don't care about the modifiers
    Cmd.Edit
      * edit mode
      + event insertion / deletion commands
      * set step interval
      * midi note insertion
      - alternate finale-like note entry: hold down step key to set step and
        turn on edit mode, but only while the key is down
      selection ops
        - transpose
    Cmd.Create
      - view and creation / deletion
      - track insertion / removal
    Cmd.TrackOps
      - collapse track to a divider, expand it back
      - mute / unmute

    Cmd.Selection
      * move insertion point
      * drag insertion point
      - drag snap to ruler, event beginning/end, ...
      * Cmd.TimeStep.advance etc. takes [Marklist]
      - tempo warp by selection

    - UI and fltk support for editing event text
    * UiMsgs for track drags, resizes, and text changes update State

  Cmd.Language: listen on a socket, receive cmd language?  or use hs-plugins?
    - simple commands to manage blocks, and save / restore state
    - pretty print various parts of state

  Cmd.Play
    * play position display
    - play loops
    - play from position
    - implement pause / resume with play from position

  Cmd.Record
    - come up with a plan for midi recording
    - implement simple midi underiver

  block / track keymap
    - signal track input keymap
    - track-dependent midi thru framework

  checkpoints
    * serialize / deserialize for State
    - Data.Binary instance for more efficient save and load
    - standalone dumper to convert the binary format to pretty-printed show
    undo
      - implement undo tree and undo/redo cmds
      - figure out how to checkpoint just state diffs
      - add undo history to on-disk format

Derive
  * simplest possible derivation -> midi render
  - Player.Position implementation for play selection, reverse tempo deriv
  - write some music!
  derive graph
    - sketch out design, think about typechecking, research phantom types
    - initial implementation
  derivers
    - signal
    - tempo
    - control

  - error reporting for deriver and renderer
  - display intermediate blocks
  - 3 way merge for intermediate blocks

  Derive.Render.Midi
    - signal rendering
    - controller and velocity for notes
    - Hz -> midi nn + pitch bend
    - pitch signal rendering

    * player blocks when it's n seconds ahead, to avoid flooding midi driver
    _ flush midi output when I get a Stop
      flush is complicated and it's easier to just live with n seconds of extra
      sound
      - complain to portmidi list?
    - channel allocator

Instrument
  - some basic midi instrument defs for generic midi (dev, patch)
  - defs for z1 and vl1

patchdb
  - simple integrated version with just hardcoded midi instruments

tests
  + some kind of organized hunit / quickcheck for pure code
  * I should be able to type 'make test' and it compiles and runs all automatic
    tests, make human_test to run interactive tests (with Test.io_human)
  * grep -v LINES hack for hsc hpc
  * speed up hs_pp
  - non-interactive version of io_human

Midi
  - midi thru: MVar (Port -> Message -> [(Port, Message)])
  - scheduler for out of order writes + thru?  how about I always write in
    order and don't allow timestamps on thru?
    no, I still need the scheduler, phooey.
    write WriteStream *OpenMergedOutput(WriteStream *stm, ...)
  * maybe move Device out of PortMidi and PortMidi out of Midi, this would mean
    Cmd/ wouldn't depend on foreign imports
  bandwidth
    - keep stats
    - display widget

Osc
  - does reaktor support timestamps?

research
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - draw antialiased lines and curves on os x
  - investigate hs-plugins and xmonad to see about hs plugin possibilities
    xmonad just recompiles the whole app
    I could actually do that at first too
  - learn about hs gtk for reference

future
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
