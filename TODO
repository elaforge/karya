UNSORTED
  Just scales, along with TwelveUtil support
    * simple just scale with no accidentals
    bugs:
      - kbd input isn't tuning the just scale properly
      - pitchbends getting lost, and being audible: save/bug-pitchbend*
    - test modulating and setting a new base hz
    - better retuning and gradual retuning
  - It's a bit unpleasant how I have TwelveUtils for accidental and key using
    scales, then Scale.Util for simple scales, and then Just is its own thing.
    Can I unify things into one framework?
  - Scale.InvalidTransposition isn't right for an nn out of range
    But that indicates a bug in the scale, right?
  - The base-C to base-A conversion is messier than it should be.  Really it's
    just a display issue, so it should be restricted to read/show functions,
    right?

  * if there are no events, \ zoom to fit should zoom to fit the ruler
    Or maybe it should always do that?
  * implement Local.Instrument.Kontakt composite kendang as a stream postproc
  * Putting start into the event would introduce redundancy with the
    Map ScoreTime Event, but it would eliminate PosEvent entirely.  And come
    to think about it, the map is private to Ui.Events.

  - If I want pitch signal render to work right, it should be in terms of
    degrees, not NoteNumbers.  Otherwise it just can't work for scales that
    retune, e.g. just.  But it means PitchSignal.Pitches need to emit degrees
    in addition to NoteNumbers, and I'd need an extra derive to compute the
    degree signal.  It would be nice to have a way to skip that for Twelve.
    * Change Track.make_scale_map to [(Pitch.Note, Pitch.Degree)]
    - As long as it's just note numbers, I should make the drawing code ignore
      the scale map.

  - I could move cmd_play_msg out of Cmd.PlayC if I moved
    Sync.set_track_signals to the ResponderSync via a magic return value.
    I could then get rid of the CPP hack in Ui.Ui I think.
  * Seq.pair_sorted and similar can return 'First a | Second b | Both a b'
    to avoid the bogus (Nothing, Nothing).  So can Seq.zip_padded
  - use NonEmpty list from semigroups
    Seq.*group*
    Block.block_integrated, block_integrated_track
  - I could set certain Symbols to stretch to the length of their event, this
    would yield a nicer looking score.  But it would mess up the bounds
    detection.
  * make Derive.Args functions more consistent, especially start vs. end
  * ParseBs.strip_comment is incorrect since it doesn't understand strings.
    It should be integrated into the parser.
  - can I use a lazy array + builder to make score generation more efficient?
    It would also be nice to use a lazy array inside the performer.
    Is there a generic lazy array implementation out there?
    It would be nice for LoggerT implementation as well.
    storablevector has a builder, but only for Storable types.
  - why not have blocks extend to the end of the ruler instead of the last
    event?  Last event necessitates the '--' hack.  Update doc/derivation.
  - There's a zillion things to stitch together for an instrument.
    Add yet more utils in MidiInst to make this easier.
  lilypond output
    - make rhythm spelling work properly for non-duple meters
    - make rhythm spelling work for compound meters
    - get pitches right, and keep the enharmonics
    - should I derive without the tempo track?
    - At some point I will probably want to only typeset certain tracks, or
      set up staffs per set of tracks, so I'll need per-track ly meta data.
      Or perhaps I'm more likely to want to typeset a certain instrument, or
      set of instruments throughout a large score.  But then I'd probably need
      to rederive and ignore certain tempo tracks.
    - support for slurs, I think I write them as a NoteTransformer which
      attaches metadata.  It can also affect note durations in normal
      performance.
    - Instrument -> Clef mapping
    - can I make a click on a note in the pdf highlight in the sequencer?
      LYEDITOR=xyz %(line)s %(column)s %(file)s
      How to turn line:col into a stack?
      I would need to have make_ly return a Map (line, col) Stack
      That means I probably stop using pretty print because I need control
      over line numbers.  Make a simple Output monad that keeps track of
      col and line number and can keep the Map.
      Then stick the map in a Performance or something.
    - to support things like trills, I'd need to have an alternate lilypond
      derivation.  Set lilypond=true in the environ, then various calls can
      e.g. emit lily code instead of notes.
      - trill on note
      - rit on note range
      Tempo is more tricky.
  - Derive.Call.Note.randomized should randomize start for 0 dur notes
  - a new empty inst with a scale doesn't get the scale right, should fall
    back on looking down the skeleton
  - but even when it does (on the scale itself) it doesn't do thru
  Space usage.  On startup it balloons up to 450mb, what is it doing?  After
    a bit of editing it's up to 750mb, who is leaking?  Undo history?
    * Write size profile that loads a big score and reports the size increase.
    - Write function to sum up State, Cache, and Performance sizes.
      Return stats about event size, etc.
    / Try interning strings on load.
      Savings are negligable, provided I'm calculating them correctly.
    - Flatten pointers out of data structures.
      Which ones? Cached Events, performed MIDI.
    * Discard old undo states.
    - Link libraries into seq as shared, also link with ghc api as shared.
      Ask on ghc-users first if anyone has done this.
    Compact cached signals and rendered MIDI.
      - First write tests that demonstrate where the space is going.
      - UNPACK Derive.Score.Event
      - Midi.Midi.WriteMessages compact as a lazy storablevector
    - Compact control tracks when I have that in, maybe compact only on
      checkpoints?
      But savings are likely to be very small for handwritten scores, would
      only make a difference for recorded control tracks.
    The ghc api uses tons of space when it starts linking in everything.
      - How much space does ghci take loading the same stuff?  Why so much
        less?
      - I probably have the whole app twice.  Can I use dynamic libraries to
        improve this?
      - dynamic libraries: www.well-typed.com/blog/30
    Check size on linux.
      stripped or not makes no difference
      bloom is 110m in memory
      repl is 200m in memory
      plus 50m for normal app
      so 360 for everything + bloom
      - calculate size of a score
      - calculate size of cache
    resident memory size:
    debug, no repl: 31m / 19m -- ? / ?
      darwin: 76 / 150
      linux: 32m / 129m
    debug, repl: unstripped / stripped -- 78m / ? -- 60m / 40m
      darwin: 193m -> 248m -- 323m -> 376m
      linux: 182m -> 230m -- 320m -> 367m
    opt, no repl: 35m / 20m -- ? / ?
      darwin: 39 / 116
      linux: 31m / 90m
    opt, repl: 81m / 48m -- 62m / 41m
      darwin: 194 -> 246 / ?
      linux: 131m -> 178m / 243m -> 321m

    loading bloom, debug: 74, 97
    loading bloom, opt: 77 / 59

    linux:
      bloom: 59 without the repl, but 231 with (huh?)
      repl: 100m + 47 to load seq libs
    darwin:

  - There's a lot of duplication between State.TrackEvents, Call.TrackInfo,
    and Derive.CallInfo.  Can I factor out the common bits?
  keys / scales / Theory:
    - support scales that are different ascending vs. descending
    - twelve, but relative to key and using numbers, aka jianpu
    - letter and jianpu but with implicit accidentals based on the key

  - if I added the cmd name before running the cmd, I could put it in the
    error msg when an exception is caught.
  - Breath kbd_input keys only work if chorded with a note, since otherwise
    controls with a NoteOff'ed note_id are not emitted.  Change this?
  - I feel like show_val should be exported from ParseBs.
  - Suppressed undo for val edit is surprising since I tend to do a lot of
    edits without leaving val edit.  Maybe don't do it for pitch val edit.
    Try going back to using the name to suppress, but ignore cmds with no
    name.
  - There are still some cmds without names, who are they?
    Do some logging to track them down.
  incremental save
    - got "error committing history: update for non-existent view id: ...
      CreateView"
    + try saving individual events for incremental save
      Seems to be just as slow as full save, probably most of the time is in
      the call to git.  Test again with larger tracks.
    - wrap operations in a lock file
    - make sure things are ok if it fails at any step
    - I don't think Ui.State needs to emit CmdTrackAllEvents for cases where
      diff will catch it.
    - Make sure that when a project changes name all the history comes with
      it.  I guess I'd have to copy the dir, or do a git clone.  If I copied
      the dir that wouldn't work with 'untitled' because I don't want all
      those other heads.  I want to copy over the current history.
      So I want to clone everything from the current commit.
      Is there a git cmd to do that?
      git clone --bare ...?
      Get all commits, then copy all commits along with referents.
      Much simpler to just copy the whole dir and then optionally trim the
      other refs and gc as a separate operation.
      - So I need the rename cmd to also mv or cp the underlying repo, if any.
    - Why should I ever do a complete save?  Why not always just do partial?
      The repo should only contain one copy of something that never changes.
      One reason is to trim history, but maybe for that I should have a option
      to rename and save without bringing the history.
      So save is just a tag operation, it doesn't actually dump state.  This
      will remove the irregularity where a save state corresponds to no
      history entry.
      But then how do I start the saving?  I would need a special value to say
      it should start saving.  Binding to ^S is logical, but then the first
      save doesn't add a tag.  Unless the first save always tags.
      - Initially save_checkpoints is false, so no checkpointing
      - cmd_save makes it true, then Undo does a checkpoint
        But it has to notice the false -> true transition, otherwise it will
        consider the cmd not worth saving.  So hist_save_checkpoints is just
        True for the cmd that turns it on, and goes off after that.
    - Ability to give names to SavePoints.
    - See if git's delta compression understands binary and can compress
      tracks.  Otherwise, would it be worth helping it by e.g. separating
      each event with a newline?  But then it makes serializing events more of
      a hassle.
    Git docs: http://progit.org/book/ch9-2.html

  - It can be really confusing how undo and redo makes windows pop up and
    disappear.  Maybe I should make undo not affect views at all?
  - I could have a Cmd state flag that does things relative to the current
    block vs. root block
    - LPerf functions
    - play
  - do the 'play this list of events' thing, send it over to the play thread
    just without an updater, so space will still kill it

  - key not applied in inner blocks, local play should take the root play's
    env as a starting point
  - fltk: some way to scroll that's not the scroll wheel
  - Cmd.Lang.LPitch.to_relative: I would need to implement Scale.scale_diff
    but I'm reluctant until I need to_relative or something similar

  complete quickcheck derive testing
    I switched back to Double for RealTime, but this means the roundoff errors
    are back.  Use quickcheck to repro them.
    * make Arbitrary for BlockSpecs
    + make a simple deriver that creates event and midi output skeletons
    - integrate quickcheck with generate_run_tests.py
    - assert that the reduced deriver output equals the simple deriver output
    - basic pitches: If the score was created with notes aligned to note
      starts, then every NoteOn should have the appropriate key, there should
      be no pitch bends, and "same note" should be the only reason for
      a channel split
    - basic controls: Given randomly placed control events, notes have the
      correct control curves.  Don't worry about times or midi.
    - slicing: Given some simple note transformers (tuple, place, ...),
      pitches and controls are still associated with the right notes as above.
      Don't worry about times, just that the right notes and the right
      controls.
    - block call property: a couple levels of nesting for block calls, notes
      still have the expected pitches and controls as above
    - inversion: as 'basic pitches' and 'basic controls', but controls are
      below the note tracks, results should be the same
    - stack: generate nested events, check that stack is as expected

  - it's annoying how a track with nothing in it won't play, and has no
    playback.
  - when I implement control block calls, I might want to override a control
    at certain points.  It should be possible to add a 'merge' operator that
    replaces samples.  Is still no good if the samples don't line up, but I'll
    need an event-level merge anyway for notes.

  - Serialize logs with Serialize rather than as text, but I need a record
    format.  This also makes it easier to change Show for various logged types
    like Derive.Stack since I don't then have to write a Read.
  - tempo composition is problematic because it means you can't change the
    length of a block from within the block.  So slowing down one part will
    speed up another.  How can I get local tempo like I want?  Or just edit
    the global tempo?  Unfortunately it's much more convenient to edit local
    tempo.  Maybe I could do a non-compositional tempo that simply overrides
    the caller, or rather multiplies with the caller.
    This means the call event is now longer than its duration would imply,
    and to fix that I need to have the child tempo modify the parent.  So
    effectively I am just modifying the global tempo, only providing a nicer
    syntax.

    This technique really is non-compositional: you can't have more than
    one call at once.
    Actually, I could: tempo track looks at calls in note tracks, gets
    sub-blocks, strips out the tempo tracks.  Then multiplies those signals
    with its own.

    Or I could just make it easier to edit the global tempo:
      * when you click on the parent, show selection pos on the child too
      - show derivation of child inside caller, I think I want to do this
        anyway, but it's hard, how do I fit all that stuff in?
      * merge child rulers with parent?
      But it still seems a bit awkward because I do want the tempo associated
      with the music, e.g. when I play by itself.  On the other hand, if the
      block repeats do I want the tempo to repeat as well?  Sometimes yes,
      sometimes no...
  - try to make TrackEnviron lazy
  - after an uncollapse, it doesn't redraw the selection that was underneath
    Not a big deal since a selection shouldn't be underneath but still...
  - randomize any control by having the 'set' call look for the -rnd control
  * some way to get symbol feedback instantly to make it easier to compose them
    - But it calls SymbolC and I ran into a problem where linux ghci can't
      link FFI-using functions.  Ask on glasgow-haskell-users.
  - glyph placement is messed up on linux, see up arpeggios
  + automate the manual tests

  wait until I want it
    - shift [ and ] undo and redo zooms.  or one key to toggle last zoom?
    - do tuplets by setting local ruler?
    - lang cmd to show state hierarchically... or does it already exist?
    / there should be a way for play to bring up blocks as they are played
      It's hard to know what blocks to auto-show, and I'd need yet another
      play mode, and a way to communicate new view ids back to the responder,
      so let's wait until I really want it.
    - save repl history along with current song, so you can search for
      previous cmds

  debugging
    - cmd to save and load cache to disk
    - add a Play.play_msgs function that plays the given msgs, normalizing so
      fst event is at 0.  Use to debug: LPerf.sel_midi >>= Play.play_msgs

  - test sending mtc to reapaer
    also test some mmc commands.  How does reaper support control surfaces?

  play:
    - playback should have multiple lines when a block is derived multiple
      times have a set of playback selnums?

  - If I quit and then restart, the second start takes a long time.  What's
    it waiting on?  Midi init?

MILESTONES
  0.1
    * support diatonics, enharmonics, and symbolic transposition for church
      modes, modes of limited transposition, and exotic scales
      (e.g. octatonic a-h)
    * record chords
    + integration
    - record continuum
    - Just scales, and other ratio-oriented scales that use letters and
      accidentals
    - complete Idiom.Wind, experiment with the Idiom postprocs
    - bring back negative duration / arrival beats
    * scales and keyswitches
    + efficient thru
    * tracklang complete with set of basic calls
    * better REPL situation
    - midi record
    - dense / efficient control signals
    * derive cache
    * symbolic score
    + save undo history / incremental save - more extensive testing
    - solution for audio, plugins, track bouncing, etc.  ardour / reaper?
    + jack support on linux
    - simple csound backend
    + lilypond backend
      slurs, calls that render lilypond ornaments e.g. trill
    + documentation
  future
    - print scores
    - mouse oriented signal editing
    - render audio
    - include audio inline
    - custom sampler / vst host with high resolution OSC or MIDI?

----------------------------------------------------------------------

integrate
  / Optimize block integration: similar to only_destinations_damaged,
    if only the destination blocks are damaged, don't rederive the source.
    Actually, this doesn't seem to be necessary.
  - single track mode that doesn't split tracks
  - integrate not logging means that integrate errors only show up on play
  - It may be possible to parallelize multiple integrations.
  / Don't allow Set, if the text is completely different then consider it an
    Add and remove the stack.  Rationale is that for a control track event,
    position and text are its only salient characteristics.
    Wait, this means that a note that is changed to a different note won't
    eval in a different place.  So I want Set after all.
  - Convert.Tracks should mirror TrackDestination structure.  Or
    parameterize TrackDestination?
  - Figure out how multiple levels of track integration work.
  * Use skeleton display to draw a line from integrated to generated
    track, in a different color.
  - If integrate is committing changes to a track, can that bite me if
    a "canceled" derivation comes through?  Think about this later.
  - What if an integrate wants to produce a note transformer track?  I
    think that's currently impossible.
  - quantization
  - split tracks on overlapping notes since some calls make them (e.g. block
    calls)

external
  - shakefile: can I print [# of #] when compiling?
  - send a patch to improve Random.Shuffle?
  - patch for hsc2hs for #alignment
  srcloc_annotate pragma
    I think a ghc pragma is needed.
    - read up on how jhc does it
    - ask ghc-users if it's a good idea
    - figure out how to implement pragmas in ghc
  - add better symbol resolution to haddock
    document 'qualification' -q flag, add mode to show it as written

use fixed-binary instead of Doubles for ScoreTime and RealTime:
  reasons to do it:
    - get rid of custom implementation in Perform.RealTime
    - get rid of half-open except start==end hack for ranges, a point selection
      is simple (start, start+1).
    - RealTime.to_seconds is big on the profile
  reasons not to do it:
    - what to do about -0?  I could disallow 0 dur events and make control
      events have an eta dur
    - will fixed64 be slower?
  switch back to Double for RealTime, split from Timestamp for midi
    - but floating point imprecision make controls not be clipped to their
      notes properly.  I think this happened at the Deriver level, not Perform
  problems:
    too slow, I do lots of to_double conversions that are slow.
    Can I do all that math in Fixed?

plugins:
  - Either dynamically load local inst definitions and local StaticConfig, or
    auto-generate the link file Local/Instrument.hs.

  - come up with plan for reloading inst config and static config
    Really what I want to be able to do is recompile the static config
    incrementally, relink it with the main binary *quickly*, and restart the
    app with exactly the same state.  This should be a lightweight operation,
    so it's feasible to edit some code, press play, edit code, and play
    again.  That means a full-on serialize restart is out, because the cache
    could be quite large.

    Of course, you want this stuff in a library so it can be reused across
    projects, so you can put it all in Local/.  Then the song state would
    have a (hopefully minimal) linkage from hs namespaces to the tracklang
    namespaces.

    So with hs-plugins: The static config is considered a plugin.  You edit
    Local/Config.hs, or edit other files in Local/.  It detects the change,
    regenerates Local/Config.hs, recompiles and reloads it.  Then the
    responder is called again with the new static config.

    So I need to be able to re-initialize the responder with a new static
    config.  Actually, the bits I care about are the call map and the cmd
    map.

bugs:
  - Create.rename_project loses the merged tracks
  * track down ghc rts crashes, assertion failure
    - make a repro case if ghc guys want it
  - run under valgrind every once and a while, just for fun
    - why doesn't valgrind reveal bad memory access from haskell, e.g. poke...

cleanup:
  - split Ui.State into separate modules for views, blocks, tracks, etc.
    put into Ui.State.* and re-export from Ui.State
  - split up CallInfo depending on type
    I got started but was discouraged when it came time to write
    GetLastSample, maybe I should make another go.
    Note tracks can't get a GetLastSample at all.
  - as above, Derived could be called Cacheable, and Elem should be a separate
    type family
  - It would be more efficient to move events around if their controls were
    normalized to start from their beginning, so that you never have to modify
    the signals.  Of course, it's only worth it if events tend to get moved
    more than once.
  - get rid of Perform.SignalBase and do something about the code
    duplication between PitchSignal and Signal
    - port SignalBase to vector
    - port Perform.Signal to Util.TimeVector
    If I want an unpacked TimeVector then I need to abstract out the way
    to unpack it.
    I should use Data.Vector.Storable since I want to pass the data to C++,
    and can pass by pointer or memcpy (as I currently do).  Data.Vector.Generic
    abstracts out the access functions.

  tracknum TrackNum
    Get rid of TrackIds, use (BlockId, TrackNum) for track addresses.
    When do I want to have tracks shared between blocks?  Well, maybe if I have
    a repeating pattern?  Shouldn't I then make it a call then?
    Consequences of getting rid of TrackIds:
      - all that get_track stuff goes away
      - don't have to worry about TrackId names
      - orphan tracks gone
      - but can't name a track with a (tid ...), I have to use
        (BlockId, TrackNum).  But it would be nice to get rid of
        (BlockId, TrackId) which is ambiguous.
      search for TrackId, where are the uses?
        - Cmd.Clip
        + Cmd.Create ->Track, orphan tracks gone
        + Cmd.EditUtil ->redundant
        + Cmd.Perf ->(BlockId, TrackNum)
        + Cmd.Selection ->redundant
        + Derive.TrackWarp: I think TrackNums, and would also be more accurate
        - Ui.Block - has track_merged, but can't replace those with TrackNum
          since merged tracks will be joined (but they're Collapsed, not gone)
        + Ui.State: have to take (BlockId, TrackNum)
    Big change, and I'm not sure it's worth it.  The tids should just be
    opaque most of the time, I don't think it matters much whether they match
    their block.  But maybe I should use (BlockId, TrackNum) more in Derive,
    e.g. TrackWarps and DisplaySignals
    More rationale:
    - I think the Cmd.Perf environ stuff should use (BlockId, TrackNum), not
      (Block. TrackId), because the same track may occur in different contexts.
      But for that to work, the stack also needs to use TrackNum.  But TrackNum
      by itself is not enough to identify the track, so perhaps BlockId and
      TrackNum should be merged.  This is going to get into getting rid of
      TrackId entirely though, which is a big job.
    - I think if the same TrackId appears in multiple places, it will be
      derived redundantly.  I should be able to cache the signal output in
      a TrackSignal.  But with any luck derive caching will take care of this.
    - TrackSignals is per TrackId, but the same TrackId may render to different
      signals in different positions because it has a differnt environment.  It
      should be (BlockId, TrackNum) + TrackId to verify in case the state was
      modified

    Lots of changes, e.g. Selection etc..  I'm afraid I'll wind up needing
    TrackId, and now everything is more complicated with both a TrackNum and
    a TrackId.  TrackId is convenient because I don't need the block, but
    I guess that's what State.Track is for.  TrackId is clearly broken when
    there are >1 per block.

    - Also need to change State functions to deal with TrackNum and State.Track
      e.g. get event tracknums.
    - Do I want to have an EventTrack TrackNum wrapper that's only created for
      event tracks?
    - put TrackNum into Stack.Track as well
    - Update Perf.lookup_val to use tracknum

    Integrate now assumes each TrackId can be mapped to one TrackNum.  But
    I don't think I can use plain (BlockId, TrackNum) because they would all
    get out of date when a track is added or deleted.  One way is to update
    them all:
      - Skeleton is already updated.
      - Cache, but it gets cleared when you add or remove a track, right?
      - Integrate index has Stacks, which would have TrackNums.
        I can't have integration break just because I added a track.

    Or I can make put the Map TrackId Track in the block, then rely on
    Ui.Block modify functions to preserve invariants.

    It would also be nice to only have one address type, so I'd want to either
    use TrackNum everywhere or TrackId everywhere.

    Remember nothing stops TrackIds from going stale either.  They're just
    less likely, only when a track is removed, not if a track to the left is
    added or removed.

    TrackId: ns/block/#

    - However, a case for retaining TrackIds that can be shared among blocks
    is to create a "view" of a score.  E.g. I want to see two parts together,
    and edit them together, but they're really part of a larger score.
    I could do this by putting the same TrackIds into two different blocks.
    I could get the same effect with solo and moving the tracks, but at least
    how solo is currently implemented I have to rederive each time I change
    it.  With shared tracks, I could add new tracks that are not reflected in
    the source block... but is that good or bad?

    However, this still doesn't require a track to occur more than once in
    a block.  So I could enforce the only-once invariant at the Ui.State
    level, to support TrackId -> TrackNum.

  - Think about some way to formalize the identifier restrictions, currently
    it's only enforced in the tracklang parser.

    p_ident applies to: Attributes, Control, PitchControl, ScaleId
    Maybe it's enough that the parser restricts them?  That means no one
    will bother creating e.g. a bogus control name because it could't be used.
    Call names are explicitly anything-goes.  BlockIds should support at
    least some of it if they are supposed to be interchangeable with other
    calls.

    On the other hand, I don't think I care much if idents can have wacky
    names, they just won't be nameable from the tracklang.
  - storing TrackEvents without duration would make maintaining the
    no-overlap invariant easier.  E.g. have explicit 'off' events, otherwise
    each event extends to the next one.  It means after merging I have to
    clear redundant offs, but that's easier right?

  / instead of building log dup suppressing logic into various functions,
    e.g.  allot, maybe I can add 'key' field to Log.Msg and suppress dup
    keys?  Who else produces dups?  Convert does.  But isn't it more
    efficient to just not emit?
    - convert and perform want to suppress the same msgs for the current
      derivation
    - Perform.Midi.Cache.is_splice_failure is just a better way to identify
      the msg than text
    - cache wants to suppress all cache msgs until end of cached block
    The problem is that it's hard to know the boundaries of the current
    derivation, especially if there are multiple blocks being derived
    simultaneously.  I would have to put a block id key.  On the other hand,
    filtering in place knows that.  The extra copy is actually no worse than
    the filter at perform time, maybe better for cache since it only happens
    once.

performance:
  efficient signals
    control
      - make Ui.Events into 'Map ScoreTime (Event | Chunk Signal)'
      - collapse chunks of adjacent 'set' calls into a Chunk
      - track_derive on a Chunk just returns the contents
      - fltk event render should detect too dense events and omit them, rely
        on the signal render
      - UI edits should see the Chunk expanded out as Events.  Inserting an
        event should modify the chunk or split it depending on if the inserted
        event is a set call or not.
    pitch
      Similar to control except I can't make Chunks automatically, since
      collapsing to NoteNumbers loses information.  But recording doesn't have
      this information in the first place, so it can generate chunks.
      However, maybe I should omit chunked pitch signals entirely and instead
      emit an initial pitch along with a transposition curve.

  - make seeks on derive output more efficient with a lazy index
  cache
    - Can I make cached signal more efficient by merging the signals before
      stashing it?  Of course laziness means that this won't actually happen
      until the next time the cache is demanded, unless I force it.
    - see if the cache filtering logs is causing significant copying and
      remove
  - make tracks into calls, so they cache and the sub-run stuff works the
    same with them as other calls
    It would be nice to make them calls in the scopes, so they can be
    rebound like other calls.  This is effectively moving the Schema into
    calls.  Then I can entirely get rid of it.
    * move Schema.default_schema_deriver into c_block
    - make Schema.derive_track into a call
    The thing is block takes 'BlockId' and track takes (BlockId, TreeNode),
    not CallArgs.  And it doesn't make sense to call from the tracks anyway,
    so maybe not in Scopes.
    Not much point to trying to put it in Environ or Scope since it's
    a different type, but it could be dynamically scoped with the others.
    Basically it's the schema, but dynamically scoped rather than attached to
    blocks.  I can't actually see how dynamic scope makes sense, it should be
    attached to blocks.  So keep it how it is, but call through generator
    cache.

    I want to do better tests about speed vs. space, cache hits and misses.
    Improve logging so that I can see, given a change, which areas of score
    were rederived.
  Cmd
    - If a msg aborts or doesn't run any cmds, don't bother to run diff.
      Except that hardly ever happens if I do shortcut thru.
    - cache track cmds for each track, update when the track title or skeleton
      changes
  Derive
    AppendList / MergeList for Derive.Stream
      - switch to AppendList and try to get garbage down
        Avoid copying sublists returned by block calls and cache hits
      - play from cursor is a linear scan on all events from the beginning,
        seems like this would be faster if I could skip chunks.
      - see if a Merge constructor can reduce copying
      - can I cache length and range in AppendList?  does it matter?
      - insert parallelism?  maybe the evaluator can do that when it sees
        Merge?
    - lazy signals
      - check out 'at' and 'bsearch' occurrances and see if they can use tails
      - There are lots of lookups in the tempo map
    - see if making a version of Derive.local that's non-monadic in the
      modifier has any effect on performance
    - to get arrival beats to work right with the control track, I think I can
      make the 'set' control track call set from (prev, cur) instead of just
      cur.  It will make simultaneous samples, but they should be ok.
    derive cache
      - c_block should only cache if the block has > a certain number of
        events.
      - implement tracks as generators so they can be cached too
      - I won't rederive cached generators if they have control damage outside
        of the event range.  But there's nothing stopping a generator from
        reading ahead or behind... come up with some kind of solution for this.
    implement incremental transformer caching, if necessary
      - once I know what I'm doing with transformers, fix up negative duration
        postproc
    - fair amount of garbage generated by SignalBase.bsearch_above, I think
      this is because it has to box the values when it pulls them out.  But
      it's really just comparing to a Double, so I should be able to do the
      operation unboxed.  But decide about lazy signals before going nuts on
      this.  If I revert to linear search then none of this is necessary.
    - at_linear is called a lot by compose, by compose_warp, by d_warp
      can I make this more efficient?

    - or maybe it's the control deriver creating a huge list of signal
      chunks, which is then all forced at once since merge needs them all.
    - Parallelize derivation with strategies.  Can I spark subderivations?
  Perform
    - use a lazy storeable vector for [Score.Event] and [Midi.Message] to save
      memory?  If I make Messages a storable vector, I'd have to hash the wdev
      or something.
    packed midi, encode to storable vector
      - last step of performer is to compact into vector
      but I'm not sure this will much help
      The main thing is how to encode the device.  I think I can hash it.  Or
      use OS X persistent device ID?
      how many msgs in e.g. the ptrio?
        127130, [pno 9205, flute 63748, clarinet 54177]
        5367 for bloom
        peak for 246114 msgs: 46mb for int, 38.7 for int, 38.7 for w64

symbolic score
  - namespacing?  don't worry about it for now, if I need it later it can be
    entirely at the haskell level, I can use the per-song config to import
    namespaces
  - feta's tr symbol looks bad especially when small, is there a better one?
  - find or make a font with jian ti symbols?
  - find or make a font with gong che pu

fltk:
  - implement labels for pitch tracks in fltk/EventTrack.cc
  - skeleton display has leveled steps to make it easier to see who is
    below who.  Only if a track has multiple children.
  - rethrow c++ exceptions as FltkError
  - auto add pitch track when a track title input is expanded crashes with
    assertion error 'title->w() == body->w()'
    solution: text entry is collapsed by track add, remove, or resize
  - factor scroll redrawing into a single class
  - draw arrows in SkeletonDisplay.cc properly
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  draw bugs:
    - redraw after track range damage draws things a pixel too low
    - when scrolling upwards, ruler mark text is not drawn completely
    - doesn't redraw after switching monitors
  Track
    / dividers can have separate color for upper part, for collapsable tracks
  event track
    - visual indication when both solo and mute is on
    - editing event text should use a text entry widget, that way I get
      a cursor, IME, etc.  A side benefit is that I don't have to derive half
      edited data.  This also solves the problem where the currently edited
      event is hidden.

      This only applies to raw edit mode.  Entering notes and doing
      programmatic changes is still single key.

      Remove the separate raw edit mode.  Return while in edit mode creates an
      event if one doesn't exist and begins editing its text.  Keyboard focus
      is then in the widget until return or tab or a click outside of it.

      The responder has to be able to tell UI to open a text entry, so return
      (State, [UiCommand]), where
        data Edit = Edit {
          edit_block_id :: BlockId
          , edit_tracknum :: TrackNum
          , edit_at :: ScoreTime
          , edit_text :: String
          , edit_insert :: Bool
          , edit_selected :: Bool
          }

      If the edit_insert is True and there is already a text entry open at
      that position, insert the given string at the insertion point rather
      than creating a new one.  This can implement midi->*note insertion.

      Return msg is:
        data Edited = Edited BlockId TrackNum ScoreTime String

      The UI can suppress this if it detects the text hasn't changed.

  control track, render signal
    / decided against rendering signal as one long line, comment in
      EventTrack.cc
    - render option: solid with color gradient
    - combine multiple signals, e.g. one controls xpos, one controls color

logview:
  - haskell and c++ use the same machine readable format
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...

Ui:
  Track
    - benchmark large TrackEvents
    more compact implemnetation than Data.Map?  profile first!
      - priorities: memory efficiency, persistent, merge speed (insert many)
        shallow tree of dense chunks?
        can I take advantage of non-overlap?  [(pos0, data), (pos1, end), ...]
        data Event = Event String StyleId | End | ControlVal Double
      - I think memory efficiency is more important than modification speed
    dense sampled signals
      - efficient storage, preferably as a Signal so no conversion is necessary
      - display dense signals: omit text and trigger lines when zoomed out

plugin host freeze audio
  features:
    3 load synth plugins: ardour3, reaper
    1 programmatically configure them, e.g. load 4 fm8s each with poly of 2
      and loading inst X, or switch them all to inst Y
      - dunno?  can reascript do it?  osc on ardour?
    3 sync play position seq, sync start time
      - I think mmc can do this
      - or maybe the control surface support can do this
    3 start record too
      - control surface support should do this
    2 sync from daw back to seq
      - Can I have the DAW also emit MMC?

  features needed:
    - host synth plugins: programmatically load and configure plugins
    - route midi: associate each plugin with its own midi ports
      It would also be nice to split by midi channel, and route each chan to
      its own plugin.

      On OS X this means creating an IAC port for each synth, presumably
      multiple ones for multiple instances of the synth.  Then I need to
      route each synth to the right midi input and keep them configured.  This
      seems like a bit of a hassle.

      Can I use JACK midi to address a specific synth?  It's one midi stream
      per jack port, so I need an association between insts and jack ports.

    - audio graph config: configure the audio graph, placing synth plugins,
      filter plugins, track record / fader / etc. daw stuff, and outputs
      at various places
    - DAW: Need to sync play position and send current cursor position when
      it changes.
    - track freezer: Record plugin output, sync play position.
  rpc
    - osc, but no good for two way
    - thrift?
  ardour
    - ardour3 supports synth plugins, but doesn't compile on OS X yet
      wait for paul to post his updated build instructions, try again then

  reaper
    it can sync to mmc
    - route multiple plugins to the same bus?  can this be scripted?
      Probably, but to use apple IAC I need to create a bunch of IAC ports and
      make sure they are configured the same way on both sides.
    - can it send cursor position?
      I can poll.

  impromptu
    - mac only
    - can programmatically create a au graph
    ? can it record audio?  yes, but maybe not from an au?
    - in any case, I can't do daw stuff, so I think I don't want this

test:
  - tests count number of tests in addition to checks within each test
  - use generics or Foldable or something to write a generic StructEqual

misc:
  - program to launch logview and seq together
  - ^T on the cmdline prints stuff!?

integrator / midi record:
  - implement

REPL: repl:
  - haskeline sucks for long lines, add multiple line editing?
    really I'd prefer plan9 style esc then edit
  - is Cmd.Lang.Fast now obsolete?
  - can I get local variable bindings (let x = ...; y <- ...) to work in the
    REPL?
  - tab completion for symbols like in ghci
    I'll need a list symbols cmd which the repl automatically sends on tab
    completion.
  - :compile cmd that turns on compilation for everything except Environ
  - :browse to look in modules... can I use GHC.getBindings for this?
  - :module cmd to move evaluation context to a certain module, maybe I
    could also get rid of the need for Cmd.Lang.Environ to import everything.

Cmd:
  - Can I have a general in-place derive cmd for note transformers?
  - step play StepPlay could work even when notes were moved by annotating
    the midi output with the UI event that produced it.  This might be useful
    for debugging too.
  - Can I give Cmds their own state without putting it in Cmd.State every time?
    For instance, twelve scale may want to know what key you're in.
    Actually, it would be best to have per-module state.
    At worst I can have 'Map.Map String Dynamic'.

    Use existentials:
      data forall a. Cmd = Cmd {
        cmd_func :: a -> CmdT (Status, Cmd)
        , cmd_state = a
      }
    This means that such cmds have to be able to be updated after they are run,
    so the cmd lists have to be kept in responder state.  If I'm going to do
    that, why not have cmds optionally return a continuation and handle state
    that way?

      cmd msg = do
        state <- stuff
        return $ continue $ \msg -> do
          more stuff

    Or if I can put it in the monad:
      cmd msg = do
        state <- stuff
        msg2 <- yield Cmd.Done
        more stuff

    For module level, each module of cmds would have to export a bunch of Cmds
    and the responder retrieves the state and passes in another layer of
    StateT, or directly.  I supposed Dynamic wouldn't be so bad for that.  What
    happens when the module is reloaded?

  ? a module with easy access to all GlobalKeymap cmds for cmdline access
  vi style keymap:
    - movement: hjkl, HJKL to move timestep+1 or skip to
      next inst track, bf to move timestep at block section rank, BF to move to
      top and bottom of block
    - esc and i for edit mode
    - number prefixed cmds?  not for now
  Cmd.Edit
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
      (merge will clip them to the next event)
    - controller edit mode accepts two numbers and moves on, no spaces
    - a legato command that always goes to the next note would still be useful
   - stretch events in selection to another length (need two selections?)

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.Play
    - play loops
    - start playing from top of displayed area
    - start playing from this block's position in the root block

  Undo
    + incremental save
    - undo as a tree?  On modification, split the undo tree instead of
      throwing away the future.
    - undo only within selection
    - record view changes, at least zoom / scroll so it can be undone / redone
      separately
    - if Cmds have a name return, history entries could have names.  Keymap
      cmds already have a name to put in.

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice or delete time or a Meter into a ruler

  Cmd.Freeze
    - details in doc/freeze_track

  Cmd.Save
    - save with a magic number so I can load songs, inst configs, etc.
    - gzip save files

Derive:
  lazy signals:
    - see if I can make control tracks truly lazy by making signals lazy
    - reimplement various functions like integrate and resample, bsearches
      must be linear
    - make linear searches faster for e.g. warp by dropping warp in the past
    - can make integrate output infinite and remove set-prev hack
  instrument
    - per-project short aliases for inst names so you can fit them in tracks
      easily
    - Implement >inst as setting the null call instead of env.instrument.
      That way the inst has control over the interpretation of e.g. attributes
      and pitch slide (to implement piano style retrigger)

      or maybe, lookup val calls in current inst analogous to current scale
      Maybe I can get rid of the Instrument.inst_control_map if I do the
      mapping in generate_note?

  - implement postproc calls
    - framework for determining scope of a postproc: per inst, per track,
      for pre or post overlaps, etc.
    - Think about how to keep incremental recomputation in the presence of
      postproc.  I suppose they have to declare how much they depend on.
    examples of postprocs:
      * echo
      - retune a note depending on the previous interval (e.g. sloppy pitches
        when playing quickly)
      - negative duration
        I think I'd rather do this as part of the instrument, though.
      * string emulation:  Every note is assigned a string.  When
        a legato new note is played, it either stops an existing string or takes
        a new one.  The previous note will either ring for a decay if the
        string is unassigned, or reset to its "open" pitch otherwise.  Strings
        can either assume their new pitch instantly (stopped), or gradually
        (bent).
      - overblow emulation: a set of overblow ranges are defined, along with
        possible pitches for each one (fundamental and overblow harmonics).
        When a note moves from one to another, start a new note at the
        destination pitch and bend the decay of the old one to the fundamental
        or closer harmonic from the previous mode.
      - rambat damping emulation: notes ring on by default until they can be
        damped.  Damp at the first opportunity, where opportunity is defined
        as a break with no notes for a certain amount of time.  Can only damp
        two neighboring notes at a time.

  * sustain signal, to control staccato vs. legato

  - to cut the middle out of a pattern: a cut signal that disabled derivation
    when it's 1?
  - combine ornaments, like "hold 1s | tr" to hold the first note for 1 score
    time before starting the trill.  I think this could work by warping tr
  - time interval literal, so I can specify e.g. trill speed in terms of beats
    This means Derive has to have access to the rulers.

  deriver customization
    - set dynamic env vals, especially if a family of derivers use the same
      argument names for analogous behaviour, e.g. 'tr-speed'
    - make it easy to add haskell derivers, tracklang must remain simple
    - derivers call other derivers, which can be rebound

  - test Calls that return overlapping events
  - block-level calls
  - x = _ will unset x

  - come up with a syntax for Ui.Event preproc calls
    >inst1 | echo < preproc1 < preproc2
  - also I can have a post-parse "macro" preproc pass, this is more suited
    for prepending a call
  - re-implement directives: derive_notes returns (EventDeriver, [Event])
    wait until I have a call that wants to use it (suppress event?)

  - When looking for the next note on, I should skip notes which are just
    'statements' that produce no notes.  That way a var set won't interrupt
    the pitch sig.
  - some kind of notation for replacing the track interpreter, e.g.
    TrackId -> EventDeriver.
    This could be used to implement macros, and also preproc.

  val calls:
    - val calls to get the next/prev TimeStep

  note calls:
    * Implement tick as a call:
      Need to get next and prev Ui.Event, get pitch from pitch sig
      to_local (between (to_gloal prev_pos) (to_gloal next_pos)
      d_absolute_at = d_at . to_local

    - Implement suppress as call:
      This is more tricky, how can a call modify neighbors?  Especially
      preceding ones.  This seems to mean I still need postproc calls:
      DeriveT -> DeriveT.  Internally it evaluates the deriver, processes
      the Score.Events and wraps it in another deriver (the seq equivalent of
      cue).  After that most behaviours are ineffective, but them's the
      breaks I guess.  It seems nicer if I could pass something to the block
      to cause it to skip the downbeat, but how can I do this in a non-ad-hoc
      way?  If I can insert a per-project block deriver I can add it as an arg.

    * Implement tuplet:
      't *n1 *n2 *n3 |' runs deriver three times with three different
      pitches. (Didn't wind up doing it that way.)

    * Implement clip-call:
      Undo the call stretching, this should be efficient because of stretch
      combining:

      d_stretch (recip (dur/block_dur)) $ d_clip dur $ deriver
      "unstretch | sub"

      A non-block call (including notes) will have a block_dur == dur.  I can
      also imagine a version without the clip.  'unstretch' is a crummy name
      though.  'restore'?  'abs-dur'?

    * Implement sekar derivation.
      It would be nice to do a piece on sekar patterns where the form itself is
      in the same pattern, for a kind of fractal structure.  How to have
      a pattern derive patterns?

      - pass the calls as block args
      - put the null deriver in the env
      - more general than the above: dynamically scoped call map and syntax to
        modify it
      - env var that prepends or appends calls to notes.  actually, this is
        better done as a preproc.
      - implement deriver like vla/cello duet?  that's a sekaran, but derived
        from another part.

    * Implement trill
      * absolute tempo version that adds new cycles when stretched
      * version with n cycles that stretches with tempo
      - hybrid where the initial part stretches, final part is absolute

  PitchTrack pitch
    * Named pitch tracks, so derivers (e.g. tuned just scale) can take pitch
      track args.  The way this could work is that the state_pitch becomes
      'Map SignalName PitchSignal' and the "" signal is taken by the note
      deriver during convert.  Track syntax:
      "*scale" -> ("", ScaleId scale)
      "*scale %psig -> ("psig", ScaleId scale)

  ControlTrack control
    interpolators
      - sine
      - constant slope, exp slope (i.e. slope until next control event)
      - continuous tempo warping for signals
        tempo: "2" -> "1", "2", cont: "2" -> "i, 1", should emit a bent line
  Derive.Scale scales
    - implement pengumbang pengisep
    - just intonation tuned to a pitch signal
    - looks like fun: http://en.wikipedia.org/wiki/Bohlen-Pierce_scale
    - retune a note depending on the previous interval (e.g. sloppy pitches
      when playing quickly)
      I think this has to be postproc.
    - Ratio based notation where the ratios are from the previous pitch.
      Should be able to do this with val calls.
    - parser for scala .scl files

   - Control track management?  It should be possible to have a note or a bunch
     of note tracks with a bunch of control tracks and control the clutter.
     Ideas: collapse has limited usefulness when there are too many, even with
     color coding.  I could do this with logview: selecting a note track logs
     a list of its control tracks and whether they are hidden or not.  Clicking
     on one in logview will emit a cmd that will hide or show that track.
     Or I could use a UI for adding new controls too: click a track, then a cmd
     'add_control "vel"', this will unhide and focus the control if it exists,
     or create a new one and link it with the skeleton if it doesn't.  ^T is
     intended to create new note tracks, and they're only linked to tempo
     initially.

     This implies a slightly more generic and acme-ish system for logview:
     anything enclosed in {}s can be clicked and will be sent verbatim, even if
     it's in the catch line:

     -- title (tracknum): inst_name, allocation, [control tracks]
     Inst (track 1): fm8/inst1, fm8:0,1,2, [vel {hide 2}, pedal {show 3}]

  - set controller within control track?
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - reflect derivation back into a block
  - merge block level changes with derivation

Perform:
  - damper pedal causes all notes to extend until the pedal comes up, should
    the performer know about that?  Is there anything that this breaks?
    I don't think so, it affects channel allotment so notes could be
    improperly joined, but mixing pedal and multiplexing seems rare enough.
  - Perform.Midi.Perform: should be possible to lead keyswitches as long as
    they don't precede the previous NoteOn, since I think samplers will only
    switch on the next NoteOn
  * instruments can have a native scale, so playing that scale won't involve
    pitch bends
  Instrument
    - some kind of organized way to manage instruments and instrument config
    - some basic midi instrument defs for generic midi (dev, patch)
  Midi:
    - see if synths support the set pitchbend range controller
    - Convert certain attrs to controls for cc 'keyswitches'.
    / inst has a notion of polyphony so I can avoid overloading a channel, say
      if I limit it to 2 voices

      The problem is 'allot' doesn't know which channels are going to have
      a lot of notes so it can allot wrong.  For instance, a large chord might
      take up all the polyphony of the first addrs, and then the Nothing addr
      gets the bendy notes.  I think I would have to look into the future and
      make a decision based on the notes that will be overlapping with this
      one.

      The problem comes up with chord oriented instruments that have a few bent
      notes.  However, I'm not totally sure this will be a problem, and it
      would be simpler to simply make two instruments, one for non-bendy notes
      and the other with multiplexing for bendy ones.  Yes, this is putting
      some busywork on the user which should be left to the performer, but
      since the solution is fairly complicated I think I'll leave it be for
      now.

Instrument DB / browser:
  - switch sysex parsing stuff to use attoparsec and ByteStrings
    I don't use state, but I parse [(SrcPos, Word8)] so that I always get the
    byte position correct.  But I should be able to run a sub-parse with byte
    already set.
    Wait, but attoparsec doesn't even keep track of the current byte.
    Should be able to use a Parsec instance for ByteString though.
  - browser search lang: can I write !sysex to search for patches without the
    sysex tag?
  - search lang supports quotes
  - search lang supports - to exclude a term
  - ability to edit tags, esp. add "favorite rating"

jack: JACK:
  bugs
    - jack1 doesn't work at all: other clients don't see writes, until I quit,
      and then they get continuously spammed.  Apparently the jack_port_t*
      from the registration and the lookup are different.
      - Try stashing port from port_by_name port instead of jack_register_port.
    - jack2 hangs for a long time on jack_connect when I reconnect due to a
      notify.  Try looking at logging to see what it's waiting on.
  - de-globalize MidiClientRef?
  - Ensure that shutdown stuff is being called correctly.  I don't care but
    maybe JACK does?
  use jack transport
    I don't think I need to be the master.
    - When starting a play, call jack_transport_locate,
      then jack_transport_start().  The play then blocks on a lock which is
      released by JackSyncCallback when it gets a JackRolling state.
    - Register with jack_set_sync_callback.  JackSyncCallback sets a syncing
      flag, emits a Msg that forces the needed bits of performance, then that
      cmd must call back and reset the flag, at which point the sync function
      can return true.
    Then the next step is to test, and then figure out a way to get ardour to
    automatically set up a bunch of instruments and make MIDI in ports for
    them.

misc ideas:
  - Staff notation represents chords well, but tracks don't.  Think of a more
    compact notation.
  - Staff notation output via lilypond?  This can be implemented as another
    kind of backend.  I think events would need metadata so I have a place to
    put formatting info.  Maybe tracks and blocks need it too so I can express
    staff associations.
  - if derivation needs event IDs, maybe I can use the value-supply package
  - safecopy package does version controlled serialization
  - think about yi's approach to keybindings as a parser and keybinding state
  - also investigate yi's approach to configuration

planning
  Composition of score fragments.  I think I want to display subderived
  notes within the call event.  And then some way to put edits on top of it.

research:
  - spline curve interpolator: evoral/Curve.cpp, www.korf.co.uk/spline.pdf
  - check out Ben Johnston's just notation

future:
  - I need to sync with a DAW but don't want to implement rewire.
    Which DAWs support jack?  ardour, reaper?, ...?

    Can I use ardour as vst host, DAW, and track freezer?  It has OSC support
    and I could add more.  Downside: no windows.

    - vst host: Need to programmatically load plugins, configure plugins, route
      audio.
    - DAW: Need to sync play position.
    - track freezer: Record plugin output, sync play position.

  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden

OTHER
  - #(poke Mispeled, field) fieldp field results in compiler bus error
  - problem with pianoteq: if the same note occurs on two channels, one
    will be dropped.  Report to pianoteq.  I could work around, but it won't
    occur with real multitimbral instruments anyway.
