- make sure pitch terminology is consistent:
  KeyNumber = scale independent note, Note = note in scale,
  Pitch = freq easily mapped to and from nn, same as NoteNumber,
  NoteNumber = Midi.Key + decimal
+ unittests for new mods: PitchTrack
bugs:
  - when I do just space, I get "keyup not in modifiers"

- hspp for Derive.warn and Derive.throw
- support for Schema.default_scale, esp since it gets automatically added
- kill skeleton instruments

- ^C should quit everything
- cmd-q should also quit entirely not just close the windows
- fix logview
- fix Signal_test

bug haskell-cafe:
  - buggy ghci debugger
  - haddock problems
  - hint trouble

  current
- implement pitch track as a separate control track
  * pitch control track
  * remove Cmd.Instrument instrument arg
  * unittests for new derive2 stuff
  + remove derive1 (rest depends on Cmd.NoteTrack)
  * fix Derive/Derive_test.hs
  * Perform.Midi should understand the new pitch track
    * checker throws a warning if an instrument has >1 pitch track
    * instead of Score.pitch, performer looks for first pitch (*...) track

  implement attrs
    * add attrs to Midi.Instrument
    * add attr priority to Midi.Instrument
    * hook up attrs and keyswitches
    * filter out excess keyswitches
    * test
    + library of standard attrs?

  cmd support
    - note entry commands add both event and pitch track
    - event edit commands enter text or notes

- relative controller tracks, combined with an operator, so e.g. "+, *scale"
  adds to the pitch track, and "*, volume" multiplies with the volume track
  operators: +, *, min, max
- relative pitch track, but to do this properly I need to support PitchSignal

should be a documented extensible way to add new track types without modifying
core ADTs


----

- set controller within the track?
cmds
  - just plain "i" means the previous val, to make timed slides easier
  - delete sections of ruler, or insert new sections

- remove State.modify_event_range?
- either ruler is binary or step goes in binary steps

- optimization: if a msg aborts or doesn't run any cmds, don't bother to run
diff.  except that hardly ever happens if I do shortcut thru

- cmd_record_keys not getting run when play throws?

- per-project short aliases for inst names so you can fit them in tracks easily

- cmds return (status, record_undo).  Also can Cmds include a name so it can be
logged or attached to an exception?  I guess the keymap thing is probably
enough.

- midi record, call it the Integrator
- caching
  on sync, check cache validity against updates, and regenerate signals and
  events on blocks if necessary.
- pass signal by pointer

- test merge paste

- Cmd.View abstraction layer for collapse and mute

- "approach val" method to make pitch bend easier, or just insert two notes?
  the former is higher-level...
  g0 - approach 0 time, equivalent to s
  gi.1 - approach linear taking 0.1 trackpos
  g.1 - as above
  g2e.1 - approach exp2 taking 0.1

  Ok, so this is more complicated than that, I need something like:
  a5- g2e1 b5-

- implement midi bandwidth display

DESIGN
  - chord input... think about some kind of compact representation
  - if derivation needs event IDs, maybe I can use the value-supply package
  - safecopy package does version controlled serialization
  - check out loch package instead of hspp

display signal:
  cmd makes a change to a controller track
  diff (and cmd) generate TrackEvents update
  sync processes TrackEvents and TrackAllEvents and merges it with samples

  so where does sync get the samples?  I can pass it [(TrackId, Samples)]
  that comes from (Track, Signal), which comes from a partial derivation
  most derivers should be able to get that from the Skeleton

****
- switch to darcs hashed repo format

bugs
  * when replacing rulers, the track widths are lost
  * destroy_ruler doesn't remove the ruler from its views
  * plain numbers to set step is error prone in kbd mode
  * parse errors don't give position
  - paste deletes events before the paste area
    can't reproduce this
  * it's easy to create empty events which then give parse errors.  There's
    a conflict between delete and move and remove letter.  So don't move.

performance
  - random little hangs are annoying.  figure out what's going on.  GC?
  * pause before playing.  printing logs make playing too strict?
  - the full event loop is too laggy for midi thru, implement a fast path
  - cache marks and events from callback
  - will removing the style speed up event copying?

new pitch lang
  * implement pitch track as a separate control track
  * implement note track and lookup, put inst in environment
    remove pitch parsing from Derive/Note.hs
  + remove the old note track stuff
  - Perform.Midi should understand the new pitch track
  - instrument attributes
  - cmd support: note entry commands write to both inst and pitch tracks

  - track collapsing
  - track muting
  - track merging

cleanup
  - make Schema.Track only event tracks

fltk
  * consistent drawing of abbreviated events so drawing isn't dependent on
    damaged area.
  * optimize: implement scroll redraw optimization
  - convert Selection to use the same format as hs, so it can show the cursor
    end specially
  - bug: selection redraw leaves gaps when dragging downwards
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  - bug: doesn't redraw after switching monitors
  UI Msgs
    - can I capture os x two-finger drag events?
      yes, they're reported as FL_MOUSEWHEEL, so I should scroll on mousewheel
  Track
    / dividers can have separate color for upper part, for collapsable tracks
    - tracks have their own status lines, to report things like mute
  event track
    - "currently edited" event shouldn't be hidden by previous ones
  Ruler
    * mark text is abbreviated if there isn't enough room
  MoveTile
    - only capture drag on a plain drag with no modifiers

logging logview
  - logview needs scrollbars
  - don't store msgs in memory, don't refilter from begining
  - colorize (tid ..) (bid ..) (vid ..) etc.
  - implement clickable srcpos and StackPos
  - haskell and c++ use the same machine readable format
  - rename LogViewer -> LogView just to reduce confusion
  - LogView should use Util.Fltk

Ui
  - some kind of special highlight to indicate the active block
  - rethrow c++ exceptions as FltkError
  Controllers
    * pass signals as pointers, not copies
    - make sure very dense (e.g. sampled) signals are displayed and stored
      efficiently, but are still editable normally when you zoom in.
    - signal render support for indexed signal type, especially pitch
    - events store style as a uchar ID for consistency and memory savings
  Track
    * patch Data.Map to include toDescList
    - benchmark large TrackEvents
    - modify IntMap for Word64s, add toDescList
      - send patch to libraries@haskell.org

Cmd
  - cmd to give a view focus and bring it to the front
  - Cmd_test
  - the cmds that return anything other than Done are rare, have a special case
    for them and make most cmds return ()
  Keymap
    - check for key assignment collisions
    - support generic modifiers like any Shift, any Control, and Command
      (which becomes alt on a PC keyboard)
  Cmd.Edit
    * change note lengths
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - trackerlike note entry: entered events are all as long as the block
      (merge will clip them to the next event)
    - map selection through function
    - transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces
    * nudge events
    - a legato command that always goes to the next note would still be useful
    - method edit works in controller tracks

  Cmd.Selection
    * drag snap to timestep
    * extend selection with shift-arrow
  Cmd.TimeStep
    - snap to event begin/end

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.View
    - ViewBlock abstraction: collapse/expand tracks, mute tracks

  Cmd.Play
    - warn about unallocated instruments (Convert.verify)
    * make sure the whole stack is lazy
    - play loops
    * background derivation
    - start playing from top of displayed area
    - start playing from TimeStep before insert point

  Cmd.Record
    - come up with a plan for midi recording
    - implement simple midi underiver aka integrator

  Undo
    * implement undo and undo/redo cmds
    - figure out how to checkpoint just state diffs
    - add undo history to on-disk format

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice time or a Meter into a ruler

  Cmd.Freeze
    - details in doc/freeze_tracks

Derive
  derivers
    * control
    * tempo
      * multiple tempos per block
    * subblock derivation
  pitch
    * pitch signal rendered to midi
    - relative pitches, e.g. +5
    - pitch signal should be Signal (Method, Pitch) so that they can be
      transposed
    - alternate scales

  - block derivation memoization / caching
  - keyswitch support in midi thru
  - set instrument within note track, controller within control track
  - separate instrument track, as a kind of controller track
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - display derived blocks
  - 3 way merge for derived blocks

Perform
  Player
    * flush midi output when I get a Stop
      * send patches upstream
  Midi
    - eliminate duplicate controller msgs
    * pitch signal rendering
    * support key switches

  Instrument
    - some kind of organized way to manage instruments and instrument config
    * backend-independent instrument def
    - some basic midi instrument defs for generic midi (dev, patch)
    - defs for z1 and vl1

  Signal
    - lazy implementation
    * implement Signal.equal
    - signal transformation derivers: +, *, /, min, max, ...
    * after implementing GUI drawing and transformation, reduce the
      proliferation of signal types
    - ensure that controllers are warped continuously by tempo

Instrument DB
  - search lang supports quotes
  - search lang supports - to exclude a term
  - original file goes in a tag, not the text
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - now that PatchTemplate is gone, maybe I can use a simpler storage format
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi
  * implement midi merging for midi thru
  * a single msg input thread instead of one thread per input port
  bandwidth
    - keep stats
    - display widget

Osc
  - does reaktor support timestamps?

research
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - draw antialiased lines and curves on os x
  - learn about hs gtk for reference

future
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
