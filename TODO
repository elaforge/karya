auto insert imports in vim:
  - follow tag under cursor
  - Get module name of current file
  - turn 'module x.y.z where' into 'import qualified x.y.z as z'
  - figure out where to insert it, and insert it

misc ghc fixes:
  - .prof output should line up better
  - hp2ps should use constant colors for biography

+ finish up derive profiling testing, logging monad
- signals:
  - profile
  - switch to lazy signals, try to fix warp compose stuff
  - make resample etc. more efficient
- implement simple integrator
- implement dense signal data in Ui.Track
- extend control track display to work with dense signals

- research ardour OSC control

CURRENT
  symbolic score
    * the manual bounding box is awkward, it should figure it out automatically,
      by drawing the symbol and counting pixels, if necessary
    - symbols are now not lined up vertically.  a flag to disable symbol
      vertical placement would make them behave.
    * a symbol with only one glyph should use the normal spacing for that glyph
    * draw symbols in pitch curve
    * remove font_default, use Config::font instead
    * c_interface
    * dotted numbers mess up vertical spacing, dots should be smaller and off
      to the side
    - namespacing?  don't worry about it for now, if I need it later it can be
      entirely at the haskell level, I can use the per-song config to import
      namespaces
    - find a free music font so I can use sharps and flats
      ttf version of lilypond's feta?
    - find or make a font with jian ti symbols?
    - find or make a font with gong che pu
      meter: circle, downstroke
      fingering: downstroke, upstroke, cross, L, circle, figure-8
      pitch: normal characters
      - ㄨ 工 六 士 一

  * fix trill to use pitch range so it makes a nicer looking signal

  - I think PitchSignals may need to be reworked.  They should be (Note, Note,
    Frac).  Otherwise, it's not clear what to call 4a# vs. 4ab.  I can still
    use numbers (Ints this time) as indices into a table of names, but e.g.
    (4c 50) will have to become (4c, 4c#, 0.5) instead of (60.5, 60.5, 0).
    But this means displaying the signal will become more straightforward.

  - I think if the same TrackId appears in multiple places, it will be derived
    redundantly.  I should be able to cache the signal output in a TrackSignal.
  - TrackSignals is per TrackId, but the same TrackId may render to different
    signals in different positions because it has a differnt environment.  It
    should be (BlockId, TrackNum) + TrackId to verify in case the state was
    modified

  - set_render_style should trigger a rederive

  - Can I not sync collapsed tracks?  I think the best is to implement
    collapse at hs level, then an expand can trigger a rederive.
    Also it would be nice to not rederive signal for tracks that haven't
    changed, maybe tracks in calls above the modified one?

  - have a way to not link with hint, to reduce link time for test runs

  * should I make the control title expression the first one instead of last?
  - Circular imports of Derive.Derive and Derive.Scale causes a lot of
    recompiling.  Can I eliminate or reduce it?

    If I put (Note -> Maybe ValCall) in Scale, then Scale needs to import
    Derive.  If I give it a type param then it's hard for TrackLang.Val to
    have a Scale

    So either, put Val and Scale into Derive, or store ScaleIds in Val

    Val will drag in too much stuff so I don't want to move it to Derive.

    I can parameterize Val with scale, then use Derive.Val everywhere.  Will
    anyone have a problem with this?

    Or change Pitch.Scale to GenericScale, then give it ().  Add Derive.Scale
    that puts in ValCall.

    Make a hs-boot.  Scale imports Derive, for ValCall.
    Scales need Derive since they have Derivers.  But Derive needs scales to
    look them up.  Maybe put a 'import SOURCE Scale.scale_map'?

    Or, can I split scale defs into uses Derive and doesn't?  Ugh.  I think
    I just need to split Twelve.scale_id into Score.default_scale_id or
    something.

  - Derive.with_* should use local, or at least finally
  - clean up warp stuff in Derive.Score
  - put TypeError into DeriveError and use Call.default_relative_note
  - LPitch.to_relative was broken by notes as calls, fix it
  - implement add_hz in Derive.Scale.Util

  * remove TrackLang.VMethod
  - remove consumed call return unless I can think of something good for it
  * test_util regex match uses a simplified regex that only supports *

  - incremental saving: pair diffs with the changed bit.  Then save that chunk
    on every save.  Occaisionally write a checkpoint, which is just the whole
    state, and throw away all states before it.  On load, scan to the last
    checkpoint, load it, and apply the subsequent diffs.  On undo, if there are
    no previous states, load the previous checkpoint and apply its diffs.

  + rts crash
    - Did alignment change fix it?  Wait a while and mail list if it's still
      gone.
    easier to repro if I start a bunch of derive threads and click
    try removing pokes and see if I can still repro, I can get positive
    confirmation at least

  * run a set of profilers as a script and save the results

  - performance:
    + eliminate the deriver memory spike
      * got some of it by strictifying a few Derive.State fields
      - why does "get" produce so much garbage?
      - at_linear is called a lot by compose, by compose_warp, by d_warp
        can I make this more efficient?

      - doesn't seem to happen so much with subderivations
      - possibly put/get/modify is too lazy?
      - maybe split Derive.State into dynamic and static portions?
      - or maybe it's the control deriver creating a huge list of signal
        chunks, which is then all forced at once since merge needs them all.

      - Deriver [Event] output is not lazy, because ErrorT won't let it be.
        I think this means I need to localize derive exceptions and remove
        ErrorT from DeriveT.  I still run calls in ErrorT though.

      - more efficient type for events:
        data EventList = Nil (Maybe Exception)
            -- | I produce a lot of singletons, so optimize away a pointer.
            | Event1 !Score.Event
            -- | Unroll a chunk of events.
            | Event16 !Score.Event !Score.Event ... EventList
            | EventCons !Score.Event EventList

    - make a profile for modification and recomputation of a large structure,
      the sort of thing memoization would help with
    - fix Perform and Signal memory spike exhibited by "generate control"
      - order of printing warns matters, experiment 'seq generate control'
        without warns
      - can I eliminate the warn/msg order thing by inserting strictness?
    - Signal.pitch_share I think is still used even when I have signal IDs
      profile and make sure it's fast for common cases

    - implement signal IDs
      - Avoid converting signals more than once.  For this I need to not
        truncate the pitch signal, or at least chop off the beginning as well.
      - Avoid expensive sharing check for channelize.
    - switch to attoparsec for parsing

  - clean up inst_config / lookup_inst situation in DeriveTest / Derive_profile

  * move test_obj/ and profile_obj/ to build/test and build/profile
  * cc on a multiplexed inst is not being merged
  - why does creating a block in setup cmd without a view go to cpu 100%?
  - Derive: inst as a call rather than just something from the env
  * symbolic score: remove null call
  * make some score generators for performance testing

  - more sophisticated function to find out the inst of a note track
  / put prev, cur, next in PassedArgs too?
    except that transformers currently don't get these args
    what would the track transformer pass?
  * remove warped control?
  - subblock derivation for control tracks
  * re-enable signal deriver, but in a more efficient way?

UNSORTED
  / move MakeRuler to Lang too?
    no, it's used by Cmd.Create, which is used by keybindings

  - clicking jumps to timestep points that arrows won't jump to
  - playback should have multiple lines when a block is derived multiple times
    have a set of playback selnums?
  - rederive lang cmd
  - insts with breath are not easy to use
    if I make sure breah control goes thru then I shouldn't need anything
    special
  - local inst db, in Ui.State, so I can e.g. set pb range for fm/* inst

  * midi input doesn't advance on note off
  - midi thru doesn't pick up default inst
    empty scale defaults in Derive, but not in Cmd
  - cmd to resize window to fit tracks
  - implement continuous controller warp
  - make Track.UnsortedEvents and Track.SortedEvents, type or newtype?
  - insert and delete time should use the selection if non-point
  - rename project -> namespace
  - document / enforce naming restrictions for CallId, Control, etc?

  - test relative pitch slide!
  - should tab in raw edit mode go to method?  how to go back then?
  - select track, st3 style select block, track
  - cut + paste didn't work with a point paste

  track management:
    - resize a bunch of tracks at once
    - collapse tracks down to minimum width?

  - editing for "pattern list" block
  - double click call to jump to its block?


MILESTONES
  0.1
    * scales and keyswitches
    + efficient thru
    + tracklang complete with set of basic calls
    - dense / efficient control signals
    - lazy signals
    - memoize deriver output, to avoid unnecessary rederivation
    - symbolic score
    - midi record / integrator
    - save undo history
    - solution for audio, plugins, track bouncing, etc.  ardour?
    - linux port
  1.0
    - display / edit derivations inline
    - print scores
    - mouse oriented signal editing
    - freeze tracks / audio memoization: doc/freeze_track
    - windows port?
    - non-midi instruments
  far future
    - render audio
    - include audio inline

----------------------------------------------------------------------

- switch to darcs hashed repo format
  darcs optimize --upgrade
  darcs optimize --pristine

note input / thru:
  - some way to turn off all midi thru / input
  - keyswitch support in midi thru
  - profile midi->midi thru and implement a fast path if necessary

bugs:
  - #(poke Mispeled, field) fieldp field results in compiler bus error
  - clipboard is not copying the skeleton
  - deriving signal causes event derive to fail too?
  - keymap collisions are logged twice
  - Create.rename_project loses the merged tracks
  * bring block windows to the front after a load / no don't, it's annoying

  - tracks with different tempos play correctly, but playback follows tempo
  - unparsed notes are played instead of dropped, it's because the pitch is
    dropped but not the note
  - bizarre hint importing requirements in Cmd.LanguageEnviron
  + track down ghc rts crashes, assertion failure
    could be:
      - bad poke in Ui/*.hsc, perhaps due to alignment
        * eliminated use of allocaBytes for alloca, see if that helps
            no
        * find_events
        - update selection
        - ...
      * concurrent call problem with CoreMidi
        * replace CoreMidi with stub interface
        no, still happens
      * bad poke in CoreMidi
      * inconsistent compile, hptSomeThingBelowUs is another symptom
        - report bug with repro instructions
      - bad write in c++ (but it's read-only, isn't it?  bad free?)

    - it showed up when ghc started paying attention to alignment, look into
      allocaBytes and allocaBytesAligned
    add -DS flag
    crash is when evacuating pinned memory, is it a foreign ptr?
    - run under valgrind
    - why doesn't valgrind reveal bad memory access from haskell, e.g. poke...
      from http://www.haskell.org/gtk2hs/
      A note of caution: Using Gtk2Hs together with the -threaded ghc is
      currently not supported. The reason is that GHC's garbage collector might
      free Xlib or Win32 objects using an OS thread different to the one that
      is used to execute all other Gtk+ functions.
  - hint refuses to compile when a module emits a warning

cleanup:
  - cleanup Ui.Track: event_list -> all_events?
  - split Derive.State into dynamically scoped, constant, and logging parts
  - State.structure only used by Clip_test
  - Makefile: ghc --make doesn't understand the hsc -> hs link, which leads to
    manual inclusion of $(UI_HS) in the deps
  - remove Util.Log -> Perform.Warning import by translating IDs into strings?
    On the other hand, it's not unreasonable for logs to use other data types
  - having collapsed state in c++ is kind of error-prone, should I go back to
    trying to put it in haskell?
  * hspp doesn't catch calls to Derive.throw and Derive.warn within Derive
  * hspp screws up \\ string continuations
  error prone things:
    - setting some state like project directly through State won't update
      global status.  Maybe I could fix this and also avoid the scattered syncs
      by doing a special state diff after cmds
      sync: state_project, state_project_scale
    - creating a block through State.create_block instead of Cmd.create_block
      won't get the current track box color
  - since tracklang lets me apply derivers to tracks and skel makes the
    structure explicit, do I still need the schema?  at least for Cmds, I do
    need a way to look up Cmds based on track focus.  Before doing anything
    rash, think about ways to derive e.g. 工尺譜.

performance:
  - More efficient signal comparison in Perform.Midi
    Derive.State keeps a counter.  This is incremented and assigned by
    'with_control'.  The MIDI layer can then compare IDs to tell if the signal
    is the same.  It's reasonable for controls to extend through the decay of
    the note, so this is enough for them.  Should I try to merge even when the
    IDs differ?  How about no at first.

    Pitch is unusual in that it is implicitly clipped at the start of the next
    note.

  - If a msg aborts or doesn't run any cmds, don't bother to run diff.
    Except that hardly ever happens if I do shortcut thru.

  - profile derivation, if parsing is a problem, look into attoparsec
  * profile with and without strict state monad
  speed and memory profiling:
    - respond to incoming notes
    - diff and modify UI
    - derive a large score
  - only derive first few seconds?  Or derive up to selection + a few seconds?
    implement caching first
    to log incrementally, emit log msg every n sec of derivation
  - use a lazy storeable vector for [Score.Event] and [Midi.Message] to save
    memory?
  random little hangs are annoying.  figure out what's going on.  GC?
    - timer can summarize one responder loop cycle?
    - get diff results is really slow
    from yi bug:
      * GHC triggers a major GC everytime Yi becomes active whenever user
      resumes typing
      * Major GC takes increasingly long time as number of object grows (as
      expected)
      So, we have to iron out all memory leaks.

  - send style id to c++ instead of all the style elements
  - strictify some basic datatypes with ! and {-# UNPACK #-}:
    Ui.Event, Midi.Message, Perform.Midi.Instrument.Instrument
  - collapsing a track shouldn't trigger a rederive
  caching:
    - in c++, cache marks and events from callback
    - cache track cmds for each track, update when the track title or skeleton
      changes
    - deriver caching, see doc/derive_cache
  - derive multiple blocks with strategies, par, parMap.  Can I spark all
    subderivations?

symbolic score as in doc/custom_symbols
  - tracklang parsing: remove null call so I can say the first word is
    anything.  It would be really nice to have arbitrary symbols as calls.
    I can do this by going to a purely location based system, so the first word
    is always a symbol.  But then I need to think of a replacement for the null
    call concept.

    Note: "" -> null call, and I don't mind losing ">i" for "inst = >i"

    Control: I suppose a special hack where if the text is a number, call "set
    n".  I already have the syntax mangle.

    Pitch: Same hack, only xyz -> 'set *xyz'.  That means there's no way to
    write a nullary call, say 'subblock'.  But if notes wind up being calls,
    the mangle can just go away and the problem is gone.

    Note: no mangle?

    How does this interact with the other idea to have inst be a call?
      call = >some/inst
    Now this actually affects the mangler, '' is mangled to
    '>some/inst'.  It might be a little cleaner to always mangle to
    'default', and then put the inst calling logic in 'default'.

    Now what about 'block0'?  It's ok, the inst is still inherited by the sub.
    What about '+attr'?  I want it to become '>inst +attr'  However, it might
    be nicer to not implement +attr and leave it to local bindings.  E.g.
    bind 'attr' to 'default +attr'.  That way, a call to 'sn' could be either
    a call to 'attrs = +sn | default' or just a call to 'sn'.

    How to represent symbols?

    If I a native text entry widget then it should be possible to expand
    symbols into their ?name? notation for editing, and render them as a symbol
    for display.  Of course, for unicode characters I can also rely on an IME,
    so I would need some way to decide which to expand.

fltk:
  - some kind of special highlight to indicate the active block
  - rethrow c++ exceptions as FltkError
  - bug: somehow capslock keydown is sent sometimes
  - auto add pitch track when a track title input is expanded crashes with
    assertion error 'title->w() == body->w()'
    solution: text entry is collapsed by track add, remove, or resize
  - factor scroll redrawing into a single class
  - draw arrows in SkeletonDisplay.cc properly
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  draw bugs:
    - redraw after track range damage draws things a pixel too low
    - when scrolling upwards, ruler mark text is not drawn completely
    - doesn't redraw after switching monitors
  Track
    / dividers can have separate color for upper part, for collapsable tracks
  event track
    - events pass style as a uchar ID for consistency and memory savings
    - visual indication when both solo and mute is on
    - adjacent collpsed tracks are merged
    - editing event text should use a text entry widget, that way I get
      a cursor, IME, etc.  A side benefit is that I don't have to derive half
      edited data.  This also solves the problem where the currently edited
      event is hidden.

      This only applies to raw edit mode.  Entering notes and doing
      programmatic changes is still single key.

      Remove the separate raw edit mode.  Return while in edit mode creates an
      event if one doesn't exist and begins editing its text.  Keyboard focus
      is then in the widget until return or tab or a click outside of it.

      The responder has to be able to tell UI to open a text entry, so return
      (State, [UiCommand]), where
        data Edit = Edit {
          edit_block_id :: BlockId
          , edit_tracknum :: TrackNum
          , edit_at :: ScoreTime
          , edit_text :: String
          , edit_insert :: Bool
          , edit_selected :: Bool
          }

      If the edit_insert is True and there is already a text entry open at
      that position, insert the given string at the insertion point rather
      than creating a new one.  This can implement midi->*note insertion.

      Return msg is:
        data Edited = Edited BlockId TrackNum ScoreTime String

      The UI can suppress this if it detects the text hasn't changed.

    - "currently edited" event shouldn't be hidden by previous ones
      bring event closest to cursor to front?

    - I think I still need a better story for collapsed events.  Maybe keep
      a local cache of TrackPos -> IsHidden, this is just a record of where
      text was drawn.
      It seems to do this right I'd have to redraw the events each time the
      selection moved, start from the selection and work outwards.  This way
      the "selected" event is visible.  Of course I only have to redraw out
      to the last event that had to change.  And I think I can still optimize
      scrolling, I just have to keep the local pos->hidden cache, which gets
      cleared on a track update.

    - collapsed events: Or, record bounding boxes of text drawn, shift them on
      scroll

  control track, render signal
    - support control signals that aren't just 0--1
    - signal filled display is chunky and ugly.  I think they would be
      nicer as one long line.  I should also not round xpos to an integer.
    * scale markers on pitch signals
    - render option: solid with color gradient
    - combine multiple signals, e.g. one controls xpos, one controls color

  MoveTile
    - only capture drag on a plain drag with no modifiers

libfltk:
  * try cocoa fltk patch
    * wait for clipping and modifier event patches to go in
  * window position not restored on load
    * had to patch fltk, test Fl_cocoa.mm, make str for Fl_mac.cxx
    * str 2309
  + fltk 1.3 Fl_Display_Text has alignment bugs, and too slow
    - sent mail to list

logging:
  - trying to derive relative blocks generates a lot of log spam, can I avoid
    that somehow?
  - commands like Selection or MIDI thru generate too much log spam, maybe
    filter logs for those?
  - compile_to_signals spams too much when there is an error

logview:
  - haskell and c++ use the same machine readable format
  - LogView should use Util.Fltk
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...
  - collapse duplicate lines

control fltk
  dense sampled signals
    - efficient storage, preferably as a Signal so no conversion is necessary
    - display dense signals: omit text and trigger lines when zoomed out
  / decided against rendering signal as one long line, comment in EventTrack.cc

Ui:
  Track
    - benchmark large TrackEvents
    more compact implemnetation than Data.Map?  profile first!
      - priorities: memory efficiency, persistent, merge speed (insert many)
        shallow tree of dense chunks?
        can I take advantage of non-overlap?  [(pos0, data), (pos1, end), ...]
        data Event = Event String StyleId | End | ControlVal Double
      - I think memory efficiency is more important than modification speed

skeleton:
  - parse skeleton in LanguageCmds

test:
  - write a fltk structure dump so UI tests can be non-interactive
  - tests count number of tests in addition to checks within each test
  - it should be possible to build only certain tests into RunTests
  - use generics or Foldable or something to write a generic StructEqual
  - RunTests.hs: if running >1 init-* tests, run them in sub processes

misc:
  - program to launch logview and seq together
  - ^T on the cmdline prints stuff!?

integrator / midi record:
  - implement

REPL repl language
  - haskeline sucks for long lines, add multiple line editing?
    really I'd prefer plan9 style esc then edit
  - could add syntax mangling, but probably better to add it to the mangler
    so it works for everyone
  - pass -fobject-code to avoid trying to recompile files?
  * add custom interpreter for some commands to make them fast?

Cmd:
  ? a module with easy access to all GlobalKeymap cmds for cmdline access
  - cmd to give a view focus and bring it to the front
  vi style keymap:
    - movement: hjkl, HJKL to move timestep+1 or skip to
      next inst track, bf to move timestep at block section rank, BF to move to
      top and bottom of block
    - esc and i for edit mode
    - number prefixed cmds?  not for now
  Cmd.Edit
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - trackerlike note entry: entered events are all as long as the block
      (merge will clip them to the next event)
    - map selection through function
    - transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces
    - a legato command that always goes to the next note would still be useful
   - swap tracks keeping skeleton up to date
   - double / halve events under selection
   - stretch events in selection to another length (need two selections?)
  Cmd.Selection
    - select_and_scroll doesn't scroll down when going from no sel -> sel
  Cmd.TimeStep
    - snap to event begin/end

  Cmd.NoteTrack
    - record velocity if there is a velocity track
    - chord input, if there are multiple note tracks for this inst

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.Play
    * warn about unallocated instruments (Convert.verify)
    * make sure the whole stack is lazy
    - play loops
    smarter background derivation
      * wait a second before deriving
      - don't derive while a key or mouse button is down
    - start playing from top of displayed area
    - start playing from TimeStep before insert point

  Undo
    - figure out how to checkpoint just state diffs
    - add undo history to on-disk format

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice or delete time or a Meter into a ruler

  Cmd.Freeze
    - details in doc/freeze_track

  Cmd.Save
    - save with a magic number so I can load songs, inst configs, etc.
    - gzip save files

Derive:
  instrument
    - per-project short aliases for inst names so you can fit them in tracks
      easily
    - Implement >inst as setting the null call instead of env.instrument.
      That way the inst has control over the interpretation of e.g. attributes
      and pitch slide (to implement piano style retrigger)

  - implement postproc calls
    - framework for determining scope of a postproc: per inst, per track,
      for pre or post overlaps, etc.
    - Think about how to keep incremental recomputation in the presence of
      postproc.  I suppose they have to declare how much they depend on.
    examples of postprocs:
      * echo
      - retune a note depending on the previous interval (e.g. sloppy pitches
        when playing quickly)
      - negative duration
      - instrument deriver that makes it retrigger on pitch changes, e.g. for
        trills on a piano... I think this has to be score postproc because it
        needs to be pre-scale conversion
        I think I'd rather do this as part of the instrument, though.
      * string emulation:  Every note is assigned a string.  When
        a legato new note is played, it either stops an existing string or takes
        a new one.  The previous note will either ring for a decay if the
        string is unassigned, or reset to its "open" pitch otherwise.  Strings
        can either assume their new pitch instantly (stopped), or gradually
        (bent).
      - overblow emulation: a set of overblow ranges are defined, along with
        possible pitches for each one (fundamental and overblow harmonics).
        When a note moves from one to another, start a new note at the
        destination pitch and bend the decay of the old one to the fundamental
        or closer harmonic from the previous mode.
      - rambat damping emulation: notes ring on by default until they can be
        damped.  Damp at the first opportunity, where opportunity is defined
        as a break with no notes for a certain amount of time.  Can only damp
        two neighboring notes at a time.

  - derivers for sekaran patterns
    - do a code version and a block version
    - block version requires block arguments and variable substitution
    - implement deriver like vla/cello duet?  that's a sekaran, so I need to
      think about this more.
  TrackLang tracklang
    * TrackLang.optional args should be able to pass Nothing if arg is not given
    - Derive.Call.map_asc_events, I need Seq.merge_asc_lists for this.
    - make sure signal derivation doesn't do calls
    - implement call by arg name e.g. "delay time=%xyz"
    * implement control calls
    - implement block level calls in block title
    - other attributes in block title, e.g. "alias=?squiggle? | xyz"?
    * support pitch signals, e.g. "tune-to %*some-sig" but that requires named
      pitch signals

    * implement sub-calls with TVal return type
      Now I have so many call maps, can I merge them?
        - relative control and pitch
        - note, control, and pitch
        - tval
    * implement scales as a set of sub-calls that return pitches
      * they can take a number for cents offset: (*4c# 20)
    * merge pitch call namespace with normal call namespace

  - dynamics controls:
    - volume, velocity, and breath map directly to midi vals
    - pres is continuous volume, maps to velocity or breath depending on inst
    - vel is attack volume, maps to velocity or breath but is only sampled at
      the beginning of the note
  - to cut the middle out of a pattern: a cut signal that disabled derivation
    when it's 1?

  - combine ornaments, like "hold 1s | tr" to hold the first note for 1 score
    time before starting the trill.  I think this could work by warping tr

  - ScoreTime and RealTime literals: 1s, 1r
    If I had score and real time literals, I could merge abs and score trills.
    Then I need to support either typed controls, or a notation for "cont
    x interpreted as score time".

    trill 1 4s -> Signal (Just (RealTime 4), Control)
    trill 1 s%cont -> Signal (Nothing :: Maybe RealTime, Control)

    data ControlType = Scalar ScalarType Signal.Control
        | Pitch PitchType PitchSignal.PitchSignal
    data ScalarType = TReal | TScore | TNum
    data PitchType = TAbsolutePitch | TRelativePitch
  - time interval literal, so I can specify e.g. trill speed in terms of beats
    This means Derive has to have access to the rulers.

  deriver customization
    - bind symbol names, e.g. bind specific-trill to local 'tr' symbol
    - set dynamic env vals, especially if a family of derivers use the same
      argument names for analogous behaviour, e.g. 'tr-speed'
    - make it easy to add haskell derivers, tracklang must remain simple
    - derivers call other derivers, which can be rebound

  * arg processing: arg defaults taken automatically from the env, if
    prefixed with call name: "call-arg"
    - one problem with this is rebound symbols, do I want to force new names?
      I think I do, because otherwise it exposes the underlying symbol.
  - test Calls that return overlapping events
  - block-level calls
  - x = _ will unset x

  - Cmd: after entering 'x = y' event, can it automatically set dur=0?

  - come up with a syntax for Ui.Event preproc calls
    >inst1 | echo < preproc1 < preproc2
  - also I can have a post-parse "macro" preproc pass, this is more suited
    for prepending a call
  - re-implement directives: derive_notes returns (EventDeriver, [Event])
    wait until I have a call that wants to use it (suppress event?)

  - When looking for the next note on, I should skip notes which are just
    'statements' that produce no notes.  That way a var set won't interrupt
    the pitch sig.

  - implement automatic block splitting as described in doc/tracklang
  - some kind of notation for replacing the track interpreter, e.g.
    TrackId -> EventDeriver.
    This could be used to implement macros, and also preproc.

  val calls:
    - val calls to get the next/prev TimeStep

  note calls:
    * Implement tick as a call:
      Need to get next and prev Ui.Event, get pitch from pitch sig
      to_local (between (to_gloal prev_pos) (to_gloal next_pos)
      d_absolute_at = d_at . to_local

    - Implement suppress as call:
      This is more tricky, how can a call modify neighbors?  Especially
      preceding ones.  This seems to mean I still need postproc calls:
      DeriveT -> DeriveT.  Internally it evaluates the deriver, processes
      the Score.Events and wraps it in another deriver (the seq equivalent of
      cue).  After that most behaviours are ineffective, but them's the
      breaks I guess.  It seems nicer if I could pass something to the block
      to cause it to skip the downbeat, but how can I do this in a non-ad-hoc
      way?  If I can insert a per-project block deriver I can add it as an arg.

    - Implement tuplet:
      't *n1 *n2 *n3 |' runs deriver three times with three different
      pitches.

    - Implement clip-call:
      Undo the call stretching, this should be efficient because of stretch
      combining:

      d_stretch (recip (dur/block_dur)) $ d_clip dur $ deriver
      "unstretch | sub"

      A non-block call (including notes) will have a block_dur == dur.  I can
      also imagine a version without the clip.  'unstretch' is a crummy name
      though.  'restore'?  'abs-dur'?

    / Implement sekar derivation.  The tricky thing here is I want n notes, not
      a call with n args.  Use the Generator "consumed" return val for this.
        Seleh can pair derivers:
          seq [stretch 0.5 (seq d1 d2), stretch 0.5 (seq d1 d2)]
          (d1 @> d2) ~ 0.5 @> (d1 @> d2) ~ 0.5

        Without logical-stop I can't sequence Derivers.

      It would be nice to do a piece on sekar patterns where the form itself is
      in the same pattern, for a kind of fractal structure.  How to have
      a pattern derive patterns?

      - pass the calls as block args
      - put the null deriver in the env
      - more general than the above: dynamically scoped call map and syntax to
        modify it
      - env var that prepends or appends calls to notes.  actually, this is
        better done as a preproc.

      Maybe I could unify the env and call map and also a general variable
      facility: var = val -- 'var' is a symbol, so assign to the call map,
      'val' is a symbol so look up in call map and env

      call var var -- look up 'var's

      This way I need a VFunction type and variable lookup.

    * Implement trill
      * absolute tempo version that adds new cycles when stretched
      * version with n cycles that stretches with tempo
      - hybrid where the initial part stretches, final part is absolute

  PitchTrack pitch
    * Named pitch tracks, so derivers (e.g. tuned just scale) can take pitch
      track args.  The way this could work is that the state_pitch becomes
      'Map SignalName PitchSignal' and the "" signal is taken by the note
      deriver during convert.  Track syntax:
      "*scale" -> ("", ScaleId scale)
      "*scale %psig -> ("psig", ScaleId scale)

  ControlTrack control
    interpolators
      - sine
      - constant slope, exp slope (i.e. slope until next control event)
      - continuous tempo warping for signals
        tempo: "2" -> "1", "2", cont: "2" -> "i, 1", should emit a bent line
  Derive.Scale scale scales
    - implement pengumbang pengisep
    - enharmonics for Twelve
    - just intonation tuned to a pitch signal
    - looks like fun: http://en.wikipedia.org/wiki/Bohlen-Pierce_scale
    - retune a note depending on the previous interval (e.g. sloppy pitches
      when playing quickly)
      I think this has to be postproc.
    - some kind of ratio based notation?  check out Ben Jonston's just notation
    - octatonic
    - parser for scala .scl files

   - Control track management?  It should be possible to have a note or a bunch
     of note tracks with a bunch of control tracks and control the clutter.
     Ideas: collapse has limited usefulness when there are too many, even with
     color coding.  I could do this with logview: selecting a note track logs
     a list of its control tracks and whether they are hidden or not.  Clicking
     on one in logview will emit a cmd that will hide or show that track.
     Or I could use a UI for adding new controls too: click a track, then a cmd
     'add_control "vel"', this will unhide and focus the control if it exists,
     or create a new one and link it with the skeleton if it doesn't.  ^T is
     intended to create new note tracks, and they're only linked to tempo
     initially.

     This implies a slightly more generic and acme-ish system for logview:
     anything enclosed in {}s can be clicked and will be sent verbatim, even if
     it's in the catch line:

     -- title (tracknum): inst_name, allocation, [control tracks]
     Inst (track 1): fm8/inst1, fm8:0,1,2, [vel {hide 2}, pedal {show 3}]

  - suspend automatic derivation while there's a note down?  use Cmd.Mod
    instead of the note_id map since it should be more reliable.
  - block derivation memoization / caching
  - set instrument within note track, controller within control track
  - separate instrument track, as a kind of controller track
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - reflect derivation back into a block
  - merge block level changes with derivation

Perform:
  - instruments can have a native scale, so playing that scale won't involve
    pitch bends
  Instrument
    - some kind of organized way to manage instruments and instrument config
    - some basic midi instrument defs for generic midi (dev, patch)

  Signal
    - lazy implementation

  Midi:
    - see if synths support the set pitchbend range controller
    - Convert certain attrs to controls for cc 'keyswitches'.

Instrument DB:
  - search lang supports quotes
  - search lang supports - to exclude a term
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - now that PatchTemplate is gone, maybe I can use a simpler storage format
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi:
  bandwidth
    - keep stats
    - display widget

misc ideas:
  - should be a documented extensible way to add new track types without
    modifying core ADTs
  - Staff notation represents chords well, but tracks don't.  Think of a more
    compact notation.
  - Staff notation output via lilypond?
  - if derivation needs event IDs, maybe I can use the value-supply package
  - safecopy package does version controlled serialization
  - think about yi's approach to keybindings as a parser and keybinding state
  - also investigate yi's approach to configuration

future:
  - I need to sync with a DAW but don't want to implement rewire.
    Which DAWs support jack?  ardour, reaper?, ...?

    Can I use ardour as vst host, DAW, and track freezer?  It has OSC support
    and I could add more.  Downside: no windows.

    - vst host: Need to programmatically load plugins, configure plugins, route
      audio.
    - DAW: Need to sync play position.
    - track freezer: Record plugin output, sync play position.

  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
