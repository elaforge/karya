- corruption when test block is scrolled to the right
- when I delete a block, do all the tracks get finalized?  I should keep track
of finalization and look for leaks.

- hint refuses to compile when Cmd.NoteEntry emits a warning
- Cmd.BlockConfig -> Block?  or View -> ViewConfig
- fix or remove logview_test
CURRENT
  - bring selection delete back
  - schema cmds can return errors

  - collapsing a track shouldn't trigger a rederive
  - skel_display status can be two chars: Sm is solo+mute
  + insert new track skeleton splice
  + fix hint stuff
  + merged tracks
    - adjacent collpsed tracks are merged
  - verify selected_tracks and selected_events

  track management:
    - resize a bunch of tracks at once
    - plain (non-merging) collapse

  - TODO / haddock sweep
  - sample reyong
  - transcribe kebyar duduk

  - i control track thing
  - editing for "pattern list" block
  - double click call to jump to its block?

- verify twelve ->midi mapping and range checking

MILESTONES
  0.1
    + scales and keyswitches
    + efficient thru
    - dense / efficient control signals
    - memoize deriver output, to avoid unnecessary rederivation
    - midi record / integrator
    - save undo history
  future
    - freeze tracks / audio memoization: doc/freeze_track
    - vst host
    - jack / rewrite
    - non-midi instruments

- make sure pitch terminology is consistent:
  KeyNumber = scale independent note, Note = note in scale,
  Pitch = freq easily mapped to and from nn, same as NoteNumber,
  NoteNumber = Midi.Key + decimal

- support for Schema.default_scale, esp since it gets automatically added

bug haskell-cafe:
  - buggy ghci debugger
  - haddock problems
  + hint trouble

----

- remove State.modify_event_range?
- either ruler is binary or step goes in binary steps.  otherwise there are
durations that I can't reach with any step.

- optimization: if a msg aborts or doesn't run any cmds, don't bother to run
diff.  except that hardly ever happens if I do shortcut thru

- per-project short aliases for inst names so you can fit them in tracks easily

- cmds return (status, record_undo).  Also can Cmds include a name so it can be
logged or attached to an exception?  I guess the keymap thing is probably
enough.

- caching
  on sync, check cache validity against updates, and regenerate signals and
  events on blocks if necessary.
- pass signal by pointer

display signal:
  cmd makes a change to a controller track
  diff (and cmd) generate TrackEvents update
  sync processes TrackEvents and TrackAllEvents and merges it with samples

  so where does sync get the samples?  I can pass it [(TrackId, Samples)]
  that comes from (Track, Signal), which comes from a partial derivation
  most derivers should be able to get that from the Skeleton

****
- switch to darcs hashed repo format

note input / thru:
  * fractional InputKey and GenericNote
  - keyswitch support in midi thru
  - profile midi->midi thru and implement a fast path if necessary

bugs:
  * when I do just space, I get "keyup not in modifiers"
    cmd_record_keys not getting run when play throws?
  * ^C should quit instead of killing ui thread and hanging
  - cmd-q should also quit entirely not just close the windows
  * backspace to delete events doesn't work
  * note on track keeps adding new tracks
  * rederive should be triggered by: track title change, skel change, track
    flags change
  - tracks with different tempos play correctly, but playback follows tempo
  - unparsed notes are played instead of dropped

performance:
  - random little hangs are annoying.  figure out what's going on.  GC?
  * pause before playing.  printing logs make playing too strict?
  - cache marks and events from callback
  - will removing the style speed up event copying?

fltk:
  - draw arrows in SkeletonDisplay.cc properly
  - convert Selection to use the same format as hs, so it can show the cursor
    end specially
  - bug: selection redraw leaves gaps when dragging downwards
  * bug: in test_block, resizing tracks, leftmost track title is confused
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  - bug: doesn't redraw after switching monitors
  - SeqInputs should display the right side of the text if they're too small
  UI Msgs
    * can I capture os x two-finger drag events?
      yes, they're reported as FL_MOUSEWHEEL, so I should scroll on mousewheel
  Track
    / dividers can have separate color for upper part, for collapsable tracks
    * tracks have their own status lines, to report things like mute
  event track
    - "currently edited" event shouldn't be hidden by previous ones
  Ruler
    * mark text is abbreviated if there isn't enough room
  MoveTile
    - only capture drag on a plain drag with no modifiers
    * bug: when there are two adjacent dividers, the right one can be resized

logging logview:
  * logview needs scrollbars
  * don't store msgs in memory, don't refilter from begining
  - use bytestrings?
  * colorize (tid ..) (bid ..) (vid ..) etc.
  - implement clickable srcpos and StackPos
  - haskell and c++ use the same machine readable format
  * rename LogViewer -> LogView just to reduce confusion
  - LogView should use Util.Fltk
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...
  - collapse duplicate lines

Ui:
  - some kind of special highlight to indicate the active block
  - rethrow c++ exceptions as FltkError
  Controllers
    * pass signals as pointers, not copies
    - make sure very dense (e.g. sampled) signals are displayed and stored
      efficiently, but are still editable normally when you zoom in.
    - signal render support for indexed signal type, especially pitch
    - events store style as a uchar ID for consistency and memory savings
  Track
    * patch Data.Map to include toDescList
    - benchmark large TrackEvents
    - modify IntMap for Word64s, add toDescList
      - send patch to libraries@haskell.org
    - track collapse
    * track mute
      - visual indication when both solo and mute is on
    - track merge

skeleton:
  + splice track: adding a new track automatically links into the skeleton
  - parse skeleton in LanguageCmds

test:
  - grepping tests gets multiple lines
  - tests count number of tests in addition to checks within each test

integrator / midi record:
  - implement

Cmd:
  - cmd to give a view focus and bring it to the front
  - Cmd_test
  - the cmds that return anything other than Done are rare, have a special case
    for them and make most cmds return ()
  Keymap
    - check for key assignment collisions
    - support generic modifiers like any Shift, any Control, and Command
      (which becomes alt on a PC keyboard)
  Cmd.Edit
    * change note lengths
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - trackerlike note entry: entered events are all as long as the block
      (merge will clip them to the next event)
    - map selection through function
    - transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces
    * nudge events
    - a legato command that always goes to the next note would still be useful
    - method edit works in controller tracks
  Cmd.Selection
    * drag snap to timestep
    * extend selection with shift-arrow
  Cmd.TimeStep
    - snap to event begin/end

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.Play
    - warn about unallocated instruments (Convert.verify)
    * make sure the whole stack is lazy
    - play loops
    * background derivation
    - start playing from top of displayed area
    - start playing from TimeStep before insert point

  Cmd.Record
    - come up with a plan for midi recording
    - implement simple midi underiver aka integrator

  Undo
    * implement undo and undo/redo cmds
    - figure out how to checkpoint just state diffs
    - add undo history to on-disk format

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice or delete time or a Meter into a ruler

  Cmd.Freeze
    - details in doc/freeze_track

Derive:
  derivers
    * control
    * tempo
      * multiple tempos per block
    * subblock derivation
  PitchTrack pitch
    - pitch signal should be Signal (Method, Pitch) so that they can be
      transposed
    - alternate scales
    - relative pitches, e.g. +5
  NoteTrack note
    - record velocity if there is a velocity track
    - chord input, if there are multiple note tracks for this inst
  ControlTrack control
    - relative controller tracks, combined with an operator, so e.g. "+, *scale"
      adds to the pitch track, and "*, volume" multiplies with the volume track
      operators: +, *, min, max
    - just plain "i" means the previous val, to make timed slides easier
      "approach val" method to make pitch bend easier, or just insert two
      notes?  the former is higher-level...
      something like: a5- g2e1 b5-
      or "a5- ;; i ;; 2e, b5-", much better!

  - suspend automatic derivation while there's a note down?  use Cmd.Mod
    instead of the note_id map since it should be more reliable.
  - block derivation memoization / caching
  - set instrument within note track, controller within control track
  - separate instrument track, as a kind of controller track
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - display derived blocks
  - 3 way merge for derived blocks

Perform:
  Player
    * flush midi output when I get a Stop
      * send patches upstream
  Midi
    * eliminate duplicate controller msgs
    * pitch signal rendering
    * support key switches

  Instrument
    - some kind of organized way to manage instruments and instrument config
    * backend-independent instrument def
    - some basic midi instrument defs for generic midi (dev, patch)
    * defs for z1 and vl1

  Signal
    - lazy implementation
    * implement Signal.equal
    - signal transformation derivers: +, *, /, min, max, ...
    * after implementing GUI drawing and transformation, reduce the
      proliferation of signal types
    - ensure that controllers are warped continuously by tempo

Instrument DB:
  - search lang supports quotes
  - search lang supports - to exclude a term
  - original file goes in a tag, not the text
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - now that PatchTemplate is gone, maybe I can use a simpler storage format
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi:
  * implement midi merging for midi thru
  * a single msg input thread instead of one thread per input port
  bandwidth
    - keep stats
    - display widget

misc ideas:
  - legato filter makes adjacent notes overlap a little, for keyed portamento
  - more complicated track names: "< legato < synth/inst" to pipe inst output
    through legato deriver
  - use "<" for tracks that generate data, ">" for ones that accept it, e.g.
    to display and merge a derived version
  - should be a documented extensible way to add new track types without
    modifying core ADTs

  - chord input... think about some kind of compact representation
  - if derivation needs event IDs, maybe I can use the value-supply package
  - safecopy package does version controlled serialization
  - check out loch package instead of hspp

research:
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - learn about hs gtk for reference

future:
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
