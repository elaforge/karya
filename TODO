- patch for hsc2hs for #alignment
- hsc2hs accepts slightly different flags from the c compiler which makes it a
  pain to write the make rule.  It should take --cflags='xyz' which is passed
  literally to the compiler.
- also patch to not put in #include pragmas

- fair amount of garbage generated by SignalBase.bsearch_above, I think this
is because it has to box the values when it pulls them out.  But it's really
just comparing to a Double, so I should be able to do the operation unboxed.
But decide about lazy signals before going nuts on this.  If I revert to linear
search then none of this is necessary.

CURRENT
  * move Types.Rect to Util.Rect
  * put collapsed state back into haskell
  run timing tests with bloom
    - compile with optimization and make sure it rederives fast
    - edit bits and make sure it rederives extra fast
    - lang cmds to fix time signature
  - ruler for LoadMod order list not exactly convenient... but maybe I just
    need event snap?
  * LoadMod should make narrower tracks, start collapsed
  - Create.view should size it to fit the block being created
  * zoom to fit cmd
  * Util.Seq.modify_at, change arg order to put list at last
  - shift [ and ] undo and redo zooms.  or one key to toggle last zoom?

  - derive cache msgs are only logged on play... can I have performance do
    that?
  * Get rid of perform cache, and hence need for EventDamage.
    yet another problem with the cache: a delete that changes the length of
    a block will generate the wrong EventDamage because the warp for that
    block has changed.  This cache stuff is just too error-prone.

    * add a perform_from that drops until >= given time
    * report how long it takes to play the first msgs, that reflects dropping
    * prime by forcing the first few score events, and report how long that
      takes
    * remove selection_pos
  - Note tracks no longer have to write local damage, only control ones.
  - see if ControlDamage is affected by the same problems (deleted events)
    as EventDamage

  * select ^a first selects *rest* of track
  * ability to set default tempo
  - block title takes up space and I'm not using it, can it collapse?
  * changing a merged track doesn't change visually
  * BlockC.insert_track passes a null merged so you can't make a view with
    tracks already merged
  * double click -> create view doesn't set focus on the new view
  signals below note track
    I think this means I don't need to worry about lazy signals anymore
    for tempo track, I can interpret the last sample as 1/1 instead of 0/1
    think about how I can use it to write sekaran

  - scrolling is slow with more than a few events onscreen
  better logging for cache
    * msgs should give context: which block were they deriving
    * CPU time to catch up to now
    derive
      * cache misses, clickable stack ranges
      should misses be logged at notice?
    perform
      * reperformed msg should be 0-12s cached, 12-15s reperformed, 15-end
        cached
  - lang level pretty print for events, esp collapsing the stack
  - add a Play.play_msgs function that plays the given msgs, normalizing so
    fst event is at 0.  Use to debug: LPerf.sel_midi >>= Play.play_msgs
  - cmd to save and load cache to disk
  - fix LPitch.note_to_degree

  * Cmd.CmdId is inconsistent with State.StateId
  * rename State.state_project_scale to default_scale
  * rename project to namespace
  - use functional references to make some of this record update stuff nicer?
    - fclabels: rename record fields, use setL and setL
    - lenses: got some magic for working with StateT?  don't understand yet
    - data-accessor
  * Derive.initial_state should get a default pitch from whatever scale is in
    the environ... or no default pitch at all
  * initial environ should also set scopes
  * Call.with_scale is not quite right because it should replace an existing
    scale scope.  So I think scopes have to have keys so they can be
    replaced.
  * fix the broken way Cmd.Schema infers scale and instrument
    Record env during derivation:
    When entering a track, save stack and env.  Then to lookup env just look
    for a stack ending with that track_id.  If >1, then just pick the first, or
    look at selection position in the first caller with >1 position, pick the
    one closest to the selection.

    a 1-2 / b 1-2 / c
    a 2-3 / b 1-2 / c

    It's important for note tracks to be able to get the scale of their pitch
    track, make sure the above scheme will work for that.

    This opens the door for cmds depending on other kinds of env, though
    I can't think of any compelling uses at the moment.  Maybe snap selection
    by sample rate?

  - storing TrackEvents without duration would make maintaining the no-overlap
    invariant easier.  E.g. have explicit 'off' events, otherwise each event
    extends to the next one.  It means after merging I have to clear redundant
    offs, but that's easier right?
  - using default Data.Binary instances to serialize is not good for
    compatibility in the long run
  - in the abscence of the ability to drag events, cmd to move start of event
    to current point, or set start and end if it's a range
  - lang cmd to show state hierarchically... or does it already exist?
  - do tuplets by setting local ruler?
  make midi msgs smaller:
    - last step of performer is to compact into vector
    how many msgs in e.g. the ptrio?
      127130, [pno 9205, flute 63748, clarinet 54177]
      5367 for bloom
      peak for 246114 msgs: 46mb for int, 38.7 for int, 38.7 for w64

  performance:
    - try using call/cc instead of either T
      Will require figuring out Derive.with_empty_collect when I get rid of
      catchError
      Also all 'local's no longer restore, which might be ok for the way the
      schema uses them, but seems error-prone in general (e.g. in
      a transformer).  Maybe I can catch errors by passing the continuation
      in a Reader, and using 'local' there too?
    - write my own Deriver monad to try to avoid lifting overhead
    - see if the cache filtering logs is causing significant copying and remove

  * remove the log timer stuff
  - maybe I could split CacheState into the writable portion, in Collect, and
    the read-only cache from the previous run, in Constant
  - remember about caching tracks, how can I make a track into a call?

  / instead of building log dup suppressing logic into various functions, e.g.
    allot, maybe I can add 'key' field to Log.Msg and suppress dup keys?
    Who else produces dups?  Convert does.  But isn't it more efficient to just
    not emit?
    - convert and perform want to suppress the same msgs for the current
      derivation
    - Perform.Midi.Cache.is_splice_failure is just a better way to identify
      the msg than text
    - cache wants to suppress all cache msgs until end of cached block
    The problem is that it's hard to know the boundaries of the current
    derivation, especially if there are multiple blocks being derived
    simultaneously.  I would have to put a block id key.  On the other hand,
    filtering in place knows that.  The extra copy is actually no worse than
    the filter at perform time, maybe better for cache since it only happens
    once.

  lazy deriver
    - I still don't understand what's going on with exceptions but it seems
      to be working.  Figure this out later, esp Derive.with_empty_collect
    - the log filter in Derive.Cache.insert_generator seems really bad.  Try
      to prove that with profiles, and then remove it.  Use a log-suppression
      framework to filter them before they are emitted?  Is that really more
      efficient?
    - see if I can make signal tracks happen lazy, or at least in order, by
      not threading Collect and CacheState.  Collect is just LocalDep, which is
      just (Set BlockId)

    lazy signals:
      - see if I can make control tracks truly lazy by making signals lazy
      - reimplement various functions like integrate and resample, bsearches
        must be linear
      - make linear searches faster for e.g. warp by dropping warp in the past
    - split writable CacheState from readonly?

    AppendList / MergeList for Derive.Stream
      - switch to AppendList and try to get garbage down
        Avoid copying sublists returned by block calls and cache hits
      - Midi.Cache.trim_events is a linear scan on all events from the
        beginning, seems like this would be faster if I could skip chunks.
      - see if a Merge constructor can reduce copying
      - can I cache length and range in AppendList?  does it matter?
      - insert parallelism?  maybe the evaluator can do that when it sees Merge?

    - when I save the cache for signal tracks, can I save a (Signal, Logs) pair
      to save space?

  - make tracks into calls, so they cache and the sub-run stuff works the same
    with them as other calls
    It would be nice to make them calls in the scopes, so they can be
    rebound like other calls.  This is effectively moving the Schema into
    calls.  Then I can entirely get rid of it.
    - move Schema.default_schema_deriver into c_block
    - make Schema.derive_track into a call
    The thing is block takes 'BlockId' and track takes (BlockId, TreeNode),
    not CallArgs.  And it doesn't make sense to call from the tracks anyway,
    so maybe not in Scopes.
    Not much point to trying to put it in Environ or Scope since it's
    a different type, but it could be dynamically scoped with the others, eg
    Derive.state_schema :: (BlockId -> 
    Basically it's the schema, but dynamicly scoped rather than attached to
    blocks.  I can't actually see how dynamic scope makes sense, it should be
    attached to blocks.  So keep it how it is, but call through generator
    cache.

    I want to do better tests about speed vs. space, cache hits and misses.
    Improve logging so that I can see, given a change, which areas of score
    were rederived, and then what range of midi was reperformed.

  - Can I make cached signal more efficient by merging the signals before
    stashing it?  Of course laziness means that this won't actually happen
    until the next time the cache is demanded, unless I force it.
  - when the dust settles, look into removing or simplifying Schema

  - packed midi, encode to storable vector
    but I'm not sure this will much help
    The main thing is how to encode the device.  I think I can hash it.  Or
    use OS X persistent device ID?

  profiles
    - profile edits (with and without auto-rederive)
      - without auto-rederive
      - with auto-rederive, derive to end
    - derivation
      - transformers: simple nested score with a couple of transformers over
        the entire thing

  - test sending mtc to reapaer
    also test some mmc commands.  How does reaper support control surfaces?

Also, I want to turn a new cmd on or off.  But I can do this just by adding
or removing from the cmd list.

UNSORTED
  - implement inst Cmd lookup, in same vein as call lookup
  - for control track entry, typing numbers puts them right of decimal, typing
    backtick enters a 1
  * create a set of profiles and a custom target to run them, so I can run them
    regularly and watch for regressions.  Maybe run them when tests run.
  - use capslock for kbd entry mode
  - flag for unpitched instruments, so they don't get pitch tracks
    I think I'd want to do a reverse map through the keymap to get the attrs
    This also gets to the per-song config issue, since I want per-song or
    per-track key -> call bindings.
  - keyboard editing: non-chord mode that advances as soon as it gets NoteOn
  - get rid of Diff.track_diff by doing all diffs in the main diff, and
    avoid sending msgs back to the UI by having ui msgs cancel updates.

  - why does logview go to 100 cpu?
    put some prints in there to see what it's doing when it does that
  - now that the signal deriver is gone, I can also get rid of ignore_tempo,
    unless I want to use it for a lilypond backend or something
  - after creating a new track, focus should go to its title
  - put a multiplier on play's timestamps to implement a play speed control
  - If I quit and then restart, the second start takes a long time.  What's
    it waiting on?  Midi init?
  * need a concept of a "root" block.  This block is used for:
    - calculating absolute time offset e.g. if a DAW wants to seek to a point
    * ability to start playing from n seconds back from the current position on
      the root block as inferred from the current position in a sub block.
      I can look at selection position on the parent blocks to know which
      particular invocation of the sub-block is meant.
    - Maybe if I know which invocation, I can figure out the environment so
      that I can know current scale and inst?
    - include root block in set_global_status, but I should do this from an
      always-run post cmd to avoid a separate Cmd.set_root_id.  Can I apply
      this to other State attrs too?

  - I really need to fix Signal.integrate

  - I think PitchSignals may need to be reworked.  They should be (Note, Note,
    Frac).  Otherwise, it's not clear what to call 4a# vs. 4ab.  I can still
    use numbers (Ints this time) as indices into a table of names, but e.g.
    (4c 50) will have to become (4c, 4c#, 0.5) instead of (60.5, 60.5, 0).
    But this means displaying the signal will become more straightforward.

    Remember that some scales may not have well defined degrees and may really
    be in NNs, e.g. a ratio relative scale.  They can't have a notion of
    transposition though.

  - I think if the same TrackId appears in multiple places, it will be derived
    redundantly.  I should be able to cache the signal output in a TrackSignal.
    But with any luck derive caching will take care of this.
  - TrackSignals is per TrackId, but the same TrackId may render to different
    signals in different positions because it has a differnt environment.  It
    should be (BlockId, TrackNum) + TrackId to verify in case the state was
    modified

  - set_render_style should trigger a rederive to get the track signal
  - LPitch.to_relative was broken by notes as calls, fix it
  - implement add_hz in Derive.Scale.Util
    or at least think about how to implement pengumbang and pengisep
  - subblock derivation for control tracks

  - playback should have multiple lines when a block is derived multiple times
    have a set of playback selnums?
  / should be able to rescan midi devices when something new is plugged in
    Centralize midi implementation functions in a record, include scan and
    open/close, record is stored in Cmd state.
    How to establish ID <-> device mapping?
    I think OS X midi ID is just for a persistent ID since names can be
    changed.  But I don't think I care too much about that?

    Read is not a problem since the midi layer handles the mapping.  Write
    needs: get (name, id), put name->id in write mapping

    Wait until I want to add JACK or alsa support.
  - local inst db, in Ui.State, so I can e.g. set pb range for fm/* inst
  * midi thru doesn't pick up default inst
    empty scale defaults in Derive, but not in Cmd
  * cmd to resize window to fit tracks
  - implement continuous controller warp
  - make Track.UnsortedEvents and Track.SortedEvents, type or newtype?
  - insert and delete time should use the selection if non-point

  - should tab in raw edit mode go to method?  how to go back then?
  * select track, st3 style select block, track

  track management:
    - resize a bunch of tracks at once
    - collapse tracks down to minimum width?

  - editing for "pattern list" block

OTHER
  - problem with pianoteq: if the same note occurs on two channels, one
    will be dropped.  Report to pianoteq.  I could work around, but it won't
    occur with real multitimbral instruments anyway.

MILESTONES
  0.1
    * scales and keyswitches
    + efficient thru
    + tracklang complete with set of basic calls
    - midi record / integrator
    - dense / efficient control signals
    + lazy signals / lazy deriver
    + derive cache
      - transformer caching
    * symbolic score
    - save undo history
    - solution for audio, plugins, track bouncing, etc.  ardour / reaper?
    - linux port
    - simple csound backend
    - simple lilypond backend?
    - documentation
  1.0
    - display / edit derivations inline
    - print scores
    - mouse oriented signal editing
    - windows port?
  far future
    - render audio
    - include audio inline

----------------------------------------------------------------------

hs plugins:
  How can the plugins link against the core quickly?  They shouldn't link the
  actual code because they are compiled as separate objects.  But to save
  time of reading all those .hi files, I can make a package.  Except it looks
  like it's just the same set of hi files.

  There's a space leak, but maybe it's acceptable?

  - research dynamic libraries: www.well-typed.com/blog/30

  - Can I make relinking faster by making the static core a shared library?
    Use cabal?
  - Either dynamically load local inst definitions and local StaticConfig, or
    auto-generate the link file Local/Instrument.hs.
  - Implement a LangPlugins that uses plugins' eval.  Or is there too much
    space leakage?

  - come up with plan for reloading inst config and static config
    Really what I want to be able to do is recompile the static config
    incrementally, relink it with the main binary *quickly*, and restart the
    app with exactly the same state.  This should be a lightweight operation,
    so it's feasible to edit some code, press play, edit code, and play
    again.  That means a full-on serialize restart is out, because the cache
    could be quite large.

    Of course, you want this stuff in a library so it can be reused across
    projects, so you can put it all in Local/.  Then the song state would
    have a (hopefully minimal) linkage from hs namespaces to the tracklang
    namespaces.

    So with hs-plugins: The static config is considered a plugin.  You edit
    Local/Config.hs, or edit other files in Local/.  It detects the change,
    regenerates Local/Config.hs, recompiles and reloads it.  Then the
    responder is called again with the new static config.

    So I need to be able to re-initialize the responder with a new static
    config.  Actually, the bits I care about are the call map and the cmd
    map.

note input / thru:
  - some way to turn off all midi thru / input
  - keyswitch support in midi thru
  - profile midi->midi thru and implement a fast path if necessary

bugs:
  - #(poke Mispeled, field) fieldp field results in compiler bus error
  - keymap collisions are logged twice
  - Create.rename_project loses the merged tracks
  - bizarre hint importing requirements in Cmd.LanguageEnviron
  * track down ghc rts crashes, assertion failure
    - make a repro case if ghc guys want it
  - run under valgrind every once and a while, just for fun
    - why doesn't valgrind reveal bad memory access from haskell, e.g. poke...
  - hint refuses to compile when a module emits a warning

cleanup:
  - cleanup Ui.Track: event_list -> all_events?
  - Makefile: ghc --make doesn't understand the hsc -> hs link, which leads to
    manual inclusion of $(UI_HS) in the deps
  - remove Util.Log -> Perform.Warning import by translating IDs into strings?
    On the other hand, it's not unreasonable for logs to use other data types
  * having collapsed state in c++ is kind of error-prone, should I go back to
    trying to put it in haskell?
  error prone things:
    - setting some state like project directly through State won't update
      global status.  Maybe I could fix this and also avoid the scattered syncs
      by doing a special state diff after cmds
      sync: state_project, state_project_scale

      The problem is that this moves the set_global_status away from the cmds
      that actually use it, and puts them in a distant function.  However, the
      state itself is already centralized.

      However, I'm worried that checking state on every single respond is going
      to hurt latency even more.

    - creating a block through State.create_block instead of Cmd.create_block
      won't get the current track box color
  - since tracklang lets me apply derivers to tracks and skel makes the
    structure explicit, do I still need the schema?  at least for Cmds, I do
    need a way to look up Cmds based on track focus.  Before doing anything
    rash, think about ways to derive e.g. 工尺譜.

performance:
  Cmd
    * try to figure out why editing is so laggy
      profile to find out were the time is going
    - If a msg aborts or doesn't run any cmds, don't bother to run diff.
      Except that hardly ever happens if I do shortcut thru.
    - cache track cmds for each track, update when the track title or skeleton
      changes
  Derive
    * lazy derivation
    - lazy signals
      - check out 'at' and 'bsearch' occurrances and see if they can use tails
      - There are lots of lookups in the tempo map
    - see if making a version of Derive.local that's non-monadic in the modifier
      has any effect on performance
    - to get arrival beats to work right with the control track, I think I can
      make the 'set' control track call set from (prev, cur) instead of just
      cur.  It will make simultaneious samples, but they should be ok.
    derive cache
      - c_block should only cache if the block has > a certain number of events.
      - implement tracks as generators so they can be cached too
      - I won't rederive cached generators if they have control damage outside
        of the event range.  But there's nothing stopping a generator from
        reading ahead or behind... come up with some kind of solution for this.
      - more efficient version of Derive.concat_derived for events, maybe use
        AppendList
    implement incremental transformer caching, if necessary
      - tempo damage should damage all events after the tempo change point
        Actually, I should treat integration as a incremental transformer.
        Then the tempo damage works because it expands the damaged region
        itself.  Otherwise, any change to tempo will have to re-integrate the
        entire track.
      - once I know what I'm doing with transformers, fix up negative duration
        postproc
    * derivation down to a Either is synchronous with the sync makes for laggy
      UI.  If I can't make derivation lazy, I can at least fill in the
      Performance in the background, perhaps with a SampleVar
    - why does "get" produce so much garbage?
    - at_linear is called a lot by compose, by compose_warp, by d_warp
      can I make this more efficient?

    * maybe split Derive.State into dynamic and static portions?
    - or maybe it's the control deriver creating a huge list of signal
      chunks, which is then all forced at once since merge needs them all.
    * to control lazy evaluation, emit log msg every n sec of derivation
    - Parallelize derivation with strategies.  Can I spark subderivations?
  Perform
    - use a lazy storeable vector for [Score.Event] and [Midi.Message] to save
      memory?  If I make Messages a storable vector, I'd have to hash the wdev
      or something.
  - send style id to c++ instead of all the style elements
  * strictify some basic datatypes with ! and {-# UNPACK #-}:
    Ui.Event, Midi.Message, Perform.Midi.Instrument.Instrument
  - collapsing a track shouldn't trigger a rederive

symbolic score
  - namespacing?  don't worry about it for now, if I need it later it can be
    entirely at the haskell level, I can use the per-song config to import
    namespaces
  - feta's tr symbol looks bad especially when small, is there a better one?
  - find or make a font with jian ti symbols?
  - find or make a font with gong che pu

fltk:
  - some kind of special highlight to indicate the active block
  - rethrow c++ exceptions as FltkError
  - bug: somehow capslock keydown is sent sometimes
  - auto add pitch track when a track title input is expanded crashes with
    assertion error 'title->w() == body->w()'
    solution: text entry is collapsed by track add, remove, or resize
  - factor scroll redrawing into a single class
  - draw arrows in SkeletonDisplay.cc properly
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  draw bugs:
    - redraw after track range damage draws things a pixel too low
    - when scrolling upwards, ruler mark text is not drawn completely
    - doesn't redraw after switching monitors
  Track
    / dividers can have separate color for upper part, for collapsable tracks
  event track
    - events pass style as a uchar ID for consistency and memory savings
    - visual indication when both solo and mute is on
    - adjacent collpsed tracks are merged
    - editing event text should use a text entry widget, that way I get
      a cursor, IME, etc.  A side benefit is that I don't have to derive half
      edited data.  This also solves the problem where the currently edited
      event is hidden.

      This only applies to raw edit mode.  Entering notes and doing
      programmatic changes is still single key.

      Remove the separate raw edit mode.  Return while in edit mode creates an
      event if one doesn't exist and begins editing its text.  Keyboard focus
      is then in the widget until return or tab or a click outside of it.

      The responder has to be able to tell UI to open a text entry, so return
      (State, [UiCommand]), where
        data Edit = Edit {
          edit_block_id :: BlockId
          , edit_tracknum :: TrackNum
          , edit_at :: ScoreTime
          , edit_text :: String
          , edit_insert :: Bool
          , edit_selected :: Bool
          }

      If the edit_insert is True and there is already a text entry open at
      that position, insert the given string at the insertion point rather
      than creating a new one.  This can implement midi->*note insertion.

      Return msg is:
        data Edited = Edited BlockId TrackNum ScoreTime String

      The UI can suppress this if it detects the text hasn't changed.

  control track, render signal
    - support control signals that aren't just 0--1
    / decided against rendering signal as one long line, comment in
      EventTrack.cc
    - render option: solid with color gradient
    - combine multiple signals, e.g. one controls xpos, one controls color

  MoveTile
    - only capture drag on a plain drag with no modifiers

libfltk:
  * fltk 1.3 Fl_Display_Text has alignment bugs, and too slow

logview:
  - haskell and c++ use the same machine readable format
  - LogView should use Util.Fltk
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...
  * collapse duplicate lines

Ui:
  Track
    - benchmark large TrackEvents
    more compact implemnetation than Data.Map?  profile first!
      - priorities: memory efficiency, persistent, merge speed (insert many)
        shallow tree of dense chunks?
        can I take advantage of non-overlap?  [(pos0, data), (pos1, end), ...]
        data Event = Event String StyleId | End | ControlVal Double
      - I think memory efficiency is more important than modification speed
    dense sampled signals
      - efficient storage, preferably as a Signal so no conversion is necessary
      - display dense signals: omit text and trigger lines when zoomed out

plugin host freeze audio
  features:
    3 load synth plugins: ardour3, reaper
    1 programmatically configure them, e.g. load 4 fm8s each with poly of 2
      and loading inst X, or switch them all to inst Y
      - dunno?  can reascript do it?  osc on ardour?
    3 sync play position seq, sync start time
      - I think mmc can do this
      - or maybe the control surface support can do this
    3 start record too
      - control surface support should do this
    2 sync from daw back to seq
      - Can I have the DAW also emit MMC?

  features needed:
    - host synth plugins: programmatically load and configure plugins
    - route midi: associate each plugin with its own midi ports
      It would also be nice to split by midi channel, and route each chan to
      its own plugin.

      On OS X this means creating an IAC port for each synth, presumably
      multiple ones for multiple instances of the synth.  Then I need to
      route each synth to the right midi input and keep them configured.  This
      seems like a bit of a hassle.

      Can I use JACK midi to address a specific synth?  It's one midi stream
      per jack port, so I need an association between insts and jack ports.

    - audio graph config: configure the audio graph, placing synth plugins,
      filter plugins, track record / fader / etc. daw stuff, and outputs
      at various places
    - DAW: Need to sync play position and send current cursor position when
      it changes.
    - track freezer: Record plugin output, sync play position.
  rpc
    - osc, but no good for two way
    - thrift?
  ardour
    - ardour3 supports synth plugins, but doesn't compile on OS X yet
      wait for paul to post his updated build instructions, try again then

  reaper
    it can sync to mmc
    - route multiple plugins to the same bus?  can this be scripted?
      Probably, but to use apple IAC I need to create a bunch of IAC ports and
      make sure they are configured the same way on both sides.
    - can it send cursor position?
      I can poll.

test:
  - write a fltk structure dump so UI tests can be non-interactive
  - tests count number of tests in addition to checks within each test
  - it should be possible to build only certain tests into RunTests
  - use generics or Foldable or something to write a generic StructEqual
  - RunTests.hs: if running >1 init-* tests, run them in sub processes

misc:
  - program to launch logview and seq together
  - ^T on the cmdline prints stuff!?

integrator / midi record:
  - implement

REPL repl language static config
  - haskeline sucks for long lines, add multiple line editing?
    really I'd prefer plan9 style esc then edit
  - could add syntax mangling, but probably better to add it to the mangler
    so it works for everyone
  - pass -fobject-code to avoid trying to recompile files?

save undo history / incremental saving
  I can't just serialize the undo states because then I lose sharing on
  deserialization.  Either explicitly save diffs and checkpoints, or come
  up with a way to serialize and keep sharing.

  explicit diffs:
    Pair diffs with the changed bit.  Then save that chunk on every save.
    Occaisionally write a checkpoint, which is just the whole
    state, and throw away all states before it.  On load, scan to the last
    checkpoint, load it, and apply the subsequent diffs.  On undo, if there are
    no previous states, load the previous checkpoint and apply its diffs.
    - check out cautious-file on hackage

Cmd:
  - Can I give Cmds their own state without putting it in Cmd.State every time?
    For instance, twelve scale may want to know what key you're in.
    Actually, it would be best to have per-module state.
    At worst I can have 'Map.Map String Dynamic'.

    Use existentials:
      data forall a. Cmd = Cmd {
        cmd_func :: a -> CmdT (Status, Cmd)
        , cmd_state = a
      }
    This means that such cmds have to be able to be updated after they are run,
    so the cmd lists have to be kept in responder state.  If I'm going to do
    that, why not have cmds optionally return a continuation and handle state
    that way?

      cmd msg = do
        state <- stuff
        return $ continue $ \msg -> do
          more stuff

    Or if I can put it in the monad:
      cmd msg = do
        state <- stuff
        msg2 <- yield Cmd.Done
        more stuff

    For module level, each module of cmds would have to export a bunch of Cmds
    and the responder retrieves the state and passes in another layer of
    StateT, or directly.  I supposed Dynamic wouldn't be so bad for that.  What
    happens when the module is reloaded?

  ? a module with easy access to all GlobalKeymap cmds for cmdline access
  vi style keymap:
    - movement: hjkl, HJKL to move timestep+1 or skip to
      next inst track, bf to move timestep at block section rank, BF to move to
      top and bottom of block
    - esc and i for edit mode
    - number prefixed cmds?  not for now
  Cmd.Edit
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - trackerlike note entry: entered events are all as long as the block
      (merge will clip them to the next event)
    - map selection through function
    * transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces
    - a legato command that always goes to the next note would still be useful
   - swap tracks keeping skeleton up to date
   * double / halve events under selection
   - stretch events in selection to another length (need two selections?)
  Cmd.Selection
  Cmd.TimeStep
    - snap to event begin/end

  Cmd.NoteTrack
    - record velocity if there is a velocity track
    - chord input, if there are multiple note tracks for this inst

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.Play
    - play loops
    - start playing from top of displayed area
    - start playing from this block' position in the root block

  Undo
    - undo as a tree?  On modification, split the undo tree instead of throwing
      away the future.
    - undo only within selection

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice or delete time or a Meter into a ruler

  Cmd.Freeze
    - details in doc/freeze_track

  Cmd.Save
    - save with a magic number so I can load songs, inst configs, etc.
    - gzip save files

Derive:
  instrument
    - per-project short aliases for inst names so you can fit them in tracks
      easily
    - Implement >inst as setting the null call instead of env.instrument.
      That way the inst has control over the interpretation of e.g. attributes
      and pitch slide (to implement piano style retrigger)

      or maybe, lookup val calls in current inst analogous to current scale
      Maybe I can get rid of the Instrument.inst_control_map if I do the mapping
      in generate_note?

  - implement postproc calls
    - framework for determining scope of a postproc: per inst, per track,
      for pre or post overlaps, etc.
    - Think about how to keep incremental recomputation in the presence of
      postproc.  I suppose they have to declare how much they depend on.
    examples of postprocs:
      * echo
      - retune a note depending on the previous interval (e.g. sloppy pitches
        when playing quickly)
      - negative duration
      - instrument deriver that makes it retrigger on pitch changes, e.g. for
        trills on a piano... I think this has to be score postproc because it
        needs to be pre-scale conversion
        I think I'd rather do this as part of the instrument, though.
      * string emulation:  Every note is assigned a string.  When
        a legato new note is played, it either stops an existing string or takes
        a new one.  The previous note will either ring for a decay if the
        string is unassigned, or reset to its "open" pitch otherwise.  Strings
        can either assume their new pitch instantly (stopped), or gradually
        (bent).
      - overblow emulation: a set of overblow ranges are defined, along with
        possible pitches for each one (fundamental and overblow harmonics).
        When a note moves from one to another, start a new note at the
        destination pitch and bend the decay of the old one to the fundamental
        or closer harmonic from the previous mode.
      - rambat damping emulation: notes ring on by default until they can be
        damped.  Damp at the first opportunity, where opportunity is defined
        as a break with no notes for a certain amount of time.  Can only damp
        two neighboring notes at a time.

  - derivers for sekaran patterns
    - do a code version and a block version
    - block version requires block arguments and variable substitution
    - implement deriver like vla/cello duet?  that's a sekaran, so I need to
      think about this more.
  - Inline subderivation.  E.g.
      inst = >foo | {
      ""
      ""}
    Will run the two events as a subderivation.  Uses:
      - set inst, scale, srate, whatever for a range
      - transform a range, e.g. echo
      - set a signal: e.g. set staccato in a range
      If I implement as just {} = subderive, then I don't have access to the
      events inside.  That means I can only use it to group Environ changes.
      However, if I present it as [(Start, Dur, Deriver)] then I can do a few
      more:
      - tuple
      - This doesn't completely solve the sekaran problem, because I still need
        to put controls on, but it would work for note-only sekaran... wait,
        what about pitch?
      I can't move anything, because of the controls problem.

  - Is there a use for "free equals"?  I had planned to use it to set inst
    within a track but there may be easier ways to do that, i.e. bind inst
    aliases within a track and then put an inst on every note, but it
    complicates caching.  Free equals is also awkward because of next note
    having to skip it.  It's also analogous to assignment, and it's nice to
    exclude that.
  - sustain signal, to control staccato vs. legato
  TrackLang tracklang
    * TrackLang.optional args should be able to pass Nothing if arg is not given
    * Derive.Call.map_asc_events, I need Seq.merge_asc_lists for this.
    - make sure signal derivation doesn't do calls
    * implement call by arg name e.g. "delay time=%xyz"
    * implement control calls
    - implement block level calls in block title
    - other attributes in block title, e.g. "alias=?squiggle? | xyz"?
    * support pitch signals, e.g. "tune-to %*some-sig" but that requires named
      pitch signals
    * implement sub-calls with TVal return type

  - dynamics controls:
    - volume, velocity, and breath map directly to midi vals
    - pres is continuous volume, maps to velocity or breath depending on inst
    - vel is attack volume, maps to velocity or breath but is only sampled at
      the beginning of the note
  - to cut the middle out of a pattern: a cut signal that disabled derivation
    when it's 1?

  - combine ornaments, like "hold 1s | tr" to hold the first note for 1 score
    time before starting the trill.  I think this could work by warping tr

  - ScoreTime and RealTime literals: 1s, 1r
    If I had score and real time literals, I could merge abs and score trills.
    Then I need to support either typed controls, or a notation for "cont
    x interpreted as score time".

    trill 1 4s -> Signal (Just (RealTime 4), Control)
    trill 1 s%cont -> Signal (Nothing :: Maybe RealTime, Control)

    data ControlType = Scalar ScalarType Signal.Control
        | Pitch PitchType PitchSignal.PitchSignal
    data ScalarType = TReal | TScore | TNum
    data PitchType = TAbsolutePitch | TRelativePitch
  - time interval literal, so I can specify e.g. trill speed in terms of beats
    This means Derive has to have access to the rulers.

  deriver customization
    * bind symbol names, e.g. bind specific-trill to local 'tr' symbol
    - set dynamic env vals, especially if a family of derivers use the same
      argument names for analogous behaviour, e.g. 'tr-speed'
    - make it easy to add haskell derivers, tracklang must remain simple
    - derivers call other derivers, which can be rebound

  * arg processing: arg defaults taken automatically from the env, if
    prefixed with call name: "call-arg"
    - one problem with this is rebound symbols, do I want to force new names?
      I think I do, because otherwise it exposes the underlying symbol.
  - test Calls that return overlapping events
  - block-level calls
  - x = _ will unset x

  - come up with a syntax for Ui.Event preproc calls
    >inst1 | echo < preproc1 < preproc2
  - also I can have a post-parse "macro" preproc pass, this is more suited
    for prepending a call
  - re-implement directives: derive_notes returns (EventDeriver, [Event])
    wait until I have a call that wants to use it (suppress event?)

  - When looking for the next note on, I should skip notes which are just
    'statements' that produce no notes.  That way a var set won't interrupt
    the pitch sig.
  - some kind of notation for replacing the track interpreter, e.g.
    TrackId -> EventDeriver.
    This could be used to implement macros, and also preproc.

  val calls:
    - val calls to get the next/prev TimeStep

  note calls:
    * Implement tick as a call:
      Need to get next and prev Ui.Event, get pitch from pitch sig
      to_local (between (to_gloal prev_pos) (to_gloal next_pos)
      d_absolute_at = d_at . to_local

    - Implement suppress as call:
      This is more tricky, how can a call modify neighbors?  Especially
      preceding ones.  This seems to mean I still need postproc calls:
      DeriveT -> DeriveT.  Internally it evaluates the deriver, processes
      the Score.Events and wraps it in another deriver (the seq equivalent of
      cue).  After that most behaviours are ineffective, but them's the
      breaks I guess.  It seems nicer if I could pass something to the block
      to cause it to skip the downbeat, but how can I do this in a non-ad-hoc
      way?  If I can insert a per-project block deriver I can add it as an arg.

    - Implement tuplet:
      't *n1 *n2 *n3 |' runs deriver three times with three different
      pitches.

    - Implement clip-call:
      Undo the call stretching, this should be efficient because of stretch
      combining:

      d_stretch (recip (dur/block_dur)) $ d_clip dur $ deriver
      "unstretch | sub"

      A non-block call (including notes) will have a block_dur == dur.  I can
      also imagine a version without the clip.  'unstretch' is a crummy name
      though.  'restore'?  'abs-dur'?

    / Implement sekar derivation.  The tricky thing here is I want n notes, not
      a call with n args.  Use the Generator "consumed" return val for this.
        Seleh can pair derivers:
          seq [stretch 0.5 (seq d1 d2), stretch 0.5 (seq d1 d2)]
          (d1 @> d2) ~ 0.5 @> (d1 @> d2) ~ 0.5

        Without logical-stop I can't sequence Derivers.

      It would be nice to do a piece on sekar patterns where the form itself is
      in the same pattern, for a kind of fractal structure.  How to have
      a pattern derive patterns?

      - pass the calls as block args
      - put the null deriver in the env
      - more general than the above: dynamically scoped call map and syntax to
        modify it
      - env var that prepends or appends calls to notes.  actually, this is
        better done as a preproc.

      Maybe I could unify the env and call map and also a general variable
      facility: var = val -- 'var' is a symbol, so assign to the call map,
      'val' is a symbol so look up in call map and env

      call var var -- look up 'var's

      This way I need a VFunction type and variable lookup.

    * Implement trill
      * absolute tempo version that adds new cycles when stretched
      * version with n cycles that stretches with tempo
      - hybrid where the initial part stretches, final part is absolute

  PitchTrack pitch
    * Named pitch tracks, so derivers (e.g. tuned just scale) can take pitch
      track args.  The way this could work is that the state_pitch becomes
      'Map SignalName PitchSignal' and the "" signal is taken by the note
      deriver during convert.  Track syntax:
      "*scale" -> ("", ScaleId scale)
      "*scale %psig -> ("psig", ScaleId scale)

  ControlTrack control
    interpolators
      - sine
      - constant slope, exp slope (i.e. slope until next control event)
      - continuous tempo warping for signals
        tempo: "2" -> "1", "2", cont: "2" -> "i, 1", should emit a bent line
  Derive.Scale scale scales
    - implement pengumbang pengisep
    - enharmonics for Twelve
    - just intonation tuned to a pitch signal
    - looks like fun: http://en.wikipedia.org/wiki/Bohlen-Pierce_scale
    - retune a note depending on the previous interval (e.g. sloppy pitches
      when playing quickly)
      I think this has to be postproc.
    - Ratio based notation where the ratios are from the previous pitch.
      Should be able to do this with val calls.
    - octatonic
    - parser for scala .scl files

   - Control track management?  It should be possible to have a note or a bunch
     of note tracks with a bunch of control tracks and control the clutter.
     Ideas: collapse has limited usefulness when there are too many, even with
     color coding.  I could do this with logview: selecting a note track logs
     a list of its control tracks and whether they are hidden or not.  Clicking
     on one in logview will emit a cmd that will hide or show that track.
     Or I could use a UI for adding new controls too: click a track, then a cmd
     'add_control "vel"', this will unhide and focus the control if it exists,
     or create a new one and link it with the skeleton if it doesn't.  ^T is
     intended to create new note tracks, and they're only linked to tempo
     initially.

     This implies a slightly more generic and acme-ish system for logview:
     anything enclosed in {}s can be clicked and will be sent verbatim, even if
     it's in the catch line:

     -- title (tracknum): inst_name, allocation, [control tracks]
     Inst (track 1): fm8/inst1, fm8:0,1,2, [vel {hide 2}, pedal {show 3}]

  * block derivation memoization / caching
  * set instrument within note track
  - set controller within control track?
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - reflect derivation back into a block
  - merge block level changes with derivation

Perform:
  - instruments can have a native scale, so playing that scale won't involve
    pitch bends
  Instrument
    - some kind of organized way to manage instruments and instrument config
    - some basic midi instrument defs for generic midi (dev, patch)
  Signal
    - lazy implementation
  Midi:
    - see if synths support the set pitchbend range controller
    - Convert certain attrs to controls for cc 'keyswitches'.
    / inst has a notion of polyphony so I can avoid overloading a channel, say
      if I limit it to 2 voices

      The problem is 'allot' doesn't know which channels are going to have
      a lot of notes so it can allot wrong.  For instance, a large chord might
      take up all the polyphony of the first addrs, and then the Nothing addr
      gets the bendy notes.  I think I would have to look into the future and
      make a decision based on the notes that will be overlapping with this
      one.

      The problem comes up with chord oriented instruments that have a few bent
      notes.  However, I'm not totally sure this will be a problem, and it
      would be simpler to simply make two instruments, one for non-bendy notes
      and the other with multiplexing for bendy ones.  Yes, this is putting
      some busywork on the user which should be left to the performer, but
      since the solution is fairly complicated I think I'll leave it be for
      now.

Instrument DB:
  - search lang supports quotes
  - search lang supports - to exclude a term
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi:
  bandwidth
    - keep stats
    - display widget

misc ideas:
  - Staff notation represents chords well, but tracks don't.  Think of a more
    compact notation.
  - Staff notation output via lilypond?  This can be implemented as another
    kind of backend.  I think events would need metadata so I have a place to
    put formatting info.  Maybe tracks and blocks need it too so I can express
    staff associations.
  - if derivation needs event IDs, maybe I can use the value-supply package
  - safecopy package does version controlled serialization
  - think about yi's approach to keybindings as a parser and keybinding state
  - also investigate yi's approach to configuration

misc ghc fixes:
  - .prof output should line up better
  - hp2ps should use constant colors for biography

research:
  - spline curve interpolator: evoral/Curve.cpp, www.korf.co.uk/spline.pdf
  - check out Ben Johnston's just notation

future:
  - I need to sync with a DAW but don't want to implement rewire.
    Which DAWs support jack?  ardour, reaper?, ...?

    Can I use ardour as vst host, DAW, and track freezer?  It has OSC support
    and I could add more.  Downside: no windows.

    - vst host: Need to programmatically load plugins, configure plugins, route
      audio.
    - DAW: Need to sync play position.
    - track freezer: Record plugin output, sync play position.

  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
