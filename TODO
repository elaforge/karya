- program to launch logview and seq together
- ^T on the cmdline prints stuff!?

- playback cursor seems to reset to the top after a play through
- empty scale defaults in Derive, but not in Cmd

- piece with fancy pitch: doira + synth
  1 1^ - 1^ 3 7# - - 1 1^ 1 32 7#7 1 1^ - 1^ 3 7# 1^
    3 3333 2 2 2b 2b
- signal deriver doesn't record track in stack

- try record punning

- maybe I can get rid of schema?

- skip derivation on a block if it has no absolute pitch tracks?
- derive multiple blocks with parMap

CURRENT
  - methods no longer hardcoded, e.g. Map MethodId MethodInterpolator
  + TrackLang
  - document / enforce rules for CallId, Control, etc?

  - initial control env has vel = constant 1

  - stack: bid/tid/* should highlight the entire track
  - crashing bug adding new track to skeleton
  * just editing a note shouldn't change its dur!
  * note track can pipe through derivers: '>fm8/bass | d0 arg0 arg1 | d1'
  - test relative pitch slide!
  - more symbolic calls, e.g. -/_\\/ and -//
  - should tab in raw edit mode go to method?  how to go back then?
  - select track, st3 style select block, track
  - symbolic score, as in doc/custom_symbols

  - demo piece: show nested tempos with "bouncing ball", expressive pitch
    track, non-trivial repl transformation (pitch tweak after big jump?)
    transcribe rejang w/ reyong patterns
  - cut + paste didn't work with a point paste

  - skel_display status can be two chars: Sm is solo+mute

  bugs:
    - Create.rename_project loses the merged tracks

  track management:
    - resize a bunch of tracks at once
    - collapse tracks down to minimum width?

  - editing for "pattern list" block
  - double click call to jump to its block?


MILESTONES
  0.1
    + scales and keyswitches
    + efficient thru
    - dense / efficient control signals
    - lazy signals
    - memoize deriver output, to avoid unnecessary rederivation
    - midi record / integrator
    - save undo history
    - linux and windows ports
  future
    - display / edit derivations inline
    - print scores
    - mouse oriented signal editing
    - freeze tracks / audio memoization: doc/freeze_track
    - vst host
    - sync with audio editor: jack or rewire
    - non-midi instruments

  far future
    - render audio
    - include audio inline

- make sure pitch terminology is consistent:
  KeyNumber = scale independent note, Note = note in scale,
  Pitch = freq easily mapped to and from nn, same as NoteNumber,
  NoteNumber = Midi.Key + decimal

----

- optimization: if a msg aborts or doesn't run any cmds, don't bother to run
diff.  except that hardly ever happens if I do shortcut thru

- per-project short aliases for inst names so you can fit them in tracks easily

display signal:
  cmd makes a change to a controller track
  diff (and cmd) generate TrackEvents update
  sync processes TrackEvents and TrackAllEvents and merges it with samples

  so where does sync get the samples?  I can pass it [(TrackId, Samples)]
  that comes from (Track, Signal), which comes from a partial derivation
  most derivers should be able to get that from the Skeleton

****
- switch to darcs hashed repo format
  darcs optimize --upgrade
  darcs optimize --pristine

note input / thru:
  - keyswitch support in midi thru
  - profile midi->midi thru and implement a fast path if necessary

bugs:
  - can share pitches doesn't consider a whole step transposition unshareable
  - is kbd entry letting keys like 1 fall through?
  - Edit.cmd_delete_time is still a little funky, an event with only 2 time
    steps is deleted, >2 is shortened.
  - keymap collisions are logged twice
  - Create.rename_project loses the merged tracks
  - bring block windows to the front after a load

  - tracks with different tempos play correctly, but playback follows tempo
  - unparsed notes are played instead of dropped, it's because the pitch is
    dropped but not the note
  - bizarre hint importing requirements in Cmd.LanguageEnviron
  + track down ghc rts crashes
    add -DS flag
    crash is when evacuating pinned memory, is it a foreign ptr?
    - run under valgrind
    - why doesn't valgrind reveal bad memory access from haskell, e.g. poke...

  - fltk: mute (i.e. change brightness) makes text get drawn twice
  - fltk: moving a track title while it's expanded doesn't work
  - hint refuses to compile when Cmd.NoteEntry emits a warning

cleanup:
  - State.structure only used by Clip_test
  - Makefile: ghc --make doesn't understand the hsc -> hs link, which leads to
    manual inclusion of $(UI_HS) in the deps
  - remove Util.Log -> Perform.Warning import by translating IDs into strings?
    On the other hand, it's not unreasonable for logs to use other data types
  - having collapsed state in c++ is kind of error-prone, should I go back to
    trying to put it in haskell?
  - hspp doesn't catch calls to Derive.throw and Derive.warn within Derive
  error prone things:
    - setting some state like project directly through State won't update
      global status.  Maybe I could fix this and also avoid the scattered syncs
      by doing a special state diff after cmds
      sync: state_project, state_project_scale
    - creating a block through State.create_block instead of Cmd.create_block
      won't get the current track box color

performance:
  speed and memory profiling:
    - respond to incoming notes
    - diff and modify UI
    - derive a large score
  - pause before starting background derive to avoid thrashing during edits?
  - use a lazy storeable vector for [Score.Event] and [Midi.Message] to save
    memory?
  random little hangs are annoying.  figure out what's going on.  GC?
    - timer can summarize one responder loop cycle?
    - get diff results is really slow
    from yi bug:
      * GHC triggers a major GC everytime Yi becomes active whenever user
      resumes typing
      * Major GC takes increasingly long time as number of object grows (as
      expected)
      So, we have to iron out all memory leaks.

  - send style id to c++ instead of all the style elements
  - strictify some basic datatypes with ! and {-# UNPACK #-}:
    Ui.Event, Midi.Message, Perform.Midi.Instrument.Instrument
  - collapsing a track shouldn't trigger a rederive
  caching:
    - in c++, cache marks and events from callback
    - cache track cmds for each track, update when the track title or skeleton
      changes
    - deriver caching, see doc/derive_cache

fltk:
  - draw arrows in SkeletonDisplay.cc properly
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  - bug: doesn't redraw after switching monitors
  - SeqInputs should display the right side of the text if they're too small
  UI Msgs
  Track
    / dividers can have separate color for upper part, for collapsable tracks
  event track
    - "currently edited" event shouldn't be hidden by previous ones
  Ruler
  MoveTile
    - only capture drag on a plain drag with no modifiers

libfltk:
  + try cocoa fltk patch
    - how to compile?
  + window position not restored on load
    - had to patch fltk, test Fl_cocoa.mm, make str for Fl_mac.cxx

logging:
  - trying to derive relative blocks generates a lot of log spam, can I avoid
    that somehow?
  - commands like Selection or MIDI thru generate too much log spam, maybe
    filter logs for those?
  - compile_to_signals spams too much when there is an error

logview:
  - haskell and c++ use the same machine readable format
  - LogView should use Util.Fltk
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...
  - collapse duplicate lines

control
  scale markers on pitch signals
    - haskell will have to send [(String, Val)].  Either cache it or avoid
      cache problems by always passing it but keep as a a ForeignPtr in haskell.
    - fltk implementation
  - more render options, e.g. solid with color gradient
  dense sampled signals
    - efficient storage, preferably as a Signal so no conversion is necessary
    - display dense signals: omit text and trigger lines when zoomed out

Ui:
  - some kind of special highlight to indicate the active block
  - rethrow c++ exceptions as FltkError
  Track
    - events pass style as a uchar ID for consistency and memory savings
    - benchmark large TrackEvents
    more compact implemnetation than Data.Map?  profile first!
      - priorities: memory efficiency, persistent, merge speed (insert many)
        shallow tree of dense chunks?
        can I take advantage of non-overlap?  [(pos0, data), (pos1, end), ...]
        data Event = Event String StyleId | End | ControlVal Double
      - I think memory efficiency is more important than modification speed
    - modify IntMap for Word64s, add toDescList
      - send patch to libraries@haskell.org
    - visual indication when both solo and mute is on
    - adjacent collpsed tracks are merged

skeleton:
  - parse skeleton in LanguageCmds

test:
  - tests count number of tests in addition to checks within each test
  - it should be possible to build only certain tests into RunTests

integrator / midi record:
  - implement

Cmd:
  ? a module with easy access to all GlobalKeymap cmds for cmdline access
  - cmd to give a view focus and bring it to the front
  - Cmd_test
  vi style keymap:
    - movement: hjkl, HJKL to move timestep+1 or skip to
      next inst track, bf to move timestep at block section rank, BF to move to
      top and bottom of block
    - esc and i for edit mode
    - number prefixed cmds?  not for now
  * selection scrolling should scroll so the next 2 timesteps are visible
  Keymap
  Cmd.Edit
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - trackerlike note entry: entered events are all as long as the block
      (merge will clip them to the next event)
    - map selection through function
    - transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces
    - a legato command that always goes to the next note would still be useful
   - swap tracks keeping skeleton up to date
   - double / halve events under selection
   - stretch events in selection to another length (need two selections?)
  Cmd.Selection
  Cmd.TimeStep
    - snap to event begin/end

  Cmd.NoteTrack
    - record velocity if there is a velocity track
    - chord input, if there are multiple note tracks for this inst

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.Play
    - warn about unallocated instruments (Convert.verify)
    * make sure the whole stack is lazy
    - play loops
    smarter background derivation
      - wait a second before deriving
      - don't derive while a key or mouse button is down
    - start playing from top of displayed area
    - start playing from TimeStep before insert point

  Undo
    - figure out how to checkpoint just state diffs
    - add undo history to on-disk format

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice or delete time or a Meter into a ruler

  Cmd.Freeze
    - details in doc/freeze_track

Derive:
  - note track can pipe through derivers: '<d0 arg0 arg1 <d1 <fm8/bass'
  - echo deriver, 'echo 2 <fm8/bass', signals: echo_feedback, echo_time
  - derivers for seleh patterns
    - do a code version and a block version
    - block version requires block arguments and variable substitution
  TrackLang
    - lazy version of Derive.Call.map_events
    - make sure signal derivation doesn't do calls
    * implement num -> signal coercion
    - implement mandatory signal args
    * implement _ dummy arg
    - implement call by arg name e.g. "delay time=%xyz"
    - implement control calls
    - implement block level calls in block title
    - other attributes in block title, e.g. "alias=?squiggle? | xyz"?
    - support pitch signals, e.g. "tune-to %*some-sig" but that requires named
      pitch signals
  PitchTrack pitch
  NoteTrack note
    - non-note commands: set random seed, ...
      do I want to set cc things from note or require a control track?
      pedals, fingered portamento, ....  I think not because it will screw up
      note initialization.  Also e.g. pedal will naturally want to apply to
      a bunch of tracks.  With a good way to collapse or hide controller
      tracks it should be ok to have its own track.
      I do want +attr -> cc for cc keyswitches.  Technically attrs also kinda
      overlap with controllers and need special support for initialization.
      They get that by being treated separate instruments.
    - leading ; means the command is evaluated for its effect but emits no note

  ControlTrack control
    - configurable interpolators instead of a hardcoded ADT
      - sine
      - constant slope, exp slope (i.e. slope until next control event)
  scales
    - implement pengumbang pengisep
    - enharmonics for Twelve
    - just intonation
    - looks like fun: http://en.wikipedia.org/wiki/Bohlen-Pierce_scale

   - Control track management?  It should be possible to have a note or a bunch
     of note tracks with a bunch of control tracks and control the clutter.
     Ideas: collapse has limited usefulness when there are too many, even with
     color coding.  I could do this with logview: selecting a note track logs
     a list of its control tracks and whether they are hidden or not.  Clicking
     on one in logview will emit a cmd that will hide or show that track.
     Or I could use a UI for adding new controls too: click a track, then a cmd
     'add_control "vel"', this will unhide and focus the control if it exists,
     or create a new one and link it with the skeleton if it doesn't.  ^T is
     intended to create new note tracks, and they're only linked to tempo
     initially.

     This implies a slightly more generic and acme-ish system for logview:
     anything enclosed in {}s can be clicked and will be sent verbatim, even if
     it's in the catch line:

     -- title (tracknum): inst_name, allocation, [control tracks]
     Inst (track 1): fm8/inst1, fm8:0,1,2, [vel {hide 2}, pedal {show 3}]

  - suspend automatic derivation while there's a note down?  use Cmd.Mod
    instead of the note_id map since it should be more reliable.
  - block derivation memoization / caching
  - set instrument within note track, controller within control track
  - separate instrument track, as a kind of controller track
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - display derived blocks
  - 3 way merge for derived blocks

Perform:
  Instrument
    - some kind of organized way to manage instruments and instrument config
    - some basic midi instrument defs for generic midi (dev, patch)

  Signal
    - lazy implementation
    - ensure that controllers are warped continuously by tempo

Instrument DB:
  - search lang supports quotes
  - search lang supports - to exclude a term
  - original file goes in a tag, not the text
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - now that PatchTemplate is gone, maybe I can use a simpler storage format
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi:
  bandwidth
    - keep stats
    - display widget

misc ideas:
  - more complicated track names: "< legato < synth/inst" to pipe inst output
    through legato deriver
  - use "<" for tracks that generate data, ">" for ones that accept it, e.g.
    to display and merge a derived version
  - should be a documented extensible way to add new track types without
    modifying core ADTs

  - chord input... think about some kind of compact representation
  - if derivation needs event IDs, maybe I can use the value-supply package
  - safecopy package does version controlled serialization

  - think about yi's approach to keybindings as a parser and keybinding state
  - also investigate yi's approach to configuration

research:
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - learn about hs gtk for reference

future:
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
