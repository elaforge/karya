misc
  - rumor has it os x leopard wants .app bundles instead of Rez, so build those

fltk
  - optimize: implement scroll redraw optimization
  - optimize: cache marks and events from callback
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  UI Msgs
    - can I capture os x two-finger drag events?
      yes, they're reported as FL_MOUSEWHEEL, so I should scroll on mousewheel
  Track
    / dividers can have separate color for upper part, for collapsable tracks
    - tracks have their own status lines, to report things like mute
  event track
    - "currently edited" event shouldn't be hidden by previous ones
    - minimal redraw doesn't display hidden events quite right
  Ruler
    - mark text tries to wrap if there isn't enough room
  MoveTile
    - only capture drag on a plain drag with no modifiers

logging
  - haskell and c++ use the same machine readable format
  - Util.Misc isn't well named, call it Util.SrcPos or something
  - rename LogViewer -> LogView just to reduce confusion
  - LogView should use Util.Fltk

Ui
  - rethrow c++ exceptions as FltkError
  * rename Interface -> Ui, ui -> fltk
  * UiMsg: use Key data type instead of Char for e.g. backspace
  * use main thread for ui
  * set block config
  * set block view config
  * BlockView.set_track_width, BlockView.get_track_width
  * track_at
  * Event
  * work old tests from TestUi into BlockC_test
  * always having to specify the color of a Selection is annoying, make
    CSelection automatically get it from block_selection_colors
  - set_track_status
  - if the app thread dies, kill the rest of the threads
  Diff
    * ErrorT
    * track width, track update (need diff hints?)
  Track
    - benchmark large TrackEvents
    - modify IntMap for Word64s, add toDescList
      - send patch to libraries@haskell.org

Cmd
  - instrument initialization
  - cmd to give a view focus and bring it to the front
  - Cmd_test
  - background derivation and caching
  keymap
    - check for key assignment collisions
  Cmd.Edit
    - change note lengths
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - change length of existing event
    - map selection through function
    - transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces

  Cmd.Selection
    - drag snap to ruler, event beginning/end, ...
    - extend selection with shift-arrow
    - normal selection move should go past bottom of screen / last note
    _ UI and fltk support for editing event text

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.View
    - ViewBlock abstraction: collapse/expand tracks, mute tracks

  Cmd.Play
    - warn about unallocated instruments (Convert.verify)
    - make sure the whole stack is lazy
    - play loops
    - background derivation

  Cmd.Record
    - come up with a plan for midi recording
    - implement simple midi underiver aka integrator

  Cmd.Save
    - Data.Binary loading a tuple instead of a val sucks CPU forever
  Undo
    - implement undo tree and undo/redo cmds
    - figure out how to checkpoint just state diffs
    - add undo history to on-disk format

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice time or a Meter into a ruler

Derive
  derivers
    * control
    * tempo
      - multiple tempos per block
    - continuous pitch control
    - alternate scales
    - defaulting parameters for control and note tracks
    - subblock derivation
  - display derived blocks
  - 3 way merge for derived blocks

Perform
  Player
    _ flush midi output when I get a Stop
      flush is complicated and it's easier to just live with n seconds of extra
      sound
      - complain to portmidi list?
  Midi
    - eliminate duplicate controller msgs
    - microtuning, implement cents to pb_offset
    - pitch signal rendering

  Instrument
    - some kind of organized way to manage instruments and instrument config
    * backend-independent instrument def
    - some basic midi instrument defs for generic midi (dev, patch)
    - defs for z1 and vl1

  Signal
    * implement Signal.equal
    - signal transformation derivers: +, *, /, min, max, ...
    - after implementing GUI drawing and transformation, reduce the
      proliferation of signal types
    - ensure that controllers are warped continuously by tempo

Instrument DB
  - search lang supports quotes
  - search lang supports - to exclude a term
  - original file goes in a tag, not the text
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - now that PatchTemplate is gone, maybe I can use a simpler storage format
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi
  - midi thru: MVar (Port -> Message -> [(Port, Message)])
  - scheduler for out of order writes + thru?  how about I always write in
    order and don't allow timestamps on thru?
    no, I still need the scheduler, phooey.
    write WriteStream *OpenMergedOutput(WriteStream *stm, ...)
  bandwidth
    - keep stats
    - display widget

Osc
  - does reaktor support timestamps?

research
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - draw antialiased lines and curves on os x
  - learn about hs gtk for reference

future
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
