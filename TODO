LEGEND
  - todo; + in progress; * done; / obsolete, do not want, or can't repro
  ? open question; . note or observation

UNSORTED
  - can I use the fancy Status trick to implement the symbol composer?
  * Top of the tracks are a bit too clipped off, the selection is barely
    visible.
  * For a short-term control track, It should be possible to change the
    control track with a %new-control event.  Pre interpretation, scan for
    those events and split the track accordingly.
  Format2
    . Rethink how indent breaking happens.
      Maybe indent should be a flag on SoftBreak
      If pre is null, then maybe I should indent to the next level, e.g.
      [(0, ("", "a")), (2, ("", "b"))]
  * Select block call puts select on ruler, but play monitor does not then
    remove it.
  * explicit track focus, to avoid putting focus back on every time
  * why does lilypond think this is a bad barcheck?
    save/bloom/ly/mvt2.ly:113:35: warning: barcheck failed at: 3/4
    \time 6/4 \key d \minor \clef bass
                                       R2. R2. | % 1
    . Full measure rests must be a full bar, so it must be R1.
  * Add a way to mute an instrument.  I can set the allocation to [], but then
    I lose the old allocation, and it constantly warns about it.  I could also
    add solo.
  * move tracks messes up the skeleton:
    () (1 2) (2 3) (3 4) (5 6), move 0 to 5
  * drawing bug: long track render sample doesn't draw near the bottom
    Samples should be at [0, 29, 31], but are [0, 20.71, 22.14]
  * when I switched with save_state_as, it emptied the old state's views
  * solo still gets another track with a 'bounce' call, save/bug-bounce-solo
  * shift-play from a super-block drops the first note of the sub-block
  * up and down arrows in text entry should go to front and back
  - add edit and windows menu to all apps
    There must be special OS X support for these
    Apparently not?  iTerms is defined in English.lproj/MainMenu.xib
    https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/WinPanel/Tasks/UsingWindowsMenu.html
    But it doesn't say how to add the Window menu.
  - keys to move focus?
  * repl macro: [@b0, @b1] didn't work
  * Refactor.order_block makes a block with a mysteriously black ruler
  * track status is lost when a track is added or removed
    The problem is that set skeleton resets the display, but doesn't reset the
    status, they have to be set separately with Block::set_status.
    So add/remove track will set skeleton, but not send Update.BlockTrack
    . Skel display could track insert and remove by bumping the Track by one.
    . It also needs to preserve across a set_skeleton.
    . Or, if I can bundle status and skeleton together.
      The problem is that skeleton is the whole thing, status is per-track.
      But I could merge them, break status out of DisplayTrack and make
      status changes emit a BlockSkeleton, which has all statuses
    . If I always set status via BlockSkeleton, e.g. emit BlockSkeleton on
      status-only change, and omit it from the dtrack check, then I can
      get rid of SkeletonDisplay::set_status.  Is it worth it?
    * have SkeletonDisplay::set_config use the statuses
    * remove insert_track remove_track
    - consider removing set_status

  * Slurs shouldn't make a note overlap the same note.
    Or at least, on the piano, slurs on chords shouldn't overlap at all.
    Also, slurs can give a slight dynamic boost to the beginning of the
    phrase.
  * postproc to make sure the same pitches don't overlap
  * %sustain -> %sus, sustain-abs -> sus-abs
  / ly-( should make a note if a generator, rather than looking for subs.
  * rename *_lang stuff in Config to repl
  * Cmd.Lang* should go too
  * move meters to Cmd.Meters and don't hardcode measures/section
  * Tags.internal should be for really internal things, add Tags.builtin for
    basic ones.
  - update shakefile to use new system calls and logging levels
  - shakefile should use typesafe oracle calls, is there newtype based
    oracle utils yet?
  convert to Text:
    * UiMsg.UpdateInput
    - TimeStep.show_time_step
    * Lilypond.to_lily
    - Pretty.pretty
      For this I need to extend Util.Format to be a simplified prettyprinter:
      - monoidal interface, not monadic
      - write text, set indent for expression, insert soft break
    - Derive.throw
    * track titles
    * turn txt (show ...) into showt
    * Cmd.ControlTrack.Event
    * instance Typecheck Text instead of String
      It means e.g. TimeStep.parse_time_step should take Text, which means
      Util.Parse should switch too.
    * BaseTypes.Symbol
    * Score.Control
    - Ui.Id
    * ModifyEvents.text
  - %sus-abs=-.x is not quite right for detached, because it should scale
    a bit for shorter notes.  E.g. it's absolute but scales down to 0 below
    a certain threshold.
  - now that I have tevents_around, can I get rid of slice_around and the
    require_previous hack?
  bloom
    * block b10 is messed up near the end
    * b13 silent
  - I can have regression tests that assert a score still derives the same way.
  calls:
    - Sometimes tick makes more sense as at attribute of the previous note, or
      perhaps a freestanding ornament, since it can happen or not on a repeat.
    - 'u' and 'd' have a problem with long notes because pitches can only be
      transposed so far.
      . If I knew how far a pitch could be transposed, I could clip the end
        time to the bottom pitch.  But I don't.  Maybe pitches should be
        transposable infinitely far, but emit a -1 NN signal when they cross
        the boundary?  Or would this hurt error reporting?
  vsl
    - dyn# should be 'dyn . crescdim . rep#'
      cre# should be just 'cresc . rep#'
    - can all perf.rep be turned into rep, or is there non-perf rep?
    - make sure perf_upbeat_repetitions are consistent
    - make sure grace vs. grace.updown is correct
    attribute groups:
      I should be able to pick a default and remove that one:
        legato/marcato/staccato, na/ha/fa/sa, vib/nv/progr
        * for grace notes, fast should be default
        * strip norm
      . bass clarinet has nv without vib
    - should be able to select the most appropriate sec# dyn given
      +cresc or +dim on a note.
    - Figure out how to map continuous controls, and crossfade.

  - Can I bind symbol names with =, e.g. 'arp = arp-manual .3 .2 .1'
    That's actually two things, one is binding the symbol, the other is
    partially applying args.  The latter overlaps with setting default in
    the env, but is more concise.
  - network midi doesn't seem to handle abort?
    playing the second time doesn't happen
  - StepPlay gets messed up by tuplets and the like.  Maybe it should step
    along the performance (with some eta to account for randomization)
    instead of the score.
  - maybe new control tracks should start with line render?

  - can I cache long blocks by slicing them if they're >n?
  - I have a feeling like FM8 doesn't obey ResetAllControls
    Maybe I should extend Midi.Interface.note_tracker to keep track of
    used CCs to issue resets for them.  Some reset to 1, e.g. cc2 and cc7,
    the rest reset to 0.
    But filtering the midi shows dyn controls mixed into both channels.
  - the signal doesn't update if I change the default environ assignment on
    another track
  * doesn't seem to save track widths, I keep making it narrow but reload it's
    still wide.

  / parsing "1r" instead of "1s" gives a "unexpected eof" error msg, it should
    say 'r' was an unknown suffix
    Can't get attoparsec to consistently report an error.  Kind of hard when
    it always backtracks.
    - Need to add <||> to attoparsec.
  - It seems confusing that in val edit the note track doesn't need cmd-x but
    the control track does.
    Maybe I should get rid of the optional cmd- thing?
  - Pretty on a lot of events causes a stack overflow
    Need a reproduction.
    I should extend Util.Format so I can use it for Util.Pretty.
  - There's a lot of duplication between State.TrackEvents, Call.TrackInfo,
    and Derive.CallInfo.  Can I factor out the common bits?
  - if I added the cmd name before running the cmd, I could put it in the
    error msg when an exception is caught.
  - There are still some cmds without names, who are they?
    Do some logging to track them down.
  - key not applied in inner blocks, local play should take the root play's
    env as a starting point
  - randomize any control by having the 'set' call look for the -rnd control
  some way to get symbol feedback instantly to make it easier to compose them
    - But it calls SymbolC and I ran into a problem where linux ghci can't
      link FFI-using functions.  Ask on glasgow-haskell-users.
  - test sending mtc to reapaer
    also test some mmc commands.  How does reaper support control surfaces?
  - Playback should have multiple lines when a block is derived multiple
    times. Have a set of playback selnums?

MILESTONES
  0.1
    * support diatonics, enharmonics, and symbolic transposition for church
      modes, modes of limited transposition, and exotic scales
      (e.g. octatonic a-h)
    * record chords
    + integration
    - record continuum
    + Just scales, and other ratio-oriented scales that use letters and
      accidentals
    - complete Idiom.Wind, experiment with the Idiom postprocs
    + bring back negative duration / arrival beats
      No longer sure how to do this.
    * scales and keyswitches
    + efficient thru
    * tracklang complete with set of basic calls
    * better REPL situation
    - midi record
    - dense / efficient control signals
    * derive cache
    * symbolic score
    + save undo history / incremental save - more extensive testing
    - solution for audio, plugins, track bouncing, etc.  ardour / reaper?
    + jack support on linux
    - simple csound backend
    * lilypond backend: good enough to render viola-sonata
    + documentation
  1.0
    - stable api
    - solution for local data / code
  future
    - non-realtime synthesizer: doc/dev_notes/synthesizer
    - horizontal layout
    - mouse oriented signal editing
    - Unify environ, controls, and pitch signals by making signals of
      arbitrary type.
    - print scores
    - include audio inline, so I can write signal transforms like event
      transforms

----------------------------------------------------------------------

documentation
  + doc/derivation.md
  * integrate doc/tracklang into derivation.md
  - split up derivation.md into separate files
  * doc/performance.md, and reorganize derivation under it, and integrate with
    doc/score.md
  - doc/ui.md
  - doc/cmd.md
  call doc:
    - I could go look through arg docs for controls and list all the controls
      that have someone listening to them in a certain scope.
    - linkify single quotes

strict derivation / parallelization / memory leaks
  cache tracks
    - put the "cached" log msg at the end of the cache results?
      Otherwise it immediately forces all of them.
      Wait, why should it?  Just cons on the front.
      . But it breaks lots of tests.  Is it really worth it?
  parallelism?
    . why does priming take so long?
      It needs the tempo.  Since signals are eager, that means evaluating
      the tempo track at least.  But not just tempo obviously, or it would be
      fast.
      What else?  Well, I need signals if they are being rendered.
    - Can I fork a spark for each note track being merged?
      Perhaps I should abandon the idea fo lazy derivation, it's likely not
      happening anyway.  I still want the evaluation incremental, but I could
      parallel force each track.
    - Try Util.AppendList again, but just at the track and block call level.
      At the block level it's to reduce copying, at the track level I can
      run a strategy on a multi-way merge to eval them in parallel.
      . Does this offer an advantage over embedding the parallel in BlockUtil?
        Well, parallelism depends on evaluation, and the track derivation is
        lazy.  So I think I'd have to put some bangs in track derivation.
      . Maybe I should try that anyway?
  strict derivation
    - If I'm forcing entirely, I can put in a merge at the cache level, so
      tracks and blocks would become merges, but all other calls are just (++)
      as before.  Then I can apply a parallel strategy at the merge level.
    - Also, consecutive signals should be mconcated.
  - try giving a big heap to speed startup? +RTS -H512m
  control memory leaks
    . Lots of lag and drag.
    . How big is each event?  Maybe the caches aren't so expensive because they
      share events?
    . Alternately, I could try doing the strict/parallel thing, and see if
      that clears it up.  Or at least strictifying.
    * use strict pair for cache entry (collect, events)
    * force the events when priming a perf
    * try lifecycle profiling, lots of void and drag
    * try retainer profiling
      - it's buggy and crashes, go mention it on the ghc bug
    - The drag is Map, and is eliminated when I clear the performances
      Narrow it down.
      . Forcing does nothing, but clearing the cache gets rid of a big
        portion.
    - If each event or unevaluated event has future and past it will keep
      the UI alive.  Maybe forcing the result of each event will clean that
      up.
  Space usage.  On startup it balloons up to 450mb, what is it doing?  After
    a bit of editing it's up to 750mb, who is leaking?  Undo history?
    * Write size profile that loads a big score and reports the size increase.
    - Write function to sum up State, Cache, and Performance sizes.
      Return stats about event size, etc.
    / Try interning strings on load.
      Savings are negligable, provided I'm calculating them correctly.
    - Flatten pointers out of data structures.
      Which ones? Cached Events, performed MIDI.
    * Discard old undo states.
    - Link libraries into seq as shared, also link with ghc api as shared.
      Ask on ghc-users first if anyone has done this.
    Compact cached signals and rendered MIDI.
      - First write tests that demonstrate where the space is going.
      - UNPACK Derive.Score.Event
      - Midi.Midi.WriteMessages compact as a lazy storablevector
    - Compact control tracks when I have that in, maybe compact only on
      checkpoints?
      But savings are likely to be very small for handwritten scores, would
      only make a difference for recorded control tracks.
    The ghc api uses tons of space when it starts linking in everything.
      - How much space does ghci take loading the same stuff?  Why so much
        less?
      - I probably have the whole app twice.  Can I use dynamic libraries to
        improve this?
      - dynamic libraries: www.well-typed.com/blog/30
    Check size on linux.
      stripped or not makes no difference
      bloom is 110m in memory
      repl is 200m in memory
      plus 50m for normal app
      so 360 for everything + bloom
      - calculate size of a score
      - calculate size of cache
    resident memory size:
    debug, no repl: 31m / 19m -- ? / ?
      darwin: 76 / 150
      linux: 32m / 129m
    debug, repl: unstripped / stripped -- 78m / ? -- 60m / 40m
      darwin: 193m -> 248m -- 323m -> 376m
      linux: 182m -> 230m -- 320m -> 367m
    opt, no repl: 35m / 20m -- ? / ?
      darwin: 39 / 116
      linux: 31m / 90m
    opt, repl: 81m / 48m -- 62m / 41m
      darwin: 194 -> 246 / ?
      linux: 131m -> 178m / 243m -> 321m

    loading bloom, debug: 74, 97
    loading bloom, opt: 77 / 59

    linux:
      bloom: 59 without the repl, but 231 with (huh?)
      repl: 100m + 47 to load seq libs
    darwin:

block composition
  - I do a lot of appending a block along with its ruler, I could have
    a single cmd to do that.
  - A more radical approach would be a block mode where the block calls are
    simply additive, and their duration doesn't matter.  This would mean I'd
    have to edit the tempo on the subblocks though, which in turn means it
    couldn't vary independently.
    . Could do this with a block call that acts as a note transformer, which
      simply pastes together sub-blocks.  I'd still want to cache the
      sub-blocks if possible, unless I do the block-range caching thing.
      Another bonus is I could probably get next/prev events working across
      block boundaries this way.  Maybe this could be used as an integrator
      input.
  - tempo composition is problematic because it means you can't change the
    length of a block from within the block.  So slowing down one part will
    speed up another.  How can I get local tempo like I want?  Or just edit
    the global tempo?  Unfortunately it's much more convenient to edit local
    tempo.  Maybe I could do a non-compositional tempo that simply overrides
    the caller, or rather multiplies with the caller.
    This means the call event is now longer than its duration would imply,
    and to fix that I need to have the child tempo modify the parent.  So
    effectively I am just modifying the global tempo, only providing a nicer
    syntax.

    This technique really is non-compositional: you can't have more than
    one call at once.
    Actually, I could: tempo track looks at calls in note tracks, gets
    sub-blocks, strips out the tempo tracks.  Then multiplies those signals
    with its own.

    Or I could just make it easier to edit the global tempo:
      * when you click on the parent, show selection pos on the child too
      - show derivation of child inside caller, I think I want to do this
        anyway, but it's hard, how do I fit all that stuff in?
      * merge child rulers with parent?
      But it still seems a bit awkward because I do want the tempo associated
      with the music, e.g. when I play by itself.  On the other hand, if the
      block repeats do I want the tempo to repeat as well?  Sometimes yes,
      sometimes no...

incremental save / git:
  + try saving individual events for incremental save
    Seems to be just as slow as full save, probably most of the time is in
    the call to git.  Test again with larger tracks.
  - wrap operations in a lock file
  - make sure things are ok if it fails at any step
  - I don't think Ui.State needs to emit CmdTrackAllEvents for cases where
    diff will catch it.
  * Why should I ever do a complete save?  Why not always just do partial?
    The repo should only contain one copy of something that never changes.
    One reason is to trim history, but maybe for that I should have a option
    to rename and save without bringing the history.
    So save is just a tag operation, it doesn't actually dump state.  This
    will remove the irregularity where a save state corresponds to no
    history entry.
    But then how do I start the saving?  I would need a special value to say
    it should start saving.  Binding to ^S is logical, but then the first
    save doesn't add a tag.  Unless the first save always tags.
    . Initially save_checkpoints is false, so no checkpointing
    . cmd_save makes it true, then Undo does a checkpoint
      But it has to notice the false -> true transition, otherwise it will
      consider the cmd not worth saving.  So hist_save_checkpoints is just
      True for the cmd that turns it on, and goes off after that.
  / Ability to give names to SavePoints.
  - See if git's delta compression understands binary and can compress
    tracks.  Otherwise, would it be worth helping it by e.g. separating
    each event with a newline?  But then it makes serializing events more of
    a hassle.
  Git docs: http://progit.org/book/ch9-2.html

integrate / integration:
  - adding a +soft stroke means it gets both less dyn and +soft again, so
    it's extra soft
  - bug: can't delete a derived track, it just gets regenerated
  - bug: can't undo past a integrate create, it just creates a new one
    Maybe I could not record the integrate step?
  - bug: create tracks, remove <, re-add <, does it work?
    Removing < should break the integrate links.

  / Optimize block integration: similar to only_destinations_damaged,
    if only the destination blocks are damaged, don't rederive the source.
    Actually, this doesn't seem to be necessary.
  / single track mode that doesn't split tracks
  / integrate not logging means that integrate errors only show up on play
  / It may be possible to parallelize multiple integrations.
  - Convert.Tracks should mirror TrackDestination structure.  Or
    parameterize TrackDestination?
  - Figure out how multiple levels of track integration work.
  - If integrate is committing changes to a track, can that bite me if
    a "canceled" derivation comes through?  Think about this later.
  - What if an integrate wants to produce a note transformer track?  I
    think that's currently impossible.
  - quantization

lilypond:
  * bloom 6/4 should be able to span the whole measure with a dotted whole
  - warning if ly-prepend or ly-append is being omitted due to a chord
  * KeyChange -> Code
  * code is mixed into the first voice, but is then lost if voice
    simplification elides that voice
  * bloom, mvt2, mm31: grace links to wrong note
  - Maybe code events with a voice should go in the voice requested rather
    than mixed into the first one.  E.g. would have fixed grace notes.
  * rename voice to v, rename hand to h?
    hand is usually in titles, and h seems too obscure
  * omit the voice division as long as there is only one voice
  * support for mordent
  - one track has voice, the other doesn't, causes a "can't advance time
    backward" error
  * put staff config like '\set Staff.pedalSustainStyle = #'mixed'
    in the staff config
  * I could use staff config to filter out some instruments
  * library of common staff code
  - remove the StackMap stuff
  - code events in >ly-global can be distributed to all staves
    Otherwise I have to remember to add e.g. ly-key to all staves manually.
    But ly-key is no good, I really do need to set the key.  I think I have to
    break up the block.  Why can't I do assignment more easily?
    Well, I have to grab a deriver to dynamically scope the new value around.
    Unless I let a deriver mutate the environ, then it has to be nested.
    If a deriver can mutate, then events have to be evaluated in order.  Of
    course, they already do for controls because of the previous sample.
    And since it's unset at the end of the block, block caching still works,
    the same way as for previous sample.
    On the other hand, I think I want to encourage nestedness and it should be
    easy to split.  The only reason viola-sonata has huge blocks is that it's
    a midi import.
  - Derive.Call.Lily needs a naming refactor since there are too many vaguely
    named flavours.
  * rename is-ly to ly-track if I can't get it to apply to individual notes.
    Well, I can, but it's just the same as when-ly.
  * instead of Code events interrupting voices, it should be incorporated into
    all voices.  But that may be incorrect, e.g. I don't want ff on every
    voice, just one.
    * dyn marking messes up simultaneous voices
  - I need some way to hide rests.
    Add magic bit of code that turns its rest r4 into s4.
  - If I can figure out the meter from just the name, then I can get rid
    of the awkward map with hardcoded meters.
    I could have parse generate the Meter and memoize it.
  - optionally emit the lilypond to display a compound meter
  * convert lily code to Text instead of String.  Maybe VString has to become
    Text then.
  * pedal should emit pedal sign
    I can't use the pedal call for that, since it emits control.  But I can
    look at the pedal signal directly.
    Maybe it would be simpler to just have a ly-ped call, especially since the
    pedal signal doesn't line up exactly the same.
    \sustainOn .. \sustainOff, \set Staff.pedalSustainStyle = #'mixed
  * Why does the cmd have to wait until lilypond is done?  Should be async.
  - use Util.Format in ly output
  * to_lily should return Text
  - try Util.LazyVector for Ly output and see if it helps
  + can I make a click on a note in the pdf highlight in the sequencer?
    Hung up on getting preview to send clicks to a program, notes in
    App/LilypondClick.hs

negative duration / arrival beats:
  - trill or trem with negative duration lines the integral number up to the
    end.
    It's not too practical since I can't have a note start where the negative
    note ends.  Though maybe I could if I put the "start" at the low end.

    Events have a flag which says whether they are end-weighted or not.  If
    so, the trigger line is drawn at the end, and text goes above the trigger,
    but they are otherwise the same.  The duration is still positive, but the
    flag is available to calls to do with what they will.

    This simplifies the editing stuff quite a bit, all of the special negative
    event handling goes away.
  - Figure out how arrival works with controls.  It's most natural for
    a pitch for a call to go at the end of the call, but for that to work
    negative dur controls have to extend to their *previous* note.  Seems
    like this requires a flag on the control to use a different Signal.at.
    But that's not right for normal notes, whose pitch really does extend
    afterwards.

    Currently, if I want to set pitch or control for a call, I have to put the
    control slightly after the start of the call, so it encompasses the call
    but not the note before.  That's awkward.

    If -0 dur control points go from >start <=end, then the pitch has to go
    at the end of the event (earlier in time), which is even more awkward.

    I think the controls have to go at the note's start, and have to logically
    extend backwards to the note's end.  That means I can't write anything
    other than a straight pitch because the actual sounding note is implicit.
    So it has to be via integration
  - ensure inversion works (it should slice >start <=end)
  - ensure redraw works
    I have to make SymbolTable wrap text above too.

external
  - chorded keys are not getting the proper pitch bend
    It's a pianoteq problem.
    Track it down and send it to them?
  - problem with pianoteq: if the same note occurs on two channels, one
    will be dropped.  Report to pianoteq.  I could work around, but it won't
    occur with real multitimbral instruments anyway.
  + send a patch to improve Random.Shuffle?
  - patch for hsc2hs for #alignment
  srcloc_annotate pragma
    I think a ghc pragma is needed.
    - read up on how jhc does it
    - ask ghc-users if it's a good idea
    - figure out how to implement pragmas in ghc

use fixed-binary instead of Doubles for ScoreTime and RealTime:
  reasons to do it:
    - get rid of custom implementation in Perform.RealTime
    - get rid of half-open except start==end hack for ranges, a point selection
      is simple (start, start+1).
    - RealTime.to_seconds is big on the profile
  reasons not to do it:
    - what to do about -0?  I could disallow 0 dur events and make control
      events have an eta dur
    - will fixed64 be slower?
  switch back to Double for RealTime, split from Timestamp for midi
    - but floating point imprecision make controls not be clipped to their
      notes properly.  I think this happened at the Deriver level, not Perform
  problems:
    too slow, I do lots of to_double conversions that are slow.
    Can I do all that math in Fixed?

plugins:
  - Either dynamically load local inst definitions and local StaticConfig, or
    auto-generate the link file Local/Instrument.hs.
  - come up with plan for reloading inst config and static config
    Really what I want to be able to do is recompile the static config
    incrementally, relink it with the main binary *quickly*, and restart the
    app with exactly the same state.  This should be a lightweight operation,
    so it's feasible to edit some code, press play, edit code, and play
    again.  That means a full-on serialize restart is out, because the cache
    could be quite large.

    Of course, you want this stuff in a library so it can be reused across
    projects, so you can put it all in Local/.  Then the song state would
    have a (hopefully minimal) linkage from hs namespaces to the tracklang
    namespaces.

    So with hs-plugins: The static config is considered a plugin.  You edit
    Local/Config.hs, or edit other files in Local/.  It detects the change,
    regenerates Local/Config.hs, recompiles and reloads it.  Then the
    responder is called again with the new static config.

    So I need to be able to re-initialize the responder with a new static
    config.  Actually, the bits I care about are the call map and the cmd
    map.

cleanup:
  - move src into src subdir.  Then I don't have to do hacks in the shakefile
    where I only recurse into [A-Z]* dirs.
  - split Ui.State into separate modules for views, blocks, tracks, etc.
    put into Ui.State.* and re-export from Ui.State
  - split up CallInfo depending on type
    I got started but was discouraged when it came time to write
    GetLastSample, maybe I should make another go.
    Note tracks can't get a GetLastSample at all.
  - as above, Derived could be called Cacheable, and Elem should be a separate
    type family
  - It would be more efficient to move events around if their controls were
    normalized to start from their beginning, so that you never have to modify
    the signals.  Of course, it's only worth it if events tend to get moved
    more than once.
  - Think about some way to formalize the identifier restrictions, currently
    it's only enforced in the tracklang parser.

    p_ident applies to: Attributes, Control, PitchControl, ScaleId
    Maybe it's enough that the parser restricts them?  That means no one
    will bother creating e.g. a bogus control name because it could't be used.
    Call names are explicitly anything-goes.  BlockIds should support at
    least some of it if they are supposed to be interchangeable with other
    calls.

    On the other hand, I don't think I care much if idents can have wacky
    names, they just won't be nameable from the tracklang.
  - storing TrackEvents without duration would make maintaining the
    no-overlap invariant easier.  E.g. have explicit 'off' events, otherwise
    each event extends to the next one.  It means after merging I have to
    clear redundant offs, but that's easier right?

  / instead of building log dup suppressing logic into various functions,
    e.g.  allot, maybe I can add 'key' field to Log.Msg and suppress dup
    keys?  Who else produces dups?  Convert does.  But isn't it more
    efficient to just not emit?
    - convert and perform want to suppress the same msgs for the current
      derivation
    - Perform.Midi.Cache.is_splice_failure is just a better way to identify
      the msg than text
    - cache wants to suppress all cache msgs until end of cached block
    The problem is that it's hard to know the boundaries of the current
    derivation, especially if there are multiple blocks being derived
    simultaneously.  I would have to put a block id key.  On the other hand,
    filtering in place knows that.  The extra copy is actually no worse than
    the filter at perform time, maybe better for cache since it only happens
    once.

performance:
  * make TrackLang.Symbol into ByteString?
    . means fewer conversions
    . maybe faster lookups
    . But ByteString is not necessarily more compact for small strings, e.g.
      1 char = 4 words, 2 char = 8 words
    . Actually space isn't a big concern, it's probably more about looking
      up in maps, bytestrings may be faster.
    . Also ByteString is pinned, does it make a difference?
    / I think the number of calls is actually not that high.  Doesn't seem
      worth it.
  - Do profiles again with Data.Text instead of ByteString.
  scrolling through giant blocks is slow
    - drawing is stil slow, I'll have to look at the fltk layer
      It happens when the block is wide.  Use test_block to see if it's just
      fltk.
      . It's fltk.  Not alpha draw though.
      Scrolling is weirdly chunky near the top when fl_scroll() is on.
      Curiously it doesn't seem to help at all.
    - Would it be faster to call fl_scroll once for all the tracks?  I could
      also theoretically call find_events all at once too, though that
      shows up low on the profile, so maybe it's not a big deal.
    . The thing is, it seems like fl_scroll doesn't actually help scrolling
      speed at all.  Maybe all the time is spent elsewhere?
  - the same place that updates the status could use updates to clear caches
    for cmds or for TimeStep
    Clear when: inst changed, so if any performance was regenerated.  In fact,
    if I put the cache in the performance then this happens automatically.
    But where do I put it while the performance is still waiting?  I guess
    I can stick stuff in the performance without forcing the events.
  - look into Debug.Trace.traceEventIO to see how long various things take as
    in http://www.yesodweb.com/blog/2012/10/future-work-warp
  efficient signals
    control
      - make Ui.Events into 'Map ScoreTime (Event | Chunk Signal)'
      - collapse chunks of adjacent 'set' calls into a Chunk
      - track_derive on a Chunk just returns the contents
      - fltk event render should detect too dense events and omit them, rely
        on the signal render
      - UI edits should see the Chunk expanded out as Events.  Inserting an
        event should modify the chunk or split it depending on if the inserted
        event is a set call or not.
    pitch
      Similar to control except I can't make Chunks automatically, since
      collapsing to NoteNumbers loses information.  But recording doesn't have
      this information in the first place, so it can generate chunks.
      However, maybe I should omit chunked pitch signals entirely and instead
      emit an initial pitch along with a transposition curve.

  - make seeks on derive output more efficient with a lazy index
  cache
    - Can I make cached signal more efficient by merging the signals before
      stashing it?  Of course laziness means that this won't actually happen
      until the next time the cache is demanded, unless I force it.
    - see if the cache filtering logs is causing significant copying and
      remove
  Cmd
    - If a msg aborts or doesn't run any cmds, don't bother to run diff.
      Except that hardly ever happens if I do shortcut thru.
    - cache track cmds for each track, update when the track title or skeleton
      changes
  Derive
    AppendList / MergeList for Derive.Stream
      - switch to AppendList and try to get garbage down
        Avoid copying sublists returned by block calls and cache hits
      - play from cursor is a linear scan on all events from the beginning,
        seems like this would be faster if I could skip chunks.
      - see if a Merge constructor can reduce copying
      - can I cache length and range in AppendList?  does it matter?
      - insert parallelism?  maybe the evaluator can do that when it sees
        Merge?
    - lazy signals
      - check out 'at' and 'bsearch' occurrances and see if they can use tails
      - There are lots of lookups in the tempo map
    - see if making a version of Derive.local that's non-monadic in the
      modifier has any effect on performance
    - to get arrival beats to work right with the control track, I think I can
      make the 'set' control track call set from (prev, cur) instead of just
      cur.  It will make simultaneous samples, but they should be ok.
    derive cache
      - c_block should only cache if the block has > a certain number of
        events.
      - implement tracks as generators so they can be cached too
      - I won't rederive cached generators if they have control damage outside
        of the event range.  But there's nothing stopping a generator from
        reading ahead or behind... come up with some kind of solution for this.
    - fair amount of garbage generated by SignalBase.bsearch_above, I think
      this is because it has to box the values when it pulls them out.  But
      it's really just comparing to a Double, so I should be able to do the
      operation unboxed.  But decide about lazy signals before going nuts on
      this.  If I revert to linear search then none of this is necessary.
    - at_linear is called a lot by compose, by compose_warp, by d_warp
      can I make this more efficient?

    - or maybe it's the control deriver creating a huge list of signal
      chunks, which is then all forced at once since merge needs them all.
    - Parallelize derivation with strategies.  Can I spark subderivations?
  Perform
    - use a lazy storeable vector for [Score.Event] and [Midi.Message] to save
      memory?  If I make Messages a storable vector, I'd have to hash the wdev
      or something.
    packed midi, encode to storable vector
      - last step of performer is to compact into vector
      but I'm not sure this will much help
      The main thing is how to encode the device.  I think I can hash it.  Or
      use OS X persistent device ID?
      how many msgs in e.g. the ptrio?
        127130, [pno 9205, flute 63748, clarinet 54177]
        5367 for bloom
        peak for 246114 msgs: 46mb for int, 38.7 for int, 38.7 for w64

symbolic score
  - namespacing?  don't worry about it for now, if I need it later it can be
    entirely at the haskell level, I can use the per-song config to import
    namespaces
  - feta's tr symbol looks bad especially when small, is there a better one?
  - find or make a font with jian ti symbols?
  - find or make a font with gong che pu

fltk:
  drawing artifacts on retina:
    . Some of this may be fltk bugs.
    * signal renders get white lines
    * track bevels get junk
    - tops of tracks and the tops of track text boxes still get gunk, visible
      when scrolling horizontally
  - Should fltk collapse adjacent dividers?
  track titles
    - Grow the window when the title grows past it.
    - Grow text past edge of window, when I resize the window the text keeps
      growing with it.  But it doesn't expect that size, and doesn't clear
      when deselected.
    - Type into track text on the right side, then expand the window so it can
      be visible.  It doesn't redraw the newly-revealed bit correctly.
    - If I wrapped track titles I could see the entire thing, but at the cost
      of using more vertical space.
  - There's a focus bug, but I'm not sure how to reproduce it.
  + can I get fltk to omit the jellybean buttons on the window?
    . Yes, but requires hacking fltk.
    . Completely disables resizing.  Apparently this is hardcoded.
  - event.text would have to be utf8 to support option-key symbols
  - some way to scroll that's not the scroll wheel
  - I could set certain Symbols to stretch to the length of their event, this
    would yield a nicer looking score.  But it would mess up the bounds
    detection.
    + gmail: subject:(scaling text)
      But it's OSX only.
  * skeleton display has leveled steps to make it easier to see who is
    below who.  Only if a track has multiple children.
  / rethrow c++ exceptions as FltkError
  - factor scroll redrawing into a single class
  / draw arrows in SkeletonDisplay.cc properly meh, they look ok
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  incremental redraw / scrolling
    I don't like the current situation of incremental redraw and scrolling.
    It's also buggy, i.e. one pixel difference between scroll and redraw.
    Get rid of damage and redraw everything every time.  Then I have to make
    it fast to fetch the data for one screenful.  What makes that slow
    currently?
  Track
    / dividers can have separate color for upper part, for collapsable tracks
  - ScoreTime is just a double, I can pass it directly as CDouble
  + Why does seq sometimes leave a app menubar on quit?  Do other fltk apps
    do that?  Yes.
  + Disable application persistence for fltk apps:
    http://oleb.net/blog/2011/07/whats-new-for-developers-in-lion-part-1/
    Can then re-enable ~/Library/Saved Application State.
  event track
    * visual indication when both solo and mute is on
    Bring back the idea of opening up a text entry in raw edit mode.
      * Block::edit_open closes any existing edits, calls
        EventTrack::edit_open
      * Block::edit_append finds a track with an open edit
      * Make sure input gets events.
      * If I put it in TrackTile, I only need one, and don't need to iterate
        through the tracks, and I think the redraw stuff works as-is.
        But then it doesn't work for an event track in the ruler position.
        And how the redraw stuff works is a hack.
      * remove is_edit_input
      * EventTrack::edit_close emits a msg
        Return msg is:
          data Edited = Edited BlockId TrackNum ScoreTime Text
        The UI can suppress this if it detects the text hasn't changed.
      * starts in the wrong place
      * respond to the response msg correctly
      * leading space creates a zero-dur event
      * there's a memory corruption bug in there somewhere
        Sometimes haskell gets \NUL\NUL instead of "hi".
      * chinese text is corrupted
      - send EditAppend
      - remove RawEdit?
      * use cmd-h, cmd-l, cmd-delete to move and delete words
      - 'i' insert, 'a' append, 'I' replace first call, 'A' replace last call
      Pros:
        . Insert at beginning or in middle since I have a cursor.
        . I can clean up text, e.g. strip spaces.
        . IME available.
        . Can edit hidden event.
        . No deriving partially written text.
      Cons:
        . Complicated.
        . Can't zoom / play / etc. while in edit mode.
        . May require more keystrokes to enter single char, though there are
          probably ways to work around that.

      The responder has to be able to tell UI to open a text entry, so cmds
      can return an Edit:
        data Edit = Edit {
          edit_block_id :: BlockId
          , edit_tracknum :: TrackNum
          , edit_at :: ScoreTime
          , edit_text :: Text
          , edit_cursor :: Int
          , edit_selected :: Bool
          }
          | AppendText Text

      If there is already a text entry open at that position, insert the given
      string at the insertion point rather than creating a new one.  This can
      implement midi->*note insertion.

      When I get a midi key, I emit AppendText.  Ideally I should only do this
      when edit is open, otherwise I'm constantly sending notes to the UI
      which are ignored.  I guess I can flip a bit when Edit goes out, and
      turn it off when Edited comes back in.

  control track, render signal
    - Figure out linear sets of samples and emit them as one line.
    / decided against rendering signal as one long line, comment in
      EventTrack.cc
    - render option: solid with color gradient
    - combine multiple signals, e.g. one controls xpos, one controls color

logview:
  - two lines for the status bar at the top
    Or as many as necessary?  Wrap on |, and justify by inserting spaces?
  - can I get the standard edit menu and copy/paste?
  - haskell and c++ use the same machine readable format
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...

Ui:
  Track
    - benchmark large TrackEvents
    more compact implemnetation than Data.Map?  profile first!
      - priorities: memory efficiency, persistent, merge speed (insert many)
        shallow tree of dense chunks?
        can I take advantage of non-overlap?  [(pos0, data), (pos1, end), ...]
        data Event = Event String StyleId | End | ControlVal Double
      - I think memory efficiency is more important than modification speed
    dense sampled signals
      - efficient storage, preferably as a Signal so no conversion is necessary
      - display dense signals: omit text and trigger lines when zoomed out

plugin host freeze audio
  features:
    3 load synth plugins: ardour3, reaper
    1 programmatically configure them, e.g. load 4 fm8s each with poly of 2
      and loading inst X, or switch them all to inst Y
      - dunno?  can reascript do it?  osc on ardour?
    3 sync play position seq, sync start time
      - I think mmc can do this
      - or maybe the control surface support can do this
    3 start record too
      - control surface support should do this
    2 sync from daw back to seq
      - Can I have the DAW also emit MMC?

  features needed:
    - host synth plugins: programmatically load and configure plugins
    - route midi: associate each plugin with its own midi ports
      It would also be nice to split by midi channel, and route each chan to
      its own plugin.

      On OS X this means creating an IAC port for each synth, presumably
      multiple ones for multiple instances of the synth.  Then I need to
      route each synth to the right midi input and keep them configured.  This
      seems like a bit of a hassle.

      Can I use JACK midi to address a specific synth?  It's one midi stream
      per jack port, so I need an association between insts and jack ports.

    - audio graph config: configure the audio graph, placing synth plugins,
      filter plugins, track record / fader / etc. daw stuff, and outputs
      at various places
    - DAW: Need to sync play position and send current cursor position when
      it changes.
    - track freezer: Record plugin output, sync play position.
  rpc
    - osc, but no good for two way
    - thrift?
  ardour
    - ardour3 supports synth plugins, but doesn't compile on OS X yet
      wait for paul to post his updated build instructions, try again then

  reaper
    it can sync to mmc
    - route multiple plugins to the same bus?  can this be scripted?
      Probably, but to use apple IAC I need to create a bunch of IAC ports and
      make sure they are configured the same way on both sides.
    - can it send cursor position?
      I can poll.

  impromptu
    - mac only
    - can programmatically create a au graph
    ? can it record audio?  yes, but maybe not from an au?
    - in any case, I can't do daw stuff, so I think I don't want this

test:
  complete quickcheck derive testing
    I switched back to Double for RealTime, but this means the roundoff errors
    are back.  Use quickcheck to repro them.
    * make Arbitrary for BlockSpecs
    + make a simple deriver that creates event and midi output skeletons
    - integrate quickcheck with generate_run_tests.py
    - assert that the reduced deriver output equals the simple deriver output
    - basic pitches: If the score was created with notes aligned to note
      starts, then every NoteOn should have the appropriate key, there should
      be no pitch bends, and "same note" should be the only reason for
      a channel split
    - basic controls: Given randomly placed control events, notes have the
      correct control curves.  Don't worry about times or midi.
    - slicing: Given some simple note transformers (tuple, place, ...),
      pitches and controls are still associated with the right notes as above.
      Don't worry about times, just that the right notes and the right
      controls.
    - block call property: a couple levels of nesting for block calls, notes
      still have the expected pitches and controls as above
    - inversion: as 'basic pitches' and 'basic controls', but controls are
      below the note tracks, results should be the same
    - stack: generate nested events, check that stack is as expected
  - tests count number of tests in addition to checks within each test
  - use generics or Foldable or something to write a generic StructEqual

integrator / midi record:
  - implement

REPL: repl:
  * don't load history if it hasn't changed
  - repl should understand --
  * stop writing history to ".repl"
  - only write history when the cmd succeeded
  * repl should load the history from save/.../repl, and have a history search
    seq will have to tell the REPL what it loaded, so it needs a fancier
    protocol.
  * haskeline doesn't get along with the prompt colorization in repl
    I could get rid of it, but is there a way to get haskeline to understand
    it?
  - add ^P for history search, and display a short menu of the various matches
  - command to open the haddock for a module
  - haskeline sucks for long lines, add multiple line editing?
    really I'd prefer plan9 style esc then edit
  - is Cmd.Lang.Fast now obsolete?
  - can I get local variable bindings (let x = ...; y <- ...) to work in the
    REPL?
  - tab completion for symbols like in ghci
    I'll need a list symbols cmd which the repl automatically sends on tab
    completion.
  - :compile cmd that turns on compilation for everything except Environ
  - :browse to look in modules... can I use GHC.getBindings for this?
  - :module cmd to move evaluation context to a certain module, maybe I
    could also get rid of the need for Cmd.Lang.Environ to import everything.

Cmd:
  meter / timestep
    - timestep 64*2 skips two 's', because 's' is the minimum match
      skip should be ignored when the match is a larger rank than exists, or
      maybe step should fail.
    - use NE list for TimeStep
    - TimeStep should support negative skip as a fractional skip
    - points use vector instead of list
      But then I lose laziness.  Maybe only worth it if I cache.
    - cache points by returning CachedTimeStep = Points
    - TimeStep.snap should optimize steps that don't do any snapping when
      prev_val is Nothing, e.g. RelativeMark and Absolute
  - step play StepPlay could work even when notes were moved by annotating
    the midi output with the UI event that produced it.  This might be useful
    for debugging too.
  - Can I give Cmds their own state without putting it in Cmd.State every time?
    For instance, twelve scale may want to know what key you're in.
    Actually, it would be best to have per-module state.
    At worst I can have 'Map.Map String Dynamic'.

    Use existentials:
      data forall a. Cmd = Cmd {
        cmd_func :: a -> CmdT (Status, Cmd)
        , cmd_state = a
      }
    This means that such cmds have to be able to be updated after they are run,
    so the cmd lists have to be kept in responder state.  If I'm going to do
    that, why not have cmds optionally return a continuation and handle state
    that way?

      cmd msg = do
        state <- stuff
        return $ continue $ \msg -> do
          more stuff

    Or if I can put it in the monad:
      cmd msg = do
        state <- stuff
        msg2 <- yield Cmd.Done
        more stuff

    For module level, each module of cmds would have to export a bunch of Cmds
    and the responder retrieves the state and passes in another layer of
    StateT, or directly.  I supposed Dynamic wouldn't be so bad for that.  What
    happens when the module is reloaded?

  ? a module with easy access to all GlobalKeymap cmds for cmdline access
  vi style keymap:
    - movement: hjkl, HJKL to move timestep+1 or skip to
      next inst track, bf to move timestep at block section rank, BF to move to
      top and bottom of block
    - esc and i for edit mode
    - number prefixed cmds?  not for now
  Cmd.Edit
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
      (merge will clip them to the next event)
    - controller edit mode accepts two numbers and moves on, no spaces
    - a legato command that always goes to the next note would still be useful

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.Play
    - start playing from top of displayed area

  Undo / UNDO
    - shift [ and ] undo and redo zooms.  or one key to toggle last zoom?
    - Suppressed undo for val edit is surprising since I tend to do a lot of
      edits without leaving val edit.  Maybe don't do it for pitch val edit.
      Try going back to using the name to suppress, but ignore cmds with no
      name.
    - It can be really confusing how undo and redo makes windows pop up and
      disappear.  Maybe I should make undo not affect views at all?
      They have to go away if the block went away, but otherwise they can
      remain unaffected.  Of course that means an undo could be undoing
      something out of sight.  Another case for per-block undo?
    undo also undoes the clipboard, which makes undo, copy, redo, paste useless
      - clip block should use the ruler, just to make it easier to look at
      - clip could also copy over the skeleton
        It could use it to make sure the paste is compatible, but that might
        be more of an annoyance than a convenience.

    - Add a "revert within selection" that searches backward for the last
      change within the selection.
    - Along those lines, should each block have its own independent history?
      This is supported naturally by the git layout since each block has its own
      file.  Wait, actually it's track, and that would be awkward if I undo one
      block and it changes tracks on another.  How do a say what position
      a block is in the history in that case?
      . One appealing thing is that I don't necessarily want things like config
        changes to be included in undo.
    - Visual display of undo history, because stepping back one-by-one is
      a bit of a hassle.
    - record view changes, at least zoom / scroll so it can be undone / redone
      separately

  Cmd.Freeze
    - details in doc/freeze_track

  Cmd.Save
    - save with a magic number so I can load songs, inst configs, etc.
    / gzip save files

Derive:
  tracklang:
    * come up with a solution for overlapping children, e.g.
      doc/dev_notes/note_tracks
    - Track caching is too fragile, if I add a track with scope over everything
      then I get no caching.  Instead I should cache the bottom note track, or
      perhaps every note track.  But that doesn't work because they're all
      sliced up.
  postproc
    - retune a note depending on the previous interval (e.g. sloppy pitches
      when playing quickly)
    - overblow emulation: a set of overblow ranges are defined, along with
      possible pitches for each one (fundamental and overblow harmonics).
      When a note moves from one to another, start a new note at the
      destination pitch and bend the decay of the old one to the fundamental
      or closer harmonic from the previous mode.
    - rambat damping emulation: notes ring on by default until they can be
      damped.  Damp at the first opportunity, where opportunity is defined
      as a break with no notes for a certain amount of time.  Can only damp
      two neighboring notes at a time.

  * x = _ will unset x
  - consider track calls and block calls:
    note_track :: TrackTree.EventsNode -> Derive.EventDeriver
    derive_tree :: ScoreTime -> TrackTree.EventsTree -> Derive.EventDeriver
    I could use this to implement is-ly and no-ly, and also totally custom
    track types and block types.

  pitch calls:
    - accelerating trill
    - overshoot pitch call, e.g. indian style

  note calls:
    trills
      - hybrid where the initial part stretches, final part is absolute
    trompong / reyong:
      - trompong ngoret, actually I can use rambat tick
        But damping on reyong is different, you can just forget some notes.
      - split to ngembat, e.g.    hmm, is there a reverse lambda?  Can
        I draw symbols reversed?  
      - various numpuk
      kilitan
        - more graceful transitions between pitches
        - variant patterns
        - coordination across parts
        - damping, depending on speed
        - support kilitan/beat speed more exotic than 4/1

  control calls:
    - sine
    - continuous tempo warping for signals
      tempo: "2" -> "1", "2", cont: "2" -> "i, 1", should emit a bent line

pitch / scales
  scales / Derive.Scale:
    just intonation
      - interpolate between just scales in different keys
      + just intonation tuned to a pitch signal
    - looks like fun: http://en.wikipedia.org/wiki/Bohlen-Pierce_scale
    - retune a note depending on the previous interval (e.g. sloppy pitches
      when playing quickly)
      I think this has to be postproc.
    - Ratio based notation where the ratios are from the previous pitch.
      Should be able to do this with val calls.
    - parser for scala .scl files
    - support scales that are different ascending vs. descending
    - twelve, but relative to key and using numbers, aka jianpu
    - letter and jianpu but with implicit accidentals based on the key
  - It's a bit unpleasant how I have TwelveUtils for accidental and key using
    scales, then Scale.Util for simple scales, and then Just is its own thing.
    Can I unify things into one framework?
  intonation: think about how to do e.g. meantone melody, with just harmony
    . Do a postproc to analyze simultaneous notes.  If I use an attr to
      tag the melody, I can tune everyone else to it.  But how do I retune
      notes with non-trivial pitch curves?  Well, I could use a transpose
      signal to tell the pitch calls what's going on.  I think I might just
      need the frequency of the melody note.
    . Do an analysis pass, and insert environment that says what the harmony
      is.  Then pitch calls use that to tune.  Doing the analysis might be
      tricky since I have to extract a "principle pitch" from each event,
      but it might be useful in general to have an analysis framework.
  fancier pitch signals:
    - to_relative: This needs Note - Note = Semis.  I think I could just add
      a field in Scale, but I'm not totally sure I really want this.
    - Cmd.Lang.LPitch.to_relative: I would need to implement Scale.scale_diff
      but I'm reluctant until I need to_relative or something similar

Perform:
  - damper pedal causes all notes to extend until the pedal comes up, should
    the performer know about that?  Is there anything that this breaks?
    I don't think so, it affects channel allotment so notes could be
    improperly joined, but mixing pedal and multiplexing seems rare enough.
  - Perform.Midi.Perform: should be possible to lead keyswitches as long as
    they don't precede the previous NoteOn, since I think samplers will only
    switch on the next NoteOn
  Instrument
    - some kind of organized way to manage instruments and instrument config
    - some basic midi instrument defs for generic midi (dev, patch)
  Midi:
    - see if synths support the set pitchbend range controller
    / inst has a notion of polyphony so I can avoid overloading a channel, say
      if I limit it to 2 voices

      The problem is 'allot' doesn't know which channels are going to have
      a lot of notes so it can allot wrong.  For instance, a large chord might
      take up all the polyphony of the first addrs, and then the Nothing addr
      gets the bendy notes.  I think I would have to look into the future and
      make a decision based on the notes that will be overlapping with this
      one.

      The problem comes up with chord oriented instruments that have a few bent
      notes.  However, I'm not totally sure this will be a problem, and it
      would be simpler to simply make two instruments, one for non-bendy notes
      and the other with multiplexing for bendy ones.  Yes, this is putting
      some busywork on the user which should be left to the performer, but
      since the solution is fairly complicated I think I'll leave it be for
      now.

Instrument DB / browser:
  - browser has lots of empty space on the bottom
  - z1/virus-bass has UnknownMessage for initialization?
  - patch files could go in the Local/Instrument dir with the source?
    at least it should go in source control
  - colorize the info_pane so tags are easier to read
  - search lang supports quotes
  sysex
    z1
      - convert patches to larger pitch bend and send them back
      - I need control over which program and bank the patches go when they
        are initialized.  I can use the card as scratch space.
      - I also need to initialize a new multiset, and give the score
        a multiset config, or derive one from the midi config.
    vl1
      - test sending sysexes back
      - move patches to new format
      - figure out how to set category for builtin patches
        *word shorthand for category=word?
        but I want to use the inst name, not the score name...

OSC backend
  in doc/dev_notes/sythesizer
  - Write a simple supercollider instrument and try controlling that with OSC.
  - Even if reaktor and supercollider don't understand bundles, I could write
    a scheduler server that takes bundles and emits their msgs at the correct
    time.

jack: JACK: linux midi:
  bugs
    - something is still wrong, I get "no space in output port" and then
      corrupted output
    ? jack1 doesn't work at all: other clients don't see writes, until I quit,
      and then they get continuously spammed.  Apparently the jack_port_t*
      from the registration and the lookup are different.
      - Try stashing port from port_by_name port instead of jack_register_port.
  - does jack not support sysex at all?  Maybe I can't use it at all then.
  - Ensure that shutdown stuff is being called correctly.  I don't care but
    maybe JACK does?
  use jack transport
    I don't think I need to be the master.
    - When starting a play, call jack_transport_locate,
      then jack_transport_start().  The play then blocks on a lock which is
      released by JackSyncCallback when it gets a JackRolling state.
    - Register with jack_set_sync_callback.  JackSyncCallback sets a syncing
      flag, emits a Msg that forces the needed bits of performance, then that
      cmd must call back and reset the flag, at which point the sync function
      can return true.
    Then the next step is to test, and then figure out a way to get ardour to
    automatically set up a bunch of instruments and make MIDI in ports for
    them.

misc ideas:
  - Staff notation represents chords well, but tracks don't.  Think of a more
    compact notation.
  - Why can't I write a 'tr' that generates pitch signal in some cases, and
    adds an attribute in others?  It would be redesigning control tracks so
    they are just note tracks that slice their children and apply
    a transformer to them.  I'm not sure that will coexist with the curve
    description language that control tracks currently implement.
    It would be interesting to get rid of track types entirely though.

planning / research
  Composition of score fragments.  I think I want to display subderived
  notes within the call event.  And then some way to put edits on top of it.
  - spline curve interpolator: evoral/Curve.cpp, www.korf.co.uk/spline.pdf

  - If I implement a VST host or patch a DAW to accept VST controls like MIDI
    controls can I get low latency high res controls?
