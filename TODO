* .depend doesn't have *.hsc -> *.h dependencies

ui
  * make TrackPos into an opaque type to let me be more free with impl.
    implement as int64 usec?  or since it's just block relative, I can use
    plain unsigned msec?
  * scroll
  * add info line at the bottom
  - zoom
  * selections
  - organized logging situation
  * bug: one pixel drawing glitch at bottom of tracks
    it has something to do with FL_FLAT_BOX + FL_THIN_DOWN_BOX
  * bug: starting with an x,y offset makes BlockView confused
  * bug: resizing ruler to 0 crashes
  _ optimize redraw by implementing scroll and selection damage
  - scrolling should add text height to time_end()

  UI Msgs
    * convert EventCollectWindow to global EventCollector
    * remove the fltk default event handling, except for inputs
    * custom Msg type that includes events, as well as "new selection" and
      other UI actions
    * send msg_scroll_changed msgs
    * figure out how to go BlockView* -> BlockView in UiMsg
    - clicking outside of SeqInput should unfocus it

  Track
    / dividers can have separate color for upper part, for collapsable tracks
  event track
    * overlay ruler
    * events
    - bug: scrolling gets little one pixels shifts
    - bug: event tracks flicker when moving horizontally
  Ruler
    * don't clip out the text as soon as the marker scrolls off screen
    * clip markers when they overlap edge of widget
    - bug: looks like overlay is getting drawn twice when called from Interface
      after adding a selection
    * text labels

  MoveTile
    - bug: upper part of ruler track not getting resize?
      also not shrinking to the left
      hard to trigger this one
    * bug: I can resize a divider by dragging the right edge
    * bug: dragging divider jumps to dragging by left edge
    * dragging tracks should resize rightmost / bottommost widget like resize()
    * bug: moving a track off the right side chops it off
    _ bug: tracks close together seem to have a problem, and the arrow hot point
      isn't obvious.  highlight?  or a handle somehow?


Interface
  * rename Interface -> Ui, ui -> fltk
  - force evaluation of args in Block.hs etc.
  * UiMsg: use Key data type instead of Char for e.g. backspace
  * use main thread for ui
  - get/set block config, block view config
  * BlockView.set_track_width, BlockView.get_track_width
  * track_at
  * Event
  - figure out how to force args

tests
  - hunit for Interface testing
  - some kind of organized hunit / quickcheck for pure code

app
  - actions
  - msg -> action mapping

Midi
  - midi thru: MVar (Port -> Message -> [(Port, Message)])
  - scheduler for out of order writes + thru?  how about I always write in
    order and don't allow timestamps on thru?
    no, I still need the scheduler, phooey.
  bandwidth
    - keep stats
    - display widget
  - midi tools: Hz -> midi mapper, channer allocator

Osc
  - does reaktor support timestamps?

research
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - draw antialiased lines and curves on os x
  - investigate hs-plugins and xmonad to see about hs plugin possibilities
    xmonad just recompiles the whole app
    I could actually do that at first too
  - learn about hs gtk for reference

future
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
