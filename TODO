LEGEND
  - todo; + in progress; * done; / obsolete, do not want, or can't repro
  ? open question; . note or observation

UNSORTED
  * scripts 'debug' and 'opt' to compile logview and seq, and run seq
    I need a way to tell if logview is running.
  - If I merge Derive.Note.render_of with Derive.Control.signal_wanted, I
    think I can get rid of Derive.state_wanted_track_signals.
  - Perhaps each score should also save the MIDI performance of the root
    block, along with the date / patch.  That way I can run a diff on the last
    good performance and if it's different, and know what version of the app
    produced it.  Git-style commit IDs would be more suitable for this, but
    dates should be good enough for now.  Or I need a darcs tag.
  * why only one cycle in 'nkam 2' in test/gamakam?
  * pitch-trill and control-trill should just be named trill, it's confusing
    to have to set different env values
  - use tr^ and tr_ starting high and low, instead of tr1 and tr2, starting
    unison and neighbor?
  * also high and low should be an environ arg
  * fix Speed starts mess:
    . Be more consistent about whether Derive.Call.Speed functions include
      the end time or not.
    . fixed bug where trill would create a transition on the end when it gets
      a score time speed.
  * Signal render is inaccurate when it depends on the tempo.
    . This is because signal render uses in_real_time, which causes RealTime
      using calls to derive differently.
    . The only reason it works when the tempo is set once at the top is that
      it then reuses the signal, just passing a constant stretch.
    . To be accurate, I'd have to render with the tempo, and then unstretch
      back to ScoreTime.
    . If I do this, I might as well get rid of the separate track signal
      derive, and piece together the sliced fragments.
    * Signal.unwarp function to unwarp the x samples of a signal.
    * update Derive.Control.put_track_signal and stash_signal to stash
      a signal, unwarping if there's a non-id warp
    * update Derive.Control.stash_signal to unwarp and stash signals for
      sliced fragments.
    * note track signal
    * Collect mappend has to merge the fragments, and be careful to avoid
      leading zero samples.
  - LRuler.inject, opposite of extract, replaces sub-block rulers
  - calling a block with a %tempo = x in the block title gets messed up timing
    . Perhaps because the block deriver then puts on another tempo=1 track,
      and it winds up with two tempos, and Tempo.with_tempo says "no two tempo
      tracks".  Or maybe not, since a tempo=1 shouldn't have any effect.
  - I want to use a library of basic patterns in multiple scores.  Rather than
    just hardcoding a bunch of global calls, I should be able to load
    a namespace, and have block calls dispatch to it.  This is different
    from just loading a copy: it loads it anew each time, and doesn't save
    it with the score.  This is like the 'import' idea, except the library is
    in score, not code.
  - If I want randomized signals, maybe I should have
    Derive.randomized_control_at that looks for a corresponding <>"-rnd"
    signal for range.  E.g., each instrument should switch to noltol at
    a different time.
  bali
    - cipher scale is still more convenient than absolute when dealing with
      one or two instruments.  Maybe I should use a base-octave var instead
      of kantilan and pemade variations.
    kotekan ornaments
      - norot
    wayang in octaves
      . I could do it with >wayang-both that emits >wayang-p and >wayang-k. Or
        just call the score twice, once with transpose +1 oct.
  india
    * factor dip and dip_c?
    * semi-tone dip.  This is like 1 cycle kam.  In fact, it might be useful
      to have a kam version where the speed is in number of cycles.
    - It would be possible to implement a general purpose initial-hold
      transformer by mapping the samples, to e.g. lengthen the first one and
      compress the rest to compensate.
    - kam^ and kam_ that tweak their speed instead of ending early
    - Can I have ornaments that affect the tempo?  This would be another way
      to control kam ending.  But it would require a separate pass to extract
      tempo modifications.
    - janta.  Isn't this just Lift?  It's fingered, right?
    - overshoot "curve" for 'smooth': over2 over3, depending how far over
    - ornaments can use more controls than just 'dyn', e.g. bow pressure
    - instead of hardcoding specific times, I should say short, medium, long,
      which can vary and have some randomization
    . Think about a way to sequence ornaments:
      . seq x; y; z to sequence ornaments, does this make sense?  Or I could
        see each note has having attack, middle, and release "slots".
        I might need something more sophisticated than just overwriting
        parts of the signal.  Also I want more natural transitions.
      . Many ornaments also depend on the previous pitch, or at least start
        there.
      . The note call is for ornaments that decide their own scope.  The
        control calls are for when you want to place them directly.
    Raga
      - Support arohana and avarohana by treating them as enharmonics
        Is this really a good idea, since they aren't anything like
        enharmonics?  Maybe I should just use the flip-enharmonic key, but
        keep the concept separate.
        . I could keep it at the Cmd level by remembering the last entered
          pitch and defaulting this one based on it, or I could try to put it
          at the Derive level too by having the pitch itself be based on the
          previous one.
        . Putting it at the derive level seems really hard and unreliable, so
          I should have separate symbols, e.g. 4r^ and 4r_ for up and down
          variants.  For western modes this isn't necessary since the notation
          is already absolute.

  - keys to turn play speed up and down
  more scales
    - wendy carlos' alpha, beta, gamma
    - overtone series
    - add ratio transpose single, that multiplies hz
  - generic way to parse a note to a Theory.Pitch, and back
    . If I add
      scale_parse :: Pitch.Note -> Maybe Theory.Pitch
      scale_show :: Theory.Pitch -> Maybe Theory.Note
    . Do I need the key?  This may have problems transposing octatonic in
      *twelve.

  + recent tends to collect pitches added via edit input, but since they have
    a specific pitch they're not useful.
    . Maybe I should have a separate recent queue only for transformers, and
      the generator recent is only one slot.  That way I can still repeat the
      last note call.
    - I'm still not sure I want this, since it seems like I want to repeat
      generators too.  But how to tell wanted ones from unwanted pitch ones?
  - After a rederive, it still takes a Cmd to free up the memory.  Who is
    holding on to it?
  - Composite 0 dur notes still not quite right, controls come too early.
    Maybe I should just abandon the idea of trying to make those 0 dur notes.
    What is the point of a 0 dur note?  The score has no explicit duration,
    and the eventual performance has some arbitrary short duration.  This
    corresponds to midi instruments whose envelope ignores NoteOff.
  - add edit and windows menu to all apps
    There must be special OS X support for these
    Apparently not?  iTerms is defined in English.lproj/MainMenu.xib
    https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/WinPanel/Tasks/UsingWindowsMenu.html
    But it doesn't say how to add the Window menu.

  - %sus-abs=-.x is not quite right for detached, because it should scale
    a bit for shorter notes.  E.g. it's absolute but scales down to 0 below
    a certain threshold.
  calls:
    - Sometimes tick makes more sense as at attribute of the previous note, or
      perhaps a freestanding ornament, since it can happen or not on a repeat.
    - 'u' and 'd' have a problem with long notes because pitches can only be
      transposed so far.
      . If I knew how far a pitch could be transposed, I could clip the end
        time to the bottom pitch.  But I don't.  Maybe pitches should be
        transposable infinitely far, but emit a -1 NN signal when they cross
        the boundary?  Or would this hurt error reporting?
  vsl
    . Legato attack scale control affects the crossfade level of interval
      samples, experiment with that.
    . figure out how perf reps work, and how I should handle them
    - make sure perf_upbeat_repetitions are consistent
    - make sure grace vs. grace.updown is correct
    attribute groups:
      . bass clarinet has nv without vib
    - should be able to select the most appropriate sec# dyn given
      +cresc or +dim on a note.
    - Figure out how to map continuous controls, and crossfade.

  - network midi doesn't seem to handle abort?
    playing the second time doesn't happen
  - I have a feeling like FM8 doesn't obey ResetAllControls
    Maybe I should extend Midi.Interface.note_tracker to keep track of
    used CCs to issue resets for them.  Some reset to 1, e.g. cc2 and cc7,
    the rest reset to 0.
    But filtering the midi shows dyn controls mixed into both channels.
  - Pretty on a lot of events causes a stack overflow
    Need a reproduction.
    I should extend Util.Format so I can use it for Util.Pretty.
  - if I added the cmd name before running the cmd, I could put it in the
    error msg when an exception is caught.
  - There are still some cmds without names, who are they?
    Do some logging to track them down.

MILESTONES
  0.1
    * support diatonics, enharmonics, and symbolic transposition for church
      modes, modes of limited transposition, and exotic scales
      (e.g. octatonic a-h)
    * record chords
    + integration
    + just scales, and other ratio-oriented scales that use letters and
      accidentals
    - complete Idiom.Wind, experiment with the Idiom postprocs
    + bring back negative duration / arrival beats
    * scales and keyswitches
    / efficient thru
    * tracklang complete with set of basic calls
    * better REPL situation
    / midi record
    / dense / efficient control signals
    * derive cache
    * symbolic score
    + save undo history / incremental save - more extensive testing
    + solution for audio, plugins, track bouncing, etc.  ardour / reaper + MTC
    + jack support on linux
    / simple csound backend
    * lilypond backend: good enough to render viola-sonata
    * documentation
  1.0
    - stable api
    - solution for local data / code
  future
    - non-realtime synthesizer: doc/dev_notes/synthesizer
    - horizontal layout
    - mouse oriented signal editing
    - Unify environ, controls, and pitch signals by making signals of
      arbitrary type.
    - print scores
    - include audio inline, so I can write signal transforms like event
      transforms

----------------------------------------------------------------------

documentation
  - update screenshots: doc/img/ly-example.png
  - Publish haddock with http://documentup.com/feuerbach/standalone-haddock
  call doc:
    - I could go look through arg docs for controls and list all the controls
      that have someone listening to them in a certain scope.

block composition
  - I do a lot of appending a block along with its ruler, I could have
    a single cmd to do that.
  - A more radical approach would be a block mode where the block calls are
    simply additive, and their duration doesn't matter.  This would mean I'd
    have to edit the tempo on the subblocks though, which in turn means it
    couldn't vary independently.
    . Could do this with a block call that acts as a note transformer, which
      simply pastes together sub-blocks.  I'd still want to cache the
      sub-blocks if possible, unless I do the block-range caching thing.
      Another bonus is I could probably get next/prev events working across
      block boundaries this way.  Maybe this could be used as an integrator
      input.
  - tempo composition is problematic because it means you can't change the
    length of a block from within the block.  So slowing down one part will
    speed up another.  How can I get local tempo like I want?  Or just edit
    the global tempo?  Unfortunately it's much more convenient to edit local
    tempo.  Maybe I could do a non-compositional tempo that simply overrides
    the caller, or rather multiplies with the caller.
    This means the call event is now longer than its duration would imply,
    and to fix that I need to have the child tempo modify the parent.  So
    effectively I am just modifying the global tempo, only providing a nicer
    syntax.

    This technique really is non-compositional: you can't have more than
    one call at once.
    Actually, I could: tempo track looks at calls in note tracks, gets
    sub-blocks, strips out the tempo tracks.  Then multiplies those signals
    with its own.

    Or I could just make it easier to edit the global tempo:
      * when you click on the parent, show selection pos on the child too
      - show derivation of child inside caller, I think I want to do this
        anyway, but it's hard, how do I fit all that stuff in?
      * merge child rulers with parent?
      But it still seems a bit awkward because I do want the tempo associated
      with the music, e.g. when I play by itself.  On the other hand, if the
      block repeats do I want the tempo to repeat as well?  Sometimes yes,
      sometimes no...

incremental save / git:
  + try saving individual events for incremental save
    Seems to be just as slow as full save, probably most of the time is in
    the call to git.  Test again with larger tracks.
  - wrap operations in a lock file
  - make sure things are ok if it fails at any step
  - I don't think Ui.State needs to emit CmdTrackAllEvents for cases where
    diff will catch it.
  - See if git's delta compression understands binary and can compress
    tracks.  Otherwise, would it be worth helping it by e.g. separating
    each event with a newline?  But then it makes serializing events more of
    a hassle.
  Git docs: http://progit.org/book/ch9-2.html

integrate / integration:
  - attrs that the instrument understands can turn into +attr calls, if
    they're not in the CallMap, e.g. save/test/wayang
  - adding a +soft stroke means it gets both less dyn and +soft again, so
    it's extra soft
  - bug: can't delete a derived track, it just gets regenerated
  - bug: can't undo past a integrate create, it just creates a new one
    Maybe I could not record the integrate step?
  - bug: create tracks, remove <, re-add <, does it work?
    Removing < should break the integrate links.

  - Convert.Tracks should mirror TrackDestination structure.  Or
    parameterize TrackDestination?
  - Figure out how multiple levels of track integration work.
  - If integrate is committing changes to a track, can that bite me if
    a "canceled" derivation comes through?  Think about this later.
  - What if an integrate wants to produce a note transformer track?  I
    think that's currently impossible.
  - quantization

lilypond:
  - warning if ly-prepend or ly-append is being omitted due to a chord
  - Maybe code events with a voice should go in the voice requested rather
    than mixed into the first one.  E.g. would have fixed grace notes.
  - one track has voice, the other doesn't, causes a "can't advance time
    backward" error
  - Support ly-append-first and ly-append-last for zero-dur notes.
    . First come up with uses for them?  Or do it just for orthogonality?
  - code events in >ly-global can be distributed to all staves
    Otherwise I have to remember to add e.g. ly-key to all staves manually.
    . But ly-key is no good, I really do need to set the key.  I think I have
      to break up the block.  Why can't I do assignment more easily?
    . Well, I have to grab a deriver to dynamically scope the new value around.
      Unless I let a deriver mutate the environ, then it has to be nested.  If
      a deriver can mutate, then events have to be evaluated in order.  Of
      course, they already do for controls because of the previous sample.
      And since it's unset at the end of the block, block caching still works,
      the same way as for previous sample.
    . On the other hand, I think I want to encourage nestedness and it should
      be easy to split.  The only reason viola-sonata has huge blocks is that
      it's a midi import.
  - Derive.Call.Lily needs a naming refactor since there are too many vaguely
    named flavours.
  - I need some way to hide rests.
    Add magic bit of code that turns its rest r4 into s4.
  - If I can figure out the meter from just the name, then I can get rid
    of the awkward map with hardcoded meters.
    I could have parse generate the Meter and memoize it.
  - optionally emit the lilypond to display a compound meter
  - use Util.Format in ly output

negative duration / arrival beats:
  represent arrival notes differently
    . Instead of representing arrival notes as the sounding time plus
      a negative duration, I could represent them as a start time plus a flag.
      If the flag is set, it's considered an arrival note and the trigger line
      is drawn at the bottom instead of the top.
    pros:
      1 Cmds work the same for negative and positive durations, I don't have
        to do any special checks for overlapping with a following negative
        event.
      2 I can have a note arrive and another depart from the same point, e.g.
        trill up to a note.
    cons:
      3 The encoding seems not as elegant.  I can still do it with negative
        durations, but now the negative is just a flag, rather than
        representing the actual extent of the duration.
    4 This means that cmds work spatially rather than logically,
      i.e. I'll need a separate "set beginning" cmd since it becomes set
      duration for negative events.  I don't know if that's a pro or con, but
      it feels like a con since I need more cmds.
    #1 might not be compelling if I've already done the work to get them to
    work, but if it's buggy or turns into continual for for every cmd then it
    becomes a big deal.

  - ensure inversion works (it should slice >start <=end)
  - ensure redraw works
    I have to make SymbolTable wrap text above too.

external
  parsing "1r" instead of "1s" gives a "unexpected eof" error msg, it should
    say 'r' was an unknown suffix
    Can't get attoparsec to consistently report an error.  Kind of hard when
    it always backtracks.
    - Need to add <||> to attoparsec.
  chorded keys are not getting the proper pitch bend
    It's a pianoteq problem.
    + Reported to pianoteq, said they'd fix it in the next release.
  - problem with pianoteq: if the same note occurs on two channels, one
    will be dropped.  Report to pianoteq.  I could work around, but it won't
    occur with real multitimbral instruments anyway.
  + send a patch to improve Random.Shuffle?
  - patch for hsc2hs for #alignment
  srcloc_annotate pragma
    I think a ghc pragma is needed.
    - read up on how jhc does it
    - ask ghc-users if it's a good idea
    - figure out how to implement pragmas in ghc

local: plugins:
  - ghc can now unload code: http://ghc.haskell.org/trac/ghc/ticket/8039
  - might be relevant: http://hackage.haskell.org/package/dynamic-loader
    http://codeutopia.net/blog/2011/08/20/adventures-in-haskell-dynamic-loading-and-compiling-of-modules/
  - to do per-score code, I can put it in Local.Score.<namespace>
    Convert to module name by replacing -x with (upper x) and capitalizing the
    first letter.
    Then when you load a score, incorporate the static config from that
    module.  Shakefile can link in the local modules under the right name.
    . If it gets to be too much overhead to link on every single build, then
      I can load dynamically at runtime.
  - Either dynamically load local inst definitions and local StaticConfig, or
    auto-generate the link file Local/Instrument.hs.
  - come up with plan for reloading inst config and static config
    Really what I want to be able to do is recompile the static config
    incrementally, relink it with the main binary *quickly*, and restart the
    app with exactly the same state.  This should be a lightweight operation,
    so it's feasible to edit some code, press play, edit code, and play
    again.  That means a full-on serialize restart is out, because the cache
    could be quite large.

    Of course, you want this stuff in a library so it can be reused across
    projects, so you can put it all in Local/.  Then the song state would
    have a (hopefully minimal) linkage from hs namespaces to the tracklang
    namespaces.

    So with hs-plugins: The static config is considered a plugin.  You edit
    Local/Config.hs, or edit other files in Local/.  It detects the change,
    regenerates Local/Config.hs, recompiles and reloads it.  Then the
    responder is called again with the new static config.

    So I need to be able to re-initialize the responder with a new static
    config.  Actually, the bits I care about are the call map and the cmd
    map.

cleanup:
  - update shakefile to use new system calls and logging levels
  - if I add an Alternative instance to Sig.Parser I can write arg parsers
    like 'Sig.many xs <|> Sig.many ys'.  I think.  If I wind up with something
    else like Derive.Call.Val.num_or_pitch it would be worth trying out.
  Format3
    . Converting Pretty to Text is blocked on this.
    . Rethink how indent breaking happens.
      Maybe indent should be a flag on SoftBreak
      If pre is null, then maybe I should indent to the next level, e.g.
      [(0, ("", "a")), (2, ("", "b"))]
    . The problem is that 'text <+/> indent 2 (...)' behaves unintuitively:
      the indent happens after the newline.  But if I put indent around
      the whole expression, then because indent is also break priority, the
      breaking is wrong.  So I want to say break + indent in one word.
  convert to Text:
    - Log.debug etc.
    - Pretty.pretty
      For this I need to extend Util.Format to be a simplified prettyprinter:
      - monoidal interface, not monadic
      - write text, set indent for expression, insert soft break
    - Derive.throw
    - Ui.Id
  - I could make the fltk interface clearer by putting c_interface.cc into
    fltk, and then putting all the types it depends on in one header.
  - There's a lot of duplication between State.TrackEvents, Call.TrackInfo,
    and Derive.CallInfo.  Can I factor out the common bits?
  - Update.BlockSkeleton sets Block.Status, and so does Update.BlockTrack.  If
    I merge status update into skeleton updates I can take Status out of
    Block.DisplayTrack.
  / move src into src subdir.  Then I don't have to do hacks in the shakefile
    where I only recurse into [A-Z]* dirs.  That's not exactly a big deal
    though.
  / split Ui.State into separate modules for views, blocks, tracks, etc.
    put into Ui.State.* and re-export from Ui.State
    . Actually the giant module isn't so bad and it's stopped growing.
  - split up CallInfo depending on type
    I got started but was discouraged when it came time to write
    GetLastSample, maybe I should make another go.
    Note tracks can't get a GetLastSample at all.
  - It would be more efficient to move events around if their controls were
    normalized to start from their beginning, so that you never have to modify
    the signals.  Of course, it's only worth it if events tend to get moved
    more than once.
    . noltol moves events with Score.move, which is really inefficient.  Think
      more about making event signals relative.  It also means I don't have to
      move signals that are never used.
    . However, this is bad for global controls, currently they can just be
      directly put in the event.  It seems a shame to have to copy a slice for
      every event.
    . Perhaps just store a control offset which the performer and signal
      lookup functions then have to take into account.
    . Maybe generalize to have a TransformedSignal !Control !Shift !Stretch
      Don't I already do that in TrackWarp or something?
  - Think about some way to formalize the identifier restrictions, currently
    it's only enforced in the tracklang parser.

    p_ident applies to: Attributes, Control, PitchControl, ScaleId
    Maybe it's enough that the parser restricts them?  That means no one
    will bother creating e.g. a bogus control name because it could't be used.
    Call names are explicitly anything-goes.  BlockIds should support at
    least some of it if they are supposed to be interchangeable with other
    calls.

    On the other hand, I don't think I care much if idents can have wacky
    names, they just won't be nameable from the tracklang.
  - storing TrackEvents without duration would make maintaining the
    no-overlap invariant easier.  E.g. have explicit 'off' events, otherwise
    each event extends to the next one.  It means after merging I have to
    clear redundant offs, but that's easier right?

performance:
  - Do profiles again with Event.event_text :: Data.Text instead of ByteString.
  scrolling through giant blocks is slow
    - drawing is stil slow, I'll have to look at the fltk layer
      It happens when the block is wide.  Use test_block to see if it's just
      fltk.
      . It's fltk.  Not alpha draw though.
      Scrolling is weirdly chunky near the top when fl_scroll() is on.
      Curiously it doesn't seem to help at all.
    - Would it be faster to call fl_scroll once for all the tracks?  I could
      also theoretically call find_events all at once too, though that
      shows up low on the profile, so maybe it's not a big deal.
    . The thing is, it seems like fl_scroll doesn't actually help scrolling
      speed at all.  Maybe all the time is spent elsewhere?
  - look into Debug.Trace.traceEventIO to see how long various things take as
    in http://www.yesodweb.com/blog/2012/10/future-work-warp
  efficient signals
    - make Ui.Events into 'Map ScoreTime (Event | Chunk Signal)'
    - collapse chunks of adjacent 'set' calls into a Chunk
    - track_derive on a Chunk just returns the contents
    - fltk event render should detect too dense events and omit them, rely
      on the signal render
    - UI edits should see the Chunk expanded out as Events.  Inserting an
      event should modify the chunk or split it depending on if the inserted
      event is a set call or not.
  cache
  Cmd
    - If a msg aborts or doesn't run any cmds, don't bother to run diff.
      Except that hardly ever happens if I do shortcut thru.
    - cache track cmds for each track, update when the track title or skeleton
      changes
  Derive
    - parallelize derivation
    AppendList / MergeList for Derive.Stream
      - switch to AppendList and try to get garbage down
        Avoid copying sublists returned by block calls and cache hits
      - play from cursor is a linear scan on all events from the beginning,
        seems like this would be faster if I could skip chunks.
      - see if a Merge constructor can reduce copying
      - can I cache length and range in AppendList?  does it matter?
      - insert parallelism?  maybe the evaluator can do that when it sees
        Merge?
    - lazy signals
      - check out 'at' and 'bsearch' occurrances and see if they can use tails
      - There are lots of lookups in the tempo map
    - see if making a version of Derive.local that's non-monadic in the
      modifier has any effect on performance
    - to get arrival beats to work right with the control track, I think I can
      make the 'set' control track call set from (prev, cur) instead of just
      cur.  It will make simultaneous samples, but they should be ok.
    derive cache
      - can I cache long blocks by slicing them if they're >n?
      - c_block should only cache if the block has > a certain number of
        events.
      - I won't rederive cached generators if they have control damage outside
        of the event range.  But there's nothing stopping a generator from
        reading ahead or behind... come up with some kind of solution for this.
    - fair amount of garbage generated by SignalBase.bsearch_above, I think
      this is because it has to box the values when it pulls them out.  But
      it's really just comparing to a Double, so I should be able to do the
      operation unboxed.  But decide about lazy signals before going nuts on
      this.  If I revert to linear search then none of this is necessary.
    - at_linear is called a lot by compose, by compose_warp, by d_warp
      can I make this more efficient?
  Perform
    / packed midi, encode to storable vector
      last step of performer is to compact into vector
      but I'm not sure this will much help
      The main thing is how to encode the device.  I think I can hash it.  Or
      use OS X persistent device ID?
      how many msgs in e.g. the ptrio?
        127130, [pno 9205, flute 63748, clarinet 54177]
        5367 for bloom
        peak for 246114 msgs: 46mb for int, 38.7 for int, 38.7 for w64

symbolic score
  some way to get symbol feedback instantly to make it easier to compose them
    . But it calls SymbolC and I ran into a problem where linux ghci can't
      link FFI-using functions.  Ask on glasgow-haskell-users.
    - I can either have a separate app, or use the special Status trick.
  - namespacing?  don't worry about it for now, if I need it later it can be
    entirely at the haskell level, I can use the per-song config to import
    namespaces
  - feta's tr symbol looks bad especially when small, is there a better one?
  - find or make a font with jian ti symbols?
  - find or make a font with gong che pu

fltk:
  - If I want to draw multiple signals together, I need a line or polygon
    + gradient function.  Maybe I can get ahold of the OS X graphics context
    and directly call cocoa functions.  For that to work on linux, I think I'd
    have to do the same for cairo.
    . Or perhaps I should just switch to OpenGL?
  drawing artifacts on retina:
    . Some of this may be fltk bugs.
    - tops of tracks and the tops of track text boxes still get gunk, visible
      when scrolling horizontally
  - Should fltk collapse adjacent dividers?
  track titles
    - Grow the window when the title grows past it.
    - Grow text past edge of window, when I resize the window the text keeps
      growing with it.  But it doesn't expect that size, and doesn't clear
      when deselected.
    - Type into track text on the right side, then expand the window so it can
      be visible.  It doesn't redraw the newly-revealed bit correctly.
    - If I wrapped track titles I could see the entire thing, but at the cost
      of using more vertical space.
  - There's a focus bug, but I'm not sure how to reproduce it.
  + can I get fltk to omit the jellybean buttons on the window?
    . Yes, but requires hacking fltk.
    . Completely disables resizing.  Apparently this is hardcoded.
  - some way to scroll that's not the scroll wheel
  - I could set certain Symbols to stretch to the length of their event, this
    would yield a nicer looking score.  But it would mess up the bounds
    detection.
    + gmail: subject:(scaling text)
      But it's OSX only.
  / rethrow c++ exceptions as FltkError
  - factor scroll redrawing into a single class
  / draw arrows in SkeletonDisplay.cc properly meh, they look ok
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  incremental redraw / scrolling
    I don't like the current situation of incremental redraw and scrolling.
    It's also buggy, i.e. one pixel difference between scroll and redraw.
    Get rid of damage and redraw everything every time.  Then I have to make
    it fast to fetch the data for one screenful.  What makes that slow
    currently?
  Track
    / dividers can have separate color for upper part, for collapsable tracks
  + Why does seq sometimes leave a app menubar on quit?  Do other fltk apps
    do that?  Yes.
    . It has to do with starting from the cmdline, starting with 'open' doesn't
      have this problem.
  + Disable application persistence for fltk apps:
    http://oleb.net/blog/2011/07/whats-new-for-developers-in-lion-part-1/
    http://developer.apple.com/library/mac/#documentation/General/Conceptual/MOSXAppProgrammingGuide/CoreAppDesign/CoreAppDesign.html#//apple_ref/doc/uid/TP40010543-CH3-SW26
    Can then re-enable ~/Library/Saved Application State.

  control track, render signal
    - render option: solid with color gradient
    - combine multiple signals, e.g. one controls xpos, one controls color
      I could combine pitch and dyn.  This is appropriate for the note track.
      . I'm pretty sure OS X can do this, as can cairo, so I would need to
        figure out how to get direct access to that API.  I could get rid of
        the awful alpha_draw.cc hack while I'm at it.

logview:
  - Logview: adding new log msgs causes the status bar to shrink back to one
    line, even though it should be wrapped to two.
  - Logview got some kind of file locked error, presumably trying to track
    a rotated log.
    . It happens if the write handle is still open, for some reason
      Posix.getFileStatus then gets openFile: resource busy (file is locked)
    . Maybe it's when reopen tries to open the file and it's already open.
  - can I get the standard edit menu and copy/paste?
  - haskell and c++ use the same machine readable format
  - tabs are not lining up properly
  - option to wrap lines or not?
  - hide or display various attrs: date, file, function, ...

Ui:
  Track
    - benchmark large TrackEvents
    more compact implemnetation than Data.Map?  profile first!
      - priorities: memory efficiency, persistent, merge speed (insert many)
        shallow tree of dense chunks?
        can I take advantage of non-overlap?  [(pos0, data), (pos1, end), ...]
        data Event = Event String StyleId | End | ControlVal Double
      - I think memory efficiency is more important than modification speed
    dense sampled signals
      - efficient storage, preferably as a Signal so no conversion is necessary
      - display dense signals: omit text and trigger lines when zoomed out

test:
  - try writing criterion tests for midi performance and derivation
  complete quickcheck derive testing
    I switched back to Double for RealTime, but this means the roundoff errors
    are back.  Use quickcheck to repro them.
    + make a simple deriver that creates event and midi output skeletons
    - integrate quickcheck with generate_run_tests.py
    - assert that the reduced deriver output equals the simple deriver output
    - basic pitches: If the score was created with notes aligned to note
      starts, then every NoteOn should have the appropriate key, there should
      be no pitch bends, and "same note" should be the only reason for
      a channel split
    - basic controls: Given randomly placed control events, notes have the
      correct control curves.  Don't worry about times or midi.
    - slicing: Given some simple note transformers (tuple, place, ...),
      pitches and controls are still associated with the right notes as above.
      Don't worry about times, just that the right notes and the right
      controls.
    - block call property: a couple levels of nesting for block calls, notes
      still have the expected pitches and controls as above
    - inversion: as 'basic pitches' and 'basic controls', but controls are
      below the note tracks, results should be the same
    - stack: generate nested events, check that stack is as expected
  - count number of tests in addition to checks within each test
  - use generics or Foldable or something to write a generic StructEqual

midi record:
  - implement
  . Ideas for editing recorded MIDI:
    . control: realign attacks, smooth or sharpen attacks.
    . pitch: retune intervals, fix wrong note or add notes, change portamento
      speed.  Add, widen, or narrow vibrato.

REPL: repl:
  - repl should understand --
  - only write history when the cmd succeeded
  - command to open the haddock for a module
  - haskeline sucks for long lines, add multiple line editing?
    really I'd prefer plan9 style esc then edit
  - is Cmd.Lang.Fast now obsolete?
  - can I get local variable bindings (let x = ...; y <- ...) to work in the
    REPL?
  - tab completion for symbols like in ghci
    I'll need a list symbols cmd which the repl automatically sends on tab
    completion.
  - :compile cmd that turns on compilation for everything except Environ
  - :browse to look in modules... can I use GHC.getBindings for this?
  - :module cmd to move evaluation context to a certain module, maybe I
    could also get rid of the need for Cmd.Lang.Environ to import everything.
  - new ghc api lets log_action catch ghci msgs, e.g. "Compiling xyz", added
    in f81e14bb14e459cdd59ea232f7c711827be85dd6

tempo:
  - Create tempo by "stretching", i.e. select start and end, and create tempo
    mark that will cause the start point to be played where the end point used
    to be played.

Cmd:
  - remove RawEdit?
  meter / timestep
    - timestep 64*2 skips two 's', because 's' is the minimum match
      skip should be ignored when the match is a larger rank than exists, or
      maybe step should fail.
  - Can I give Cmds their own state without putting it in Cmd.State every time?
    At worst I can have 'Map.Map String Dynamic'.

    Use existentials:
      data forall a. Cmd = Cmd {
        cmd_func :: a -> CmdT (Status, Cmd)
        , cmd_state = a
      }
    This means that such cmds have to be able to be updated after they are run,
    so the cmd lists have to be kept in responder state.  If I'm going to do
    that, why not have cmds optionally return a continuation and handle state
    that way?

      cmd msg = do
        state <- stuff
        return $ continue $ \msg -> do
          more stuff

    Or if I can put it in the monad:
      cmd msg = do
        state <- stuff
        msg2 <- yield Cmd.Done
        more stuff

    For module level, each module of cmds would have to export a bunch of Cmds
    and the responder retrieves the state and passes in another layer of
    StateT, or directly.  I supposed Dynamic wouldn't be so bad for that.  What
    happens when the module is reloaded?

  Cmd.Edit
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
      (merge will clip them to the next event)
  Cmd.Repl
    - functions to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.Play
    - Playback should have multiple lines when a block is derived multiple
      times. Have a set of playback selnums?
  copy / paste / Clip
    - clip block should use the ruler, just to make it easier to look at
    - clip could also copy over the skeleton
      It could use it to make sure the paste is compatible, but that might
      be more of an annoyance than a convenience.

  Undo / UNDO
    - shift [ and ] undo and redo zooms.  or one key to toggle last zoom?
    - Suppressed undo for val edit is surprising since I tend to do a lot of
      edits without leaving val edit.  Maybe don't do it for pitch val edit.
      Try going back to using the name to suppress, but ignore cmds with no
      name.
    - Add a "revert within selection" that searches backward for the last
      change within the selection.
    - Along those lines, should each block have its own independent history?
      This is supported naturally by the git layout since each block has its own
      file.  Wait, actually it's track, and that would be awkward if I undo one
      block and it changes tracks on another.  How do a say what position
      a block is in the history in that case?
      . One appealing thing is that I don't necessarily want things like config
        changes to be included in undo.
    - Visual display of undo history, because stepping back one-by-one is
      a bit of a hassle.
    - record view changes, at least zoom / scroll so it can be undone / redone
      separately

Derive:
  - namespaces for calls
    As there gets to be more calls, I may need to have a 'import x' which
    brings the namespace into scope.  Namespace could use tags, but perhaps
    tags should instead be derived from the namespace, e.g. prelude, bali,
    india.
  tracklang:
    - If I don't allow = in calls, I could write assigns without whitespace:
      x=y Is it worth it?
    - there should be a character that triggers a parse failure, which is used
      by invalid ShowVal instances like ShowVal Pitch
    - it's confusing how some calls expect env vals like 'x = 1' and some
      expect controls like '%x = 1'.
      . The obvious way to solve this would be to merge env vals and controls,
        but that's a big change.
    - Track caching is too fragile, if I add a track with scope over everything
      then I get no caching.  Instead I should cache the bottom note track, or
      perhaps every note track.  But that doesn't work because they're all
      sliced up.
  postproc
    - retune a note depending on the previous interval (e.g. sloppy pitches
      when playing quickly)
    - overblow emulation: a set of overblow ranges are defined, along with
      possible pitches for each one (fundamental and overblow harmonics).
      When a note moves from one to another, start a new note at the
      destination pitch and bend the decay of the old one to the fundamental
      or closer harmonic from the previous mode.
    - rambat damping emulation: notes ring on by default until they can be
      damped.  Damp at the first opportunity, where opportunity is defined
      as a break with no notes for a certain amount of time.  Can only damp
      two neighboring notes at a time.

  - consider track calls and block calls:
    note_track :: TrackTree.EventsNode -> Derive.EventDeriver
    derive_tree :: ScoreTime -> TrackTree.EventsTree -> Derive.EventDeriver
    I could use this to implement is-ly and no-ly, and also totally custom
    track types and block types.

  pitch calls:
    - accelerating trill
    - overshoot pitch call, e.g. indian style

  note calls:
    trills
      / hybrid where the initial part stretches, final part is absolute
    trompong / reyong:
      - trompong ngoret, actually I can use rambat tick
        But damping on reyong is different, you can just forget some notes.
      - split to ngembat, e.g.  λ 人 hmm, is there a reverse lambda?  Can
        I draw symbols reversed? 入 兩
      - various numpuk
      kilitan
        . What is the "core" of what kilitan is?
          Take a melody, and split it into multiple parts.  Each part has
          a limited pitch range, and when the melody is out of range, play
          harmonizing intervals, or move in contrary motion.
          Also, the melody is at a slow tempo, and kilitan elaborates at some
          integral multiple, using norot style patterns.
        . So I decide on how many parts, and steady state patterns for each
          part.  The patterns may have alternatives, or internal variations.
        . Patterns also have transitions to a new melody note, which occur
          before the melody note arrives.  The transitions may vary depending
          on the source and destination melody notes.
        . There are also cross-part variations, where neighbors must pick
          cooperating variations.
        . Also there may be ornaments that affect all the parts, e.g.
          232321612.  These are similar to cross-part variations, except that
          they should be signalled explicitly in the notation rather than
          being random.

        . Eval transformed deriver in flat time, to get events in ScoreTime.
        . Simplify notes to 'Melody Theory.Pitch | Ornament (Byong | DownUp)'
        . Ornaments become set patterns at the given time, different for each
          part.
        . Start with part 1 and for each note:
          . If it's an Ornament, emit the relevant notes verbatim relative to
            the current time, e.g.
              Ornament -> Part -> Time -> [(RelativeTime, Note)]
            Clip anything that would overlap the previous event, or the next
            note.
          . If it's Melody, generate harmonic points until the next
            non-Melody.  They are relative to the start of the call.
          . Start assembling notes from fragments.  Get the transition
            fragments based on the Part and the next Melody note, and if any
            line up to now, pick and emit one.  Otherwise, pick a continuation
            fragment based on the current Melody.  If it's a coordinated one,
            emit that separately.
          . Do the same for each part, except that the fragments that are
            chosen can be influenced by previous coordinated fragments.
        . Just emit open notes.  Damping is done with a separate postproc.

        . type RelativeTime = Int -- at harmonic rhythm
        . type RelativePitch = (Diatonic, Chromatic)
        . type Fragment = [(RelativeTime, RelativePitch)]
        . type Coordination = Char -- anything, just a key
        . type Fragments = [(Maybe Coordination, Probability, Fragment)]
        . type Part = Part
          { transition :: Pitch -> Fragments, continuation :: Fragments }

        - extend to work other scales
        - more graceful transitions between pitches
        - variant patterns
        - coordination across parts
        - damping, depending on speed
        - support kilitan/beat speed more exotic than 4/1

  control calls:
    - signal transformations: +, *, max, min
    - saturation limit, e.g. flatten sine wave but without clipping
    - continuous tempo warping for signals
      tempo: "2" -> "1", "2", cont: "2" -> "i, 1", should emit a bent line

pitch: scales: scale:
  scales / Derive.Scale:
    just intonation
      - interpolate between just scales in different keys
    - meantone
    - Interpolate between two scales.  The main thing is to establish a note
      to note correspondance.
    bohlen-pierce
      - Make relative scale.
    - retune a note depending on the previous interval (e.g. sloppy pitches
      when playing quickly)
      I think this has to be postproc.
    support scales that are different ascending vs. descending
      . Scales have two versions of each degree.
      - scale_input_to_note takes a previous Note arg, which it can use to
        guess the appropriate variant.
      - Variants have to have unambiguous names though, maybe 4n^ and 4n.
      - Use scale_alternate to switch a note between alternates, bind to the
        same key as enharmonic.  If there are no enharmonics, then fall back
        on alternate.

    - letter and jianpu but with implicit accidentals based on the key
  + It's a bit unpleasant how I have TwelveUtils for accidental and key using
    scales, then Scale.Util for simple scales, and then Just is its own thing.
    Can I unify things into one framework?
  intonation: think about how to do e.g. meantone melody, with just harmony
    . Do a postproc to analyze simultaneous notes.  If I use an attr to
      tag the melody, I can tune everyone else to it.  But how do I retune
      notes with non-trivial pitch curves?  Well, I could use a transpose
      signal to tell the pitch calls what's going on.  I think I might just
      need the frequency of the melody note.
    . Do an analysis pass, and insert environment that says what the harmony
      is.  Then pitch calls use that to tune.  Doing the analysis might be
      tricky since I have to extract a "principle pitch" from each event,
      but it might be useful in general to have an analysis framework.
  fancier pitch signals:
    - to_relative: This needs Note - Note = Semis.  I think I could just add
      a field in Scale, but I'm not totally sure I really want this.
    - Cmd.Lang.LPitch.to_relative: I would need to implement Scale.scale_diff
      but I'm reluctant until I need to_relative or something similar

Perform:
  - damper pedal causes all notes to extend until the pedal comes up, should
    the performer know about that?  Is there anything that this breaks?
    I don't think so, it affects channel allotment so notes could be
    improperly joined, but mixing pedal and multiplexing seems rare enough.
  - Perform.Midi.Perform: should be possible to lead keyswitches as long as
    they don't precede the previous NoteOn, since I think samplers will only
    switch on the next NoteOn
  Instrument
    - some kind of organized way to manage instruments and instrument config
    - some basic midi instrument defs for generic midi (dev, patch)

Instrument DB / browser:
  - browser has lots of empty space on the bottom
  - z1/virus-bass has UnknownMessage for initialization?
  - patch files could go in the Local/Instrument dir with the source?
    at least it should go in source control
  - colorize the info_pane so tags are easier to read
  - search lang supports quotes
  sysex
    z1
      - convert patches to larger pitch bend and send them back
      - I need control over which program and bank the patches go when they
        are initialized.  I can use the card as scratch space.
      - I also need to initialize a new multiset, and give the score
        a multiset config, or derive one from the midi config.
    vl1
      - test sending sysexes back
      - move patches to new format
      - figure out how to set category for builtin patches
        *word shorthand for category=word?
        but I want to use the inst name, not the score name...

OSC backend
  in doc/dev_notes/sythesizer
  - Write a simple supercollider instrument and try controlling that with OSC.
  - Even if reaktor and supercollider don't understand bundles, I could write
    a scheduler server that takes bundles and emits their msgs at the correct
    time.

jack: JACK: linux midi:
  bugs
    - something is still wrong, I get "no space in output port" and then
      corrupted output
    ? jack1 doesn't work at all: other clients don't see writes, until I quit,
      and then they get continuously spammed.  Apparently the jack_port_t*
      from the registration and the lookup are different.
      - Try stashing port from port_by_name port instead of jack_register_port.
  - does jack not support sysex at all?  Maybe I can't use it at all then.
  - Ensure that shutdown stuff is being called correctly.  I don't care but
    maybe JACK does?
  use jack transport
    I don't think I need to be the master.
    - When starting a play, call jack_transport_locate,
      then jack_transport_start().  The play then blocks on a lock which is
      released by JackSyncCallback when it gets a JackRolling state.
    - Register with jack_set_sync_callback.  JackSyncCallback sets a syncing
      flag, emits a Msg that forces the needed bits of performance, then that
      cmd must call back and reset the flag, at which point the sync function
      can return true.
    Then the next step is to test, and then figure out a way to get ardour to
    automatically set up a bunch of instruments and make MIDI in ports for
    them.

misc ideas:
  . Import or trace curve from a pitch tracker into the pitch track.
  - Staff notation represents chords well, but tracks don't.  Think of a more
    compact notation.
  - Why can't I write a 'tr' that generates pitch signal in some cases, and
    adds an attribute in others?  It would be redesigning control tracks so
    they are just note tracks that slice their children and apply
    a transformer to them.  I'm not sure that will coexist with the curve
    description language that control tracks currently implement.
    It would be interesting to get rid of track types entirely though.
  darcs to git:
    . https://github.com/purcell/darcs-to-git
    . http://darcs.net/DarcsBridgeUsage

planning / research
  cmj:
    - bezier-spline-modeling-of-pitch-continuous-melodic-expression.pdf
      Contact Bret Battey about PICACS: http://www.mti.dmu.ac.uk/~bbattey/
    - Wendy Carlos' tuning article: "Tuning at the crossroads", CMJ 11/1
  things for expressive music
    There needs to be some way for notes to affect surrounding notes.  For
    example
      . A trill might want to push the next note back a bit so it can complete
        its cycle.
      . Portamento might want to put controls points on a curve, so the speed
        a distance between pitches affects how quickly they approach, and
        quick notes will have less accurate pitch.
      . Gender tick affects the damping of the previous note.
      . If I control uses bezier curves, the curve is determined by the last
        control point of the previous and the first point of the current call.
    Other ideas:
      . Switch samples when played quickly.
      . Drum thing where successive strokes lose some energy.
    . Randomization is a first step, but true variation in playing is not
      random.  Things to study:
      . Tempo variation.  This is related to intentional tempo variation, but
        there should be slight tempo variations all the time.  This also has
        to do with higher level controls like rushing or lagging, and slight
        amounts of swing.
        E.g. some instruments may tend to rush when they want to be more
        prominent, or get louder.
      . Start / duration variation.  Related to tempo but at a lower level and
        less systematic.  Interpretation of staccato depends on surrounding
        tempo.
      . Dynamic variation.  Many instruments tend to get louder at higher
        pitches.  Tempo speed up tends to increase volume.
      . Pitch variation.  Some instruments tend to attack inaccurately and
        then correct.  Higher dynamics and tempo could make pitch less
        accurate.
  Composition of score fragments.  I think I want to display subderived
  notes within the call event.  And then some way to put edits on top of it.
  - spline curve interpolator: evoral/Curve.cpp, www.korf.co.uk/spline.pdf

  - If I implement a VST host or patch a DAW to accept VST controls like MIDI
    controls can I get low latency high res controls?
