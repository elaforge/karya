****

bugs
  * when replacing rulers, the track widths are lost
  * destroy_ruler doesn't remove the ruler from its views
  * plain numbers to set step is error prone in kbd mode
  * parse errors don't give position
  - paste deletes events before the paste area
    can't reproduce this
  * it's easy to create empty events which then give parse errors.  There's
    a conflict between delete and move and remove letter.  So don't move.

performance
  - random little hangs are annoying.  figure out what's going on.  GC?
  * pause before playing.  printing logs make playing too strict?
  - the full event loop is too laggy for midi thru, implement a fast path
  - cache marks and events from callback
  - will removing the style speed up event copying?

new pitch lang
  * implement pitch track as a separate control track
  - implement instrument track and lookup, put inst in environment
  - remove the old instrument track stuff
  - instrument attributes
  - modify note entry commands to write to both inst and pitch tracks

  - track collapsing
  - track muting
  - track merging


fltk
  * consistent drawing of abbreviated events so drawing isn't dependent on
    damaged area.
  * optimize: implement scroll redraw optimization
  - convert Selection to use the same format as hs, so it can show the cursor
    end specially
  - bug: selection redraw leaves gaps when dragging downwards
  - figure out how to have a minimal title bar in os x (win.border(0) removes
    it altogether)
    I can set something like kUtilityWindowClass in Fl_mac.cxx:Fl_X::make, but
    it doesn't get any kbd input
  - can I get the windows into an os x windows menu?
  - bug: doesn't redraw after switching monitors
  UI Msgs
    - can I capture os x two-finger drag events?
      yes, they're reported as FL_MOUSEWHEEL, so I should scroll on mousewheel
  Track
    / dividers can have separate color for upper part, for collapsable tracks
    - tracks have their own status lines, to report things like mute
  event track
    - "currently edited" event shouldn't be hidden by previous ones
  Ruler
    * mark text is abbreviated if there isn't enough room
  MoveTile
    - only capture drag on a plain drag with no modifiers

logging logview
  - logview needs scrollbars
  - don't store msgs in memory, don't refilter from begining
  - colorize (tid ..) (bid ..) (vid ..) etc.
  - implement clickable srcpos and StackPos
  - haskell and c++ use the same machine readable format
  - rename LogViewer -> LogView just to reduce confusion
  - LogView should use Util.Fltk

Ui
  - some kind of special highlight to indicate the active block
  - rethrow c++ exceptions as FltkError
  Controllers
    * pass signals as pointers, not copies
    - make sure very dense (e.g. sampled) signals are displayed and stored
      efficiently, but are still editable normally when you zoom in.
    - signal render support for indexed signal type, especially pitch
    - events store style as a uchar ID for consistency and memory savings
  Track
    * patch Data.Map to include toDescList
    - benchmark large TrackEvents
    - modify IntMap for Word64s, add toDescList
      - send patch to libraries@haskell.org

Cmd
  - cmd to give a view focus and bring it to the front
  - Cmd_test
  - the cmds that return anything other than Done are rare, have a special case
    for them and make most cmds return ()
  Keymap
    - check for key assignment collisions
    - support generic modifiers like any Shift, any Control, and Command
      (which becomes alt on a PC keyboard)
  Cmd.Edit
    * change note lengths
    - alternate finale-like note entry: hold down step key to set step and
      turn on edit mode, but only while the key is down
    - trackerlike note entry: entered events are all as long as the block
      (merge will clip them to the next event)
    - map selection through function
    - transpose selection
    - controller edit mode accepts two numbers and moves on, no spaces
    * nudge events
    - a legato command that always goes to the next note would still be useful
    - method edit works in controller tracks

  Cmd.Selection
    * drag snap to timestep
    * extend selection with shift-arrow
  Cmd.TimeStep
    - snap to event begin/end

  Cmd.Language
    - lang cmd stuff to load string serialized tracks for event cut and paste
    - an aux data input for the lang socket might be useful, to paste in data
      without having to quote it
  Cmd.LanguageCmd
    - some way to more easily type IDs, either the mangler adds a let for pbid,
      pvid, etc., or the mangler turns <foo> into <current/foo>

  Cmd.View
    - ViewBlock abstraction: collapse/expand tracks, mute tracks

  Cmd.Play
    - warn about unallocated instruments (Convert.verify)
    * make sure the whole stack is lazy
    - play loops
    * background derivation
    - start playing from top of displayed area
    - start playing from TimeStep before insert point

  Cmd.Record
    - come up with a plan for midi recording
    - implement simple midi underiver aka integrator

  Undo
    * implement undo and undo/redo cmds
    - figure out how to checkpoint just state diffs
    - add undo history to on-disk format

  Cmd.MakeRuler
    - functions to modify zoom levels and other mark attributes
    - functions to splice time or a Meter into a ruler

  Cmd.Freeze
    Play also enables record on the plugin host.  The host needs to agree with
    me about synth names, and have one recorder for each synth, so I can tell
    it which synths to record by name.

    After I hit stop, I remember the recorded time range and which instruments
    were active at the time.  On playback, I suppress the playing of synths
    that fall within a recorded range.  Also, when playback enters a recorded
    range, it has to send a msg to the host, saying where it is.  The host will
    have to be smart enough to select from the recorded clips and playback any
    cached audio in that range.

    To thaw a range, I remove it from the freeze map, stop suppressing the
    msgs, and stop sending the host msgs for it (or tell it to delete that
    range).

Derive
  derivers
    * control
    * tempo
      * multiple tempos per block
    * subblock derivation
  pitch
    * pitch signal rendered to midi
    - relative pitches, e.g. +5
    - pitch signal should be Signal (Method, Pitch) so that they can be
      transposed
    - alternate scales

  - block derivation memoization / caching
  - keyswitch support in midi thru
  - set instrument within note track, controller within control track
  - separate instrument track, as a kind of controller track
  - instrument aliases to make a shorthand for setting instrument, and also
    setting keyswitch on current instrument

  - display derived blocks
  - 3 way merge for derived blocks

Perform
  Player
    * flush midi output when I get a Stop
      * send patches upstream
  Midi
    - eliminate duplicate controller msgs
    * pitch signal rendering
    * support key switches

  Instrument
    - some kind of organized way to manage instruments and instrument config
    * backend-independent instrument def
    - some basic midi instrument defs for generic midi (dev, patch)
    - defs for z1 and vl1

  Signal
    - lazy implementation
    * implement Signal.equal
    - signal transformation derivers: +, *, /, min, max, ...
    * after implementing GUI drawing and transformation, reduce the
      proliferation of signal types
    - ensure that controllers are warped continuously by tempo

Instrument DB
  - search lang supports quotes
  - search lang supports - to exclude a term
  - original file goes in a tag, not the text
  - bug: discarded insts still in index
  - ability to edit tags, esp. add "favorite rating"
  - now that PatchTemplate is gone, maybe I can use a simpler storage format
  - standardized tags
  - put file in a tag so I can search on it
    I can also use it to create a *.txt file with custom info
  - explicitly allow merged patches, so I can get params from syx but send
    program change

Midi
  * implement midi merging for midi thru
  * a single msg input thread instead of one thread per input port
  bandwidth
    - keep stats
    - display widget

Osc
  - does reaktor support timestamps?

research
  - loading fonts in fltk, and drawing new fonts
  - subscribe to haskell-art
  - download sequencers and see how they ship midi reliably
  - draw antialiased lines and curves on os x
  - learn about hs gtk for reference

future
  - check out jack some more.  I don't necessarily support it in the beginning
    but should have an idea at least.
    Looks like I could use it for midi i/o, but what's the advantage over
    e.g. portmidi?  Maybe the ability to send midi to e.g. local apps in
    standalone mode?  Or would be be better to support vst?
  - sync via jack with e.g. ardour, rosegarden
  - vst interface
  - liblash would let me save plugin / jack configuration
