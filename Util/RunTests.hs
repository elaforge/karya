-- Copyright 2013 Evan Laforge
-- This program is distributed under the terms of the GNU General Public
-- License 3.0, see COPYING or http://www.gnu.org/licenses/gpl-3.0.txt

-- | Run tests.  This is meant to be invoked via a main module generated by
-- @test/generate_run_tests.py@.
module Util.RunTests where
import Control.Monad
import qualified Data.IORef as IORef
import qualified Data.List as List
import qualified Data.Map as Map
import qualified Data.Maybe as Maybe

import qualified Numeric
import qualified System.CPUTime as CPUTime
import qualified System.Console.GetOpt as GetOpt
import qualified System.Environment
import qualified System.Exit
import qualified System.Posix as Posix
import qualified System.Process as Process

import qualified Util.Regex as Regex
import qualified Util.Seq as Seq
import qualified Util.Test as Test


data Test = Test {
    -- | Name of the test function.
    testSymName :: String
    -- | Run the test.
    , testRun :: IO ()
    -- | Test module filename.
    , testFilename :: FilePath
    -- | Line of the test function declaration.
    , testLine :: Int
    -- | If given, this function is wrapped around 'testRun'.  Since there is
    -- no tear down function, each test requiring initialization will be called
    -- in its own subprocess.
    , testInitialize :: Maybe (IO () -> IO ())
    -- | This is an arbitrary classification added by generate_run_tests.py.
    -- It is prepended to the test name, so you can filter tests with it.
    , testType :: String
    }

testName :: Test -> String
testName test = testType test ++ "-" ++ testSymName test

-- Prefix for lines with test metadata.
metaPrefix :: String
metaPrefix = "===>"

data Flag = List | NonInteractive deriving (Eq, Show)

options :: [GetOpt.OptDescr Flag]
options =
    [ GetOpt.Option [] ["list"] (GetOpt.NoArg List) "display but don't run"
    , GetOpt.Option [] ["noninteractive"] (GetOpt.NoArg NonInteractive)
        "run interactive tests noninteractively by assuming they all passed"
    ]

run :: String -> [Test] -> IO ()
run argv0 tests = do
    args <- System.Environment.getArgs
    (flags, args) <- case GetOpt.getOpt GetOpt.Permute options args of
        (opts, n, []) -> return (opts, n)
        (_, _, errs) -> do
            putStrLn "usage: $0 [ flags ] regex regex ..."
            putStr (GetOpt.usageInfo "Run tests that match any regex." options)
            putStrLn $ "\nerrors:\n" ++ concat errs
            System.Exit.exitFailure
    runTests argv0 tests flags args

runTests :: String -> [Test] -> [Flag] -> [String] -> IO ()
runTests argv0 tests flags args
    | List `elem` flags = printTests True
    | otherwise = do
        when (NonInteractive `elem` flags) $
            IORef.writeIORef Test.skip_human True
        printTests False
        let (initTests, nonInitTests) =
                List.partition (Maybe.isJust . testInitialize) matches
        mapM_ runTest nonInitTests
        case initTests of
            [test] -> runTest test
            _ -> mapM_ (runSubprocess argv0) initTests
    where
    matches = matchingTests args tests
    printTests printOnly
        | null matches = putStrLn $ "no tests match: " ++ show args
        | otherwise = do
            unless printOnly $ do
                pid <- Posix.getProcessID
                putStrLn $ "\nRunTests: " ++ show pid
            mapM_ putStrLn (List.sort (map testName matches))

runSubprocess :: String -> Test -> IO ()
runSubprocess argv0 test = do
    putStrLn $ "subprocess: " ++ show argv0 ++ " " ++ show [testName test]
    val <- Process.rawSystem argv0 [testName test]
    case val of
        System.Exit.ExitFailure code -> void $ Test.failure_srcpos Nothing $
            "test returned " ++ show code ++ ": " ++ testName test
        _ -> return ()

-- | Match all tests whose names match any regex, or if a test is an exact
-- match, just that test.
matchingTests :: [String] -> [Test] -> [Test]
matchingTests regexes tests = concatMap match regexes
    where
    byName = Map.fromList (zip (map testName tests) tests)
    match reg = case Map.lookup reg byName of
        Just test -> [test]
        Nothing -> filter (Regex.matches (Regex.make reg) . testName) tests

runTest :: Test -> IO ()
runTest test = do
    putStrLn $ unwords [metaPrefix, "run-test", testName test]
    let name = last (Seq.split "." (testName test))
    start <- CPUTime.getCPUTime
    maybe id id (testInitialize test) $ Test.catch_srcpos
        (Just (testFilename test, Just name, testLine test)) (testRun test)
    end <- CPUTime.getCPUTime
    -- CPUTime is in picoseconds.
    let secs = fromIntegral (end - start) / 10^12
    -- Grep for timing to make a histogram.
    putStrLn $ unwords [metaPrefix, "timing ", testName test,
        Numeric.showFFloat (Just 3) secs ""]
    return ()
