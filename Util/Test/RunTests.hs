-- Copyright 2013 Evan Laforge
-- This program is distributed under the terms of the GNU General Public
-- License 3.0, see COPYING or http://www.gnu.org/licenses/gpl-3.0.txt

{-# LANGUAGE ScopedTypeVariables #-}
-- | Run tests.  This is meant to be invoked via a main module generated by
-- "Util.Test.GenerateRunTests".
module Util.Test.RunTests where
import qualified Control.Exception as Exception
import Control.Monad
import qualified Data.List as List
import qualified Data.Map as Map
import qualified Data.Maybe as Maybe
import Data.Monoid ((<>))
import qualified Data.Text as Text

import qualified Numeric
import qualified System.CPUTime as CPUTime
import qualified System.Console.GetOpt as GetOpt
import qualified System.Environment
import qualified System.Exit
import qualified System.Process as Process

import qualified Util.Regex as Regex
import qualified Util.Seq as Seq
import qualified Util.Test.Testing as Testing


data Test = Test {
    -- | Name of the test function.
    testSymName :: String
    -- | Run the test.
    , testRun :: IO ()
    -- | Test module filename.
    , testFilename :: FilePath
    -- | Line of the test function declaration.
    , testLine :: Int
    -- | If given, this function is wrapped around 'testRun'.  Since there is
    -- no tear down function, each test requiring initialization will be called
    -- in its own subprocess.
    , testInitialize :: Maybe (IO () -> IO ())
    -- | This is an arbitrary classification added by generate_run_tests.py.
    -- It is prepended to the test name, so you can filter tests with it.
    , testType :: String
    }

testName :: Test -> String
testName test = testType test ++ "-" ++ testSymName test

-- Prefix for lines with test metadata.
metaPrefix :: String
metaPrefix = "===>"

data Flag = List | NonInteractive deriving (Eq, Show)

options :: [GetOpt.OptDescr Flag]
options =
    [ GetOpt.Option [] ["list"] (GetOpt.NoArg List) "display but don't run"
    , GetOpt.Option [] ["noninteractive"] (GetOpt.NoArg NonInteractive)
        "run interactive tests noninteractively by assuming they all passed"
    ]

run :: String -> [Test] -> IO ()
run argv0 tests = do
    args <- System.Environment.getArgs
    (flags, args) <- case GetOpt.getOpt GetOpt.Permute options args of
        (opts, n, []) -> return (opts, n)
        (_, _, errs) -> do
            putStrLn "usage: $0 [ flags ] regex regex ..."
            putStr (GetOpt.usageInfo "Run tests that match any regex." options)
            putStrLn $ "\nerrors:\n" ++ concat errs
            System.Exit.exitFailure
    runTests argv0 tests flags args

runTests :: String -> [Test] -> [Flag] -> [String] -> IO ()
runTests argv0 tests flags args
    | List `elem` flags = printTests
    | otherwise = do
        when (NonInteractive `elem` flags) $
            Testing.modify_test_config $ \config ->
                config { Testing.config_skip_human = True }
        printTests
        let (initTests, nonInitTests) =
                List.partition (Maybe.isJust . testInitialize) matches
        mapM_ runTest nonInitTests
        case initTests of
            [test] -> runTest test
            _ -> mapM_ (runSubprocess argv0) initTests
    where
    matches = matchingTests args tests
    printTests
        | null matches = return ()
        | otherwise = mapM_ putStrLn $ List.sort (map testName matches)

runSubprocess :: String -> Test -> IO ()
runSubprocess argv0 test = do
    putStrLn $ "subprocess: " ++ show argv0 ++ " " ++ show [testName test]
    val <- Process.rawSystem argv0 [testName test]
    case val of
        System.Exit.ExitFailure code -> Testing.with_test_name (testName test) $
            void $ Testing.failure $
                "test returned " <> Text.pack (show code) <> ": "
                <> Text.pack (testName test)
        _ -> return ()

-- | Match all tests whose names match any regex, or if a test is an exact
-- match, just that test.
matchingTests :: [String] -> [Test] -> [Test]
matchingTests regexes tests = concatMap match regexes
    where
    byName = Map.fromList (zip (map testName tests) tests)
    match reg = case Map.lookup reg byName of
        Just test -> [test]
        Nothing -> filter
            (Regex.matches (Regex.compileUnsafe reg) . Text.pack . testName)
            tests

runTest :: Test -> IO ()
runTest test = Testing.with_test_name name $ do
    putStrLn $ unwords [metaPrefix, "run-test", testName test]
    start <- CPUTime.getCPUTime
    maybe id id (testInitialize test) $ catch (testSymName test) (testRun test)
    end <- CPUTime.getCPUTime
    -- CPUTime is in picoseconds.
    let secs = fromIntegral (end - start) / 10^12
    -- Grep for timing to make a histogram.
    putStrLn $ unwords [metaPrefix, "timing ", testName test,
        Numeric.showFFloat (Just 3) secs ""]
    return ()
    where name = last (Seq.split "." (testName test))

catch :: String -> IO a -> IO ()
catch name op = do
    result <- Exception.try op
    case result of
        Left (exc :: Exception.SomeException) -> do
            void $ Testing.failure $ Text.pack name <> " threw exception: "
                <> Text.pack (show exc)
            -- Die on async exception, otherwise it will try to continue
            -- after ^C or out of memory.
            case Exception.fromException exc of
                Just (exc :: Exception.AsyncException) -> Exception.throwIO exc
                Nothing -> return ()
        Right _ -> return ()
