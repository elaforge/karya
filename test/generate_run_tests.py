#!/usr/bin/env python
"""usage: output.hs test_mod1.hs test_mod2.hs ...

Collect tests from the given modules and generate a haskell module that calls
the tests.

The generated haskell module takes either '-list', which will display the tests
it knows about, or a set of string prefixes, which will run only tests starting
with one of those prefixes.

Tests are divided into "interactive" and "plain", depending on whether they
use certain interactive assertions.

-- TODO: support noisy and quiet tests?
"""

import sys, os, re
import hs_pp

def main():
    out_fn = sys.argv[1]
    test_fns = sys.argv[2:]

    test_func = re.compile(r'^(test_[a-z0-9_]+?)( =.*\n(?:\s+.*\n|\n)*)',
        re.MULTILINE)
    init_func = re.compile(r'^initialize ', re.MULTILINE)

    test_defs = {}
    init_funcs = {}
    for fn in test_fns:
        src = open(fn).read()
        line_map = [m.start() for m in re.finditer('\n', src)]
        def offset_to_line(offset):
            for i, off in enumerate(line_map):
                if off > offset:
                    break
            return i+1

        test_defs[fn] = []
        for match in test_func.finditer(src):
            test_defs[fn].append((match.group(1),
                offset_to_line(match.start()), match.group(2)))
        if init_func.search(src):
            init_funcs[fn] = '%s.initialize' % path_to_module(fn)

    out = open(out_fn, 'w')
    out.write(hs_template % {
        'argv0': sys.argv[0],
        'imports': '\n'.join(map(make_import, test_fns)),
        'all_tests': ',\n    '.join(make_tests(test_defs, init_funcs)),
    })


def make_import(fn):
    return 'import qualified %s' % path_to_module(fn)

def path_to_module(path):
    return os.path.splitext(path)[0].replace('/', '.')

def make_tests(test_defs, init_funcs):
    out = []
    for fn, defs in test_defs.items():
        for (test_name, line, body) in defs:
            name = ''
            if fn in init_funcs:
                init = '(Just %s)' % init_funcs[fn]
                name += 'init-'
            else:
                name += 'direct-'
                init = 'Nothing'
            if has_interactive(body):
                name += 'interactive-'
            else:
                name += 'plain-'
            sym = '%s.%s' % (path_to_module(fn), test_name)
            name += sym
            out.append('Test %s %s %s %d %s'
                % (hs_str(name), sym, hs_str(fn), line, init))
    return out

def has_interactive(func_body):
    for (src, dest, is_interactive) in hs_pp.test_macros:
        if is_interactive and re.search(r'\b(%s|%s)\b'
            % (src, dest), func_body):
            return True
    return False

def hs_str(s):
    return '"%s"' % s.replace('"', '\\"').replace('\n', '\\n')


hs_template = r'''-- automatically generated by %(argv0)s --
import qualified Data.List as List
import qualified Data.Maybe as Maybe
import qualified System.Environment
import qualified Util.Test as Test


%(imports)s

data Test = Test
    { test_name :: String
    , test_test :: IO ()
    , test_file :: String
    , test_line :: Int
    , test_initialize :: Maybe (IO () -> IO ())
    }

all_tests = [
    %(all_tests)s
    ]

main :: IO ()
main = do
    args <- System.Environment.getArgs
    let printl vals = mapM_ putStrLn (List.sort vals)
    case args of
        "-list" : prefixes -> printl $ map test_name (matching_tests prefixes)
        prefixes -> let tests = matching_tests prefixes in do
            putStrLn $ "running: " ++ comma_list (map test_name tests)
            mapM_ run_test tests

matching_tests [] = all_tests
matching_tests prefixes =
    filter (\t -> any (`List.isPrefixOf` test_name t) prefixes) all_tests

run_test test = maybe id id (test_initialize test) $
    Test.catch_line (Just (test_file test, test_line test)) (test_test test)

comma_list = concat . List.intersperse ", "
'''


if __name__ == '__main__':
    main()
