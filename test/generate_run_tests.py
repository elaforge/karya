#!/usr/bin/env python
# Copyright 2013 Evan Laforge
# This program is distributed under the terms of the GNU General Public
# License 3.0, see COPYING or http://www.gnu.org/licenses/gpl-3.0.txt

"""usage: output.hs test_mod1.hs test_mod2.hs ...

Collect tests from the given modules and generate a haskell module that calls
the tests.  Test functions are any function starting with 'large_test_',
'test_' or 'profile_' and immediately followed by '=' (implying the function
has no arguments).  This module doesn't distinguish between tests and profiles,
but they should presumably be compiled separately since they required different
flags.

If a module has a function called 'initialize', it will be called as 'IO ()'
prior to the tests.

Tests are divided into interactive and auto variants.  Interactive tests want
to have a conversation with the user, so they're not appropriate to run
frequently.  Auto tests get an auto- prefix so you can avoid the interactive
ones.  TODO interactive should be removed
"""

import sys, os, re, subprocess


def main():
    if len(sys.argv) < 3:
        print ('usage: generate_run_tests.py output.hs input_test1.hs '
            'input_test2.hs ...')
        return 1

    out_fn = sys.argv[1]
    test_fns = sys.argv[2:]

    test_defs = {}
    init_funcs = {}
    for fn in test_fns:
        test_defs[fn], init_funcs[fn] = extract_defs(fn)
        if not test_defs[fn]:
            print >>sys.stderr, 'Warning: no (test|profile)_* defs in %r' % fn
        if not init_funcs[fn]:
            del init_funcs[fn]

    output = hs_template % {
        'generator': sys.argv[0],
        'imports': '\n'.join(map(make_import, test_fns)),
        'all_tests': ',\n    '.join(make_tests(test_defs, init_funcs)),
        'argv0': hs_str(out_fn[:-3]), # strip .hs
    }
    subprocess.call(['mkdir', '-p', os.path.dirname(out_fn)])
    out = open(out_fn, 'w')
    out.write(output)
    out.close()


init_func_re = re.compile(r'^initialize .*=', re.MULTILINE)

def extract_defs(fn):
    lines = list(open(fn))
    defs = get_defs(list(enumerate(lines)))
    if init_func_re.search(''.join(lines)):
        init_func = '%s.initialize' % path_to_module(fn)
    else:
        init_func = None
    return defs, init_func


def get_defs(lines):
    # regexes are not liking me, so functional it is
    if not lines:
        return []
    i, line = lines[0]
    i += 1 # enumerate starts from 0
    m = re.match(r'^(?:large_test|test|profile)_[a-zA-Z0-9_]+ \=', line)
    if m:
        body, rest = span(
            lambda (_, line): line.startswith(' ') or line == '\n', lines[1:])
        body = ''.join(line for (_, line) in body)
        head = line.split(None, 1)
        return [(i, head[0], head[1]+body)] + get_defs(rest)
    else:
        return get_defs(lines[1:])

def span(f, xs):
    pre = []
    i = 0
    for i, x in enumerate(xs):
        if f(x):
            pre.append(x)
        else:
            break
    return pre, xs[i:]

def make_import(fn):
    return 'import qualified %s' % path_to_module(fn)

def path_to_module(path):
    path = os.path.normpath(path)
    return os.path.splitext(path)[0].replace('/', '.')

def make_tests(test_defs, init_funcs):
    out = []
    for fn, defs in test_defs.items():
        has_initialize = fn in init_funcs
        for (lineno, test_name, body) in defs:
            if fn in init_funcs:
                init = '(Just %s)' % init_funcs[fn]
            else:
                init = 'Nothing'
            sym = '%s.%s' % (path_to_module(fn), test_name)
            out.append('Test %s (%s >> return ()) %s %d %s %s' % (
                hs_str(sym), sym, hs_str(fn), lineno, init,
                hs_str(test_type(has_initialize, test_name, body))))
    return out

def test_type(has_initialize, test_name, func_body):
    interactive = any(re.search(r'\b%s\b' % sym, func_body)
        for sym in ['io_human', 'io_human_line'])
    if interactive:
        return 'interactive'
    elif has_initialize:
        return 'gui'
    elif test_name.startswith('large_test_'):
        return 'large'
    else:
        return 'normal'

def hs_str(s):
    return '"%s"' % s.replace('"', '\\"').replace('\n', '\\n')

def hs_bool(b):
    return b and 'True' or 'False'


hs_template = r'''-- automatically generated by %(generator)s --
import qualified Util.RunTests as RunTests
import Util.RunTests (Test(..))

%(imports)s

-- System.Environment.getProgName strips the dir, so I can't use it to
-- reinvoke.
argv0 :: String
argv0 = %(argv0)s

tests :: [Test]
tests = [
    %(all_tests)s
    ]

main :: IO ()
main = RunTests.run argv0 tests
'''


if __name__ == '__main__':
    sys.exit(main())
