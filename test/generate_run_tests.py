#!/usr/bin/env python
"""usage: output.hs test_mod1.hs test_mod2.hs ...

Collect tests from the given modules and generate a haskell module that calls
the tests.  Test functions are any function starting with 'test_' or
'profile_'.  This module doesn't distinguish between tests and profiles, but
they should presumably be compiled separately since they required different
flags.

If a module has a function called 'initialize', it will be called as 'IO ()'
prior to the tests.  Since there is no tear down function, each test requiring
initialization will be called in its own subprocess. (TODO)

The generated haskell module takes a set of regexes, and will run tests that
match any regex.  If given a '--list' flag, it will just print the tests
instead of running them.

Tests are divided into interactive and auto variants.  Interactive tests want
to have a conversation with the user, so they're not appropriate to run
frequently.  Auto tests get an auto- prefix so you can avoid the interactive
ones.  TODO interactive should be removed
"""

import sys, os, re, subprocess


def main():
    if len(sys.argv) < 3:
        print ('usage: generate_run_tests.py output.hs input_test1.hs '
            'input_test2.hs ...')
        return 1

    out_fn = sys.argv[1]
    test_fns = sys.argv[2:]

    init_func = re.compile(r'^initialize .*=', re.MULTILINE)
    test_defs = {}
    init_funcs = {}
    for fn in test_fns:
        src = open(fn).read()
        lines = list(open(fn))
        test_defs[fn] = get_defs(list(enumerate(lines)))
        if not test_defs[fn]:
            print >>sys.stderr, 'Warning: no test_* defs in %r' % fn
        if init_func.search(''.join(lines)):
            init_funcs[fn] = '%s.initialize' % path_to_module(fn)

    output = hs_template % {
        'argv0': sys.argv[0],
        'imports': '\n'.join(map(make_import, test_fns)),
        'all_tests': ',\n    '.join(make_tests(test_defs, init_funcs)),
    }
    subprocess.call(['mkdir', '-p', os.path.dirname(out_fn)])
    out = open(out_fn, 'w')
    out.write(output)
    out.close()


def get_defs(lines):
    # regexes are not liking me, so functional it is
    if not lines:
        return []
    i, line = lines[0]
    i += 1 # enumerate starts from 0
    m = re.match(r'^(?:test|profile)_[a-zA-Z0-9_]+ \=', line)
    if m:
        body, rest = span(
            lambda (_, line): line.startswith(' ') or line == '\n', lines[1:])
        body = ''.join(line for (_, line) in body)
        head = line.split(None, 1)
        return [(i, head[0], head[1]+body)] + get_defs(rest)
    else:
        return get_defs(lines[1:])

def span(f, xs):
    pre = []
    for i, x in enumerate(xs):
        if f(x):
            pre.append(x)
        else:
            break
    return pre, xs[i:]

def make_import(fn):
    return 'import qualified %s' % path_to_module(fn)

def path_to_module(path):
    return os.path.splitext(path)[0].replace('/', '.')

def make_tests(test_defs, init_funcs):
    out = []
    for fn, defs in test_defs.items():
        for (lineno, test_name, body) in defs:
            if fn in init_funcs:
                init = '(Just %s)' % init_funcs[fn]
            else:
                init = 'Nothing'
            sym = '%s.%s' % (path_to_module(fn), test_name)
            out.append('Test %s (%s >> return ()) %s %d %s %s' % (
                hs_str(sym), sym, hs_str(fn), lineno, init,
                hs_bool(is_interactive(body))))
    return out

def is_interactive(func_body):
    interactive = ['io_human', 'io_human_line']
    for sym in interactive:
        if re.search(r'\b%s\b' % sym, func_body):
            return True
    return False

def hs_str(s):
    return '"%s"' % s.replace('"', '\\"').replace('\n', '\\n')

def hs_bool(b):
    return b and 'True' or 'False'


hs_template = r'''-- automatically generated by %(argv0)s --
import qualified Data.List as List
import qualified Data.IORef as IORef
import qualified System.Environment
import qualified System.Console.GetOpt as GetOpt

import qualified Util.Regex as Regex
import qualified Util.Seq as Seq
import qualified Util.Test as Test

%(imports)s


data Test = Test
    { test_sym_name :: String
    , test_test :: IO ()
    , test_file :: String
    , test_line :: Int
    , test_initialize :: Maybe (IO () -> IO ())
    , test_interactive :: Bool
    }

test_name :: Test -> String
test_name test = prefix ++ "-" ++ test_sym_name test
    where
    prefix
        | test_interactive test = "interactive"
        | otherwise = "auto"

all_tests :: [Test]
all_tests = [
    %(all_tests)s
    ]

data Flag = List | Skip deriving (Eq, Show)

options :: [GetOpt.OptDescr Flag]
options =
    [ GetOpt.Option [] ["list"] (GetOpt.NoArg List) "display but don't run"
    , GetOpt.Option [] ["skip"] (GetOpt.NoArg Skip)
        "run though interactive tests without asking"
    ]

main :: IO ()
main = do
    args <- System.Environment.getArgs
    (flags, args) <- case GetOpt.getOpt GetOpt.Permute options args of
        (opts, n, []) -> return (opts, n)
        (_, _, errs) -> error $ "errors:\n" ++ concat errs
    run flags args

run :: [Flag] -> [String] -> IO ()
run flags args
    | List `elem` flags = print_tests
    | Skip `elem` flags = do
        IORef.writeIORef Test.skip_human True
        print_tests
        mapM_ run_test tests
    | otherwise = do
        print_tests
        mapM_ run_test tests
    where
    tests = matching_tests args
    print_tests = print_sorted (map test_name tests)

print_sorted vals = mapM_ putStrLn (List.sort vals)

matching_tests :: [String] -> [Test]
matching_tests [] = all_tests
matching_tests patterns =
    filter (\t -> any (flip Regex.matches (test_name t)) regs) all_tests
    where regs = map Regex.make patterns

run_test test = do
    putStrLn $ "---------- run test "
        ++ test_file test ++ ": " ++ test_name test
    let name = last (Seq.split "." (test_name test))
    maybe id id (test_initialize test) $
        Test.catch_srcpos
            (Just (test_file test, Just name, test_line test)) (test_test test)
'''


if __name__ == '__main__':
    sys.exit(main())
