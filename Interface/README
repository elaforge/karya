There are three main UI objects: Block, Track, and Event, each contained within
the other.  Blocks and Tracks have a corresponding BlockView and TrackView that
represent the display aspects.  This is so a single Block can have multiple
windows, and a single Track may appear in different blocks.

There is no EventView because the blocks-as-macros functionality should allow
you to put a single event in multiple places already.

measures <- Ruler.create_marklist [mark, ..]
sections <- Ruler.create_marklist [...]
ruler1 <- Ruler.create bg_color [measures, sections]

block1 <- Block.create block_model_config
block2 <- Block.create block_model_config

-- two views of one block
view1a <- Block.view block_view_config block1
view1b <- Block.view block_view_config block1
Block.zoom view1b (Zoom 1.5sec 2)
Block.close view1b -- destroy view

track1 <- Track.create
Block.set_ruler_track block1 ruler1 20
Block.insert_track block1 0 (Block.R ruler1) 20
Block.insert_track block1 1 (Block.T (ruler1, track1)) 60
Block.insert_track block1 2 (Block.D Color.blue) 5

-- block2 also has the same track
Block.insert_track block2 0 (Block.T (ruler1, track1)) 100


kbd_map = [
    (Key.down_arrow, \active -> next_minor (Event.active_block active)),
    (Key.insert, \active -> insert_event (Event.active_track active)),
]

ins_sel = 0
next_minor blockv = do
    pos <- Block.selection blockv ins_sel
    ruler <- Block.get_ruler_track (Block.model blockv)
    sel <- Block.get_selection blockv ins_sel
    Block.set_selection blockv ins_sel (next_mark (rank 1) ruler (sel_pos sel))

insert_event blockv trackv = do
    pos <- Block.selection blockv ins_sel
    Track.insert_event (Track.model trackv) ""


threading
A haskell thread, in its own os thread, loops on Fl::wait(), passing back
events as they come.  Every time wait() returns, it clears out a channel of
incoming IO actions to perform on the UI.  Sending an action on the channel
triggers the wait() to release, by calling Fl::awake().



The 'send' function ships actions to the ui thread to execute.  To keep the ui
thread from doing too much work I should make sure it's strict as possible.
Easiest way I can think of to do this is to only send c_something calls since
the args have been serialized... or could that by lazy too?

Or, I can have the various args get !s?


The problem is to always execute actions from the same thread.  Solutions:

Need to be single threaded:
create view
modify view (model modification counts too)

Don't need to be single threaded:
query model
query view (make sure that all values are stored in the class, not the widget,
so e.g. title is set by fl_input callback)

Onle the write actions should trigger coming out of wait()... but then I guess
even reads should be serialized.  If there are certain things that get called
a lot maybe I could put the lock in the c++?

In any case, it would be good to abstract away 'send_action' so I just call the
functions and they work right.


    Implementation

The XImpl modules implement the actual c interface.  The corresponding
X modules call send_action as necessary, first fully evaluating their arguments
to prevent the ui thread hanging up on thunks.

The opaque raw implementation types Block, BlockView, etc. contain the pointer
or foreign pointer to the C structure and then auxiliary haskell data along for
the ride.  Some of this data (e.g. the Block of a BlockView) could technically
be derived from the C struct, but it's easier to get it from the haskell type.
