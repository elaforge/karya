The basic idea is fairly simple:

Each block has an attached schema.  The schema is used with the block to
produce a deriver, which is simply a function (in the DeriverT monad) that
produces [Score.Event].

Now the deriver can work any way it wants, but the default setup is that
the schema parses the block into a hierarchy of note tracks and controller
tracks called a skeleton, where the controller tracks have scope over certain
note tracks.

The skeleton is used to generate a single deriver, which consists of nested
derivers for each track, which may interpret a track, merge multiple event
streams, or whatever.

Controller tracks are interpreted (by a deriver function) as a simple language
with primitives to describe points and interpolation between them: flat,
linear, curved, etc.  These control curves go into an environment of
(Controller, Signal) pairs.

The note tracks are evaluated in the environment established by the controller
tracks, and like any deriver they have access to the controllers and their
signals.  The note tracks are expected to produce [Score.Event], but can do
so in a non-trivial manner, depending on the text of the event on the track and
its context.

How this happens is that there is yet another environment which is used to look
up a deriver for that particular event.  The returned deriver is then run as
a sub-derivation, so each event effectively acts as a function call.  The
sub-derivation may immediately return events based on the event text, or may
turn around and derive a whole other block, and so on recursively.

All the important aspects of the events are derived from the environment.  The
most important signal from the environment is the warp.  This is a signal
typically derived from controller tracks titled "tempo" which is
a transformation from score time to real time.  Derivers that produce events
by convention will look up the event's starting and ending times (as in the
track itself) in the warp to produce the event's starting time and duration.
Events by convention all begin at time 0 and have a duration of 1, and are
given their eventual start and duration by manipulating the tempo warp they are
evaluated in.

The warp signals themselves may be combined via composition (i.e. a relative
tempo transformation) or by just replacing one with another (i.e. an absolute
tempo transformation, for events that have the same duration regardless of the
tempo of their surroundings).

Another important signal is pitch.
... TODO


Controls

to "play" a control, it gets attached to the event
this is done by a function across the score

controls are created in the first place by adding them to the environment
this way, the control itself isn't looked at until the attacher function runs
intermediate layers can modify the controls (e.g. compose tempo maps, cancel
out transposition), or interpret them (e.g. act as a time dependent parameter
to a deriver).


what I want to be able to do:

transpose (const 5) (tracks)
(some_instrument tracks)

some_instrument tracks = do
    setenv transpose (const 5) tracks

other_inst score = map_score score $ \event ->
    if (getenv "magic" `at` event_start > 0.5)
        then transpose 10 (alter event) else event

transpose sig op = do
    modify_env "transpose" (+ sig) op

track track_id = do
    st <- get
    track <- get_track track_id
    return $ (Score.Score . map (Score.from_track_event track_id)
        . Track.event_list . Track.track_events) track


(transpose x y beh) -> (let ((x y)) beh)



Vocab: derive : Score -> Score, realize : Score -> NoteList

The Derive layer converts the raw block format (Score) to the NoteList format.
Derivation is the part of playing that doesn't depend on the backend.  The
NoteList format is a set of notes with start and end times, instrument data
(contents passed to the backend for interpretation), and controller curves
(stored as high level curve descriptions so the backend has the choice of how
to realize it).

Derive functions get EventAddresses for the events they process, so they can
report errors.

Derivation is actually a pipeline of derivers that all take Score -> Score, and
possibly display or update a derived track, and then a realizer that takes
Score -> NoteList.

Since derived blocks and tracks may be derived themselves, realizing a block
means deriving its parent blocks and so on.  To make this fast, blocks cache
their derivations and only recompute if the bock has been modified since the
cache, make-style.  So changes are displayed quickly, a background thread
refreshes the derivations when a block is modified.

Tempo
Some events should not undergo tempo modification, i.e. the attack of a note.
So there needs to be a way to set absolute tempo which overrides the tempo from
the environment.  In fact, absolute and relative versions of all controllers
would be useful.


Derivation is a set of composed derive functions.  Each one has type
'Score -> Derive Score'.  Derive is a monad which keeps log msgs (both status
reports and errors), and provides access to the derivation environment (String
-> Signal mapping).  Each derivation step is optionally exposed as a set of
Tracks.  Merging with a Block is also a derivation step.

When you hit "play" on a block, it should play the contents.  However, only
a realized score can be played, and only "sufficiently derived" scores can be
realized.  What's more, a block may have more than one derivation (say, before
and after tempo warping is applied).

So I need a definition of "sufficiently derived" so I can know for sure if
a given score is realizable.  Then, given a block, I can get a list of its
playable derivations.  Each block should have a "play" derivation explicitly
set in its Attrs.  If not, there's a heuristic that looks for the closest
realizable derivation, or sends an error if there is >1 realizable derivation.

    Realizable derivation

A Score that can be realized.  What this is depends on the backend.  After
running the derivation, I try to realize it and store the realization or error
msgs.  Derivations can set their results as explicitly unrealizable to save CPU
time or bypass this derivation in the search for closest realizable derivation.

    Keeping track of derivations

You should be able to hit a key and "descend" one level into derivation, or
have second block window with the derivation, or have a derived track next to
the source.

Derived block - A separate block with the derivation.

Stacked derivation - Hit a key on a block to "descend" one derivation level.
The derived block replaces the current one.

Derived track - Another track in the same block derived from one track.

So derivations can have scope over a whole block (tempo), or over a set of
tracks (triplet derivation, controller merging, ...).  They result in a set of
tracks, possibly preserving things like dividers and rulers.


    Block Attrs

    Track Attrs
random seed - so random processes are consistent

midi controller resolution - changeable dynamically per controller for effects,
also because lower resolution may not be noticable on some controllers.  So
this is a track level event, rather than a track attr.

Some events directly address the derivation environment, like interpolation
resolution.

    Derive monad
log msg -- Write to log msg output list.  Used for progress reports and error
msgs.  Another thread is reading this list as it becomes available, so reports
can be displayed as they are calculated.

log_error msg -- Like 'log', but abort further derivation.

dynamic_let key signal -- Attach the key to the event's environment.  This is
used to implement nyquist like behaviours, where lower levels of the
derivation, or the realizer, can decide how to interpret an arbitrary signal.

-- Score

data BlockData = BlockData String Score
data Score = Score
    { score_title :: String
    , score_attrs :: Attrs
    , score_tracks :: [Track]
    }

data Track = Track String Attrs [Event]


-- NoteList

data NoteList = NoteList [NoteList]

data Note = Note
    { start :: TrackPos
    , end :: TrackPos
    , instrument :: InstrumentData
    , controllers :: [ControllerCurve]
    }

type ControllerCurve = [CurveSegment]

data CurveSegment = CurveSegment InterpolationMethod [Point]
data InterpolationMethod = InterpolationMethod String
    -- Given the input points, give values at each of those points.
    -- This takes a list to a list to allow a more efficient implementation.
    (Points -> [TrackPos] -> [ControllerValue])
-- e.g. InterpolationMethod "linear" (\pts pos -> pts at pos)

type Points = Array (TrackPos, ControllerValue) -- sorted by TrackPos
type ControllerValue = Double

data InstrumentData
    = MidiInstrument MidiRender.InstrumentData
    | OscInstrument OscRender.InstrumentData
    | ...
